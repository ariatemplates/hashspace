/**
 * Utility methods to extract information from the intermediate representation (tree) generated by the parser
 */
var _ = require("underscore");

exports.create = function (tree) {
	var isTree = tree && tree.type === "template" && tree.name && tree.content;

	// Prototype of any element that is contained in the tree
	var contentElement = {
		/**
		 * Whether an element is of a given type
		 * @return {String} type Type to be checked
		 * @throws
		 */
		ofType : function (type) {
			if (!this.element) {
				throw new Error("Element " + this.path + " is undefined.");
			}
			if (this.element.type !== type) {
				// Surely enough this is not a text node
				throw new Error("Element " + this.path + " is not of type '" + type + "' but '" + this.element.type + "'.");
			}
		},

		/**
		 * Whether the element is a text node
		 * @param  {String}  content [Optinal] Text node content (trimmed for comparison)
		 * @throws
		 */
		isText : function (content) {
			this.ofType("text");

			if (content && this.element.value.trim() !== content.trim()) {
				// Content is different from what expected
				throw new Error("Text Element " + this.path + " doesn't match '" + content.trim() + "'. Value: '" + this.element.value + "'.");
			}
		},

		/**
		 * Whether the element is a certain instruction
		 * @param  {String}  name Instruction name
		 * @throws
		 */
		isInstruction : function (name) {
			this.ofType("instruction");

			if (this.element.name !== name) {
				throw new Error("Instruction " + this.path + " is not of type '" + name + ", got '" + this.element.name + "'.");
			}
		},

		/**
		 * Whether the element is an HTML element.
		 * @param  {String}  tagName Tag name
		 * @throws
		 */
		isElement : function (tagName) {
			this.ofType("element");

			if (this.element.name !== tagName) {
				throw new Error("Element " + this.path + " is not a " + tagName + " but a " + this.element.name);
			}
		},

		/**
		 * Whether the current element is a variable or not. The path should be an array, while isBindModified is
		 * optional and defaults to false
		 * @param  {Array}   path            Path variable 'a.b.c' -> ['a', 'b', 'c']
		 * @param  {Boolean} isBindModified  Whether this variable has a binding modifier or not
		 * @throws
		 */
		isVariable : function (path, isBindModified) {
			isBindModified = isBindModified === true;
			this.ofType("value");

			var elementPath = this.element.args.join(".");
			var expectedPath = path.join(".");
			if (elementPath !== expectedPath) {
				throw new Error("Variable path in " + this.path + " is different from '" + expectedPath + "', got '" + elementPath + "'.");
			}
			if (this.element.bind !== isBindModified) {
				throw new Error("Variable binding in " + this.path + " is different from '" + isBindModified + "', got '" + this.element.bind + "'.");
			}
		},

		/**
		 * Whether the current element is a for loop.
		 * @param  {String} iterator     Name of the variable created by the loop
		 * @param  {String} keyword      Like 'in' or 'of'
		 * @param  {Array}  collection   Path of the element on which we loop
		 * @throws
		 */
		isForLoop : function (iterator, keyword, collection) {
			this.ofType("instruction");
			if (this.element.name !== "foreach") {
				throw new Error("Element " + this.path + " is not a for loop. " + this.element.type + " " + this.element.name);
			}
			if (this.element.args.iterator !== iterator) {
				throw new Error("Iterator in for loop " + this.path + " is not '" + iterator + "', got '" + this.element.args.iterator + "'.");
			}
			if (this.element.args.keyword !== keyword) {
				throw new Error("Keyword in for loop " + this.path + " is not '" + keyword + "', got '" + this.element.args.keyword + "'.");
			}
			if (this.element.args.collection.type !== "ObjectIdentifier") {
				throw new Error("Collection in for loop " + this.path + " must be 'ObjectIdentifier', got '" + this.element.args.keyword + "'.");
			}
			var collectionString = this.element.args.collection.path.join(".");
			if (collectionString !== collection.join(".")) {
				throw new Error("Collection in for loop " + this.path + " is not '" + collection + "', got '" + this.element.args.collection.path + "'.");
			}
		},

		/**
		 * Whether the current element is an if statement.
		 * @param  {Array}    condition Path of the condition element
		 * @param  {Boolean}  haveElse  Whether the if has an else block. Default false
		 * @throws
		 */
		isIf : function (condition, haveElse) {
			haveElse = haveElse === true;
			this.ofType("instruction");

			if (this.element.name !== "if") {
				throw new Error("Element " + this.path + " is not an if statement. " + this.element.type + " " + this.element.name);
			}
			var conditionString = this.element.args.path.join(".");
			if (conditionString !== condition.join(".")) {
				throw new Error("Condition of 'if' statement " + this.path + " is not '" + condition + "', got '" + this.element.args.path + "'.");
			}
			// TODO else ?
		},

		/**
		 * Return a property of the current element
		 * @param  {String} what Property name
		 * @return {Object}
		 */
		get : function (what) {
			return this.element[what];
		},

		/**
		 * Return an helper around the n-th element contained in this element.
		 * @param  {Number} position Index
		 * @return {Object}
		 */
		n : function (position) {
			return Object.create(contentElement, {
				element : {
					writable : false,
					configurable : false,
					value : this.element.content[position]
				},
				path : {
					writable : false,
					configurable : false,
					value : this.path + ".content[" + position + "]"
				}
			});
		},

		/**
		 * Return an helper around the k-th element contained in the j-th content of this element.
		 * This is useful for elements with multiple content blocks
		 * @param  {Number} j Primary index, content[j]
		 * @param  {Number} k Secondary index, content[j][k]
		 * @return {Object}
		 */
		nn : function (j, k) {
			return Object.create(contentElement, {
				element : {
					writable : false,
					configurable : false,
					value : this.element.content[j][k]
				},
				path : {
					writable : false,
					configurable : false,
					value : this.path + ".content[" + j + "][" + k + "]"
				}
			});
		}
	};

	return Object.create({
		/**
		 * Is this a valid parsed tree
		 * @return {Boolean}
		 */
		isTree : function () {
			return isTree;
		},

		/**
		 * Whether the tree has as many content nodes as specified.
		 * @param  {Number}  howMany How many content nodes we expect, if null anything bigger than 0
		 * @return {Boolean}
		 */
		hasContent : function (howMany) {
			if (!isTree) {
				throw new Error("Invalid parse tree");
			}

			if (_.isNumber(howMany)) {
				return tree.content.length === howMany;
			} else {
				return tree.content.length > 0;
			}
		},

		/**
		 * Return an helper around the n-th element of the template, 0 based index.
		 * @param  {Number} position Index
		 * @return {Object}
		 */
		n : function (position) {
			return Object.create(contentElement, {
				element : {
					writable : false,
					configurable : false,
					value : this.tree.content[position]
				},
				path : {
					writable : false,
					configurable : false,
					value : "tree.content[" + position + "]"
				}
			});
		},

		/**
		 * Log in the console the tree structure.
		 * @param  {Object} tree
		 */
		log : function (tree) {
			console.log(require("util").inspect(this.tree, false, null, true));
		}
	}, {
		tree : {
			writable : false,
			configurable : false,
			value : tree
		}
	});
};