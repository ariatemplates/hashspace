(function(define) {
    define("hsp/compiler/parser/hspblocks.peg.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        module.exports = function() {
            /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
            function quote(s) {
                /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
                return '"' + s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
            }
            var result = {
                /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
                parse: function(input, startRule) {
                    var parseFunctions = {
                        TemplateFile: parse_TemplateFile,
                        TextBlock: parse_TextBlock,
                        RequireBlock: parse_RequireBlock,
                        TemplateBlock: parse_TemplateBlock,
                        TemplateStart: parse_TemplateStart,
                        TemplateController: parse_TemplateController,
                        ArgumentsDefinition: parse_ArgumentsDefinition,
                        InvalidTplArgs: parse_InvalidTplArgs,
                        TemplateEnd: parse_TemplateEnd,
                        TemplateContent: parse_TemplateContent,
                        TplTextBlock: parse_TplTextBlock,
                        TplTextChar: parse_TplTextChar,
                        InvalidBlock: parse_InvalidBlock,
                        IfBlock: parse_IfBlock,
                        ElseIfBlock: parse_ElseIfBlock,
                        ElseBlock: parse_ElseBlock,
                        EndIfBlock: parse_EndIfBlock,
                        CommentBlock: parse_CommentBlock,
                        HTMLCommentBlock: parse_HTMLCommentBlock,
                        HTMLCommentChar: parse_HTMLCommentChar,
                        ForeachBlock: parse_ForeachBlock,
                        ForeachArgs: parse_ForeachArgs,
                        ForeachArgs1: parse_ForeachArgs1,
                        ForeachArgs2: parse_ForeachArgs2,
                        EndForeachBlock: parse_EndForeachBlock,
                        HTMLElement: parse_HTMLElement,
                        HTMLElementAttributes: parse_HTMLElementAttributes,
                        EndHTMLElement: parse_EndHTMLElement,
                        HspComponent: parse_HspComponent,
                        EndHspComponent: parse_EndHspComponent,
                        HspCptAttribute: parse_HspCptAttribute,
                        EndHspCptAttribute: parse_EndHspCptAttribute,
                        InvalidHTMLElement: parse_InvalidHTMLElement,
                        HTMLName: parse_HTMLName,
                        HTMLAttName: parse_HTMLAttName,
                        HTMLAttribute: parse_HTMLAttribute,
                        HTMLAttributeValue: parse_HTMLAttributeValue,
                        HTMLAttributeText: parse_HTMLAttributeText,
                        HTMLAttributeChar: parse_HTMLAttributeChar,
                        LogBlock: parse_LogBlock,
                        LetBlock: parse_LetBlock,
                        LetAssignment: parse_LetAssignment,
                        ExpressionBlock: parse_ExpressionBlock,
                        HExpression: parse_HExpression,
                        HExpressionContent: parse_HExpressionContent,
                        HExpressionCssClassElt: parse_HExpressionCssClassElt,
                        InvalidExpressionValue: parse_InvalidExpressionValue,
                        S: parse_S,
                        _: parse__,
                        WhiteSpace: parse_WhiteSpace,
                        EOL: parse_EOL,
                        EOS: parse_EOS,
                        EOF: parse_EOF,
                        __: parse___,
                        Comment: parse_Comment,
                        MultiLineComment: parse_MultiLineComment,
                        SingleLineComment: parse_SingleLineComment,
                        JSObjectRef: parse_JSObjectRef,
                        JSLiteral: parse_JSLiteral,
                        SourceCharacter: parse_SourceCharacter,
                        Identifier: parse_Identifier,
                        IdentifierName: parse_IdentifierName,
                        IdentifierStart: parse_IdentifierStart,
                        VarIdentifier: parse_VarIdentifier,
                        VarIdentifierName: parse_VarIdentifierName,
                        VarIdentifierStart: parse_VarIdentifierStart,
                        IdentifierPart: parse_IdentifierPart,
                        Letter: parse_Letter,
                        Digit: parse_Digit,
                        ReservedWord: parse_ReservedWord,
                        Keyword: parse_Keyword,
                        FutureReservedWord: parse_FutureReservedWord,
                        NullLiteral: parse_NullLiteral,
                        BooleanLiteral: parse_BooleanLiteral,
                        NumericLiteral: parse_NumericLiteral,
                        HexIntegerLiteral: parse_HexIntegerLiteral,
                        HexDigit: parse_HexDigit,
                        DecimalLiteral: parse_DecimalLiteral,
                        DecimalIntegerLiteral: parse_DecimalIntegerLiteral,
                        DecimalDigits: parse_DecimalDigits,
                        DecimalDigit: parse_DecimalDigit,
                        NonZeroDigit: parse_NonZeroDigit,
                        ExponentPart: parse_ExponentPart,
                        ExponentIndicator: parse_ExponentIndicator,
                        SignedInteger: parse_SignedInteger,
                        StringLiteral: parse_StringLiteral,
                        DoubleStringCharacters: parse_DoubleStringCharacters,
                        SingleStringCharacters: parse_SingleStringCharacters,
                        DoubleStringCharacter: parse_DoubleStringCharacter,
                        SingleStringCharacter: parse_SingleStringCharacter,
                        EscapeSequence: parse_EscapeSequence,
                        CharacterEscapeSequence: parse_CharacterEscapeSequence,
                        SingleEscapeCharacter: parse_SingleEscapeCharacter,
                        NonEscapeCharacter: parse_NonEscapeCharacter,
                        EscapeCharacter: parse_EscapeCharacter,
                        HexEscapeSequence: parse_HexEscapeSequence,
                        UnicodeEscapeSequence: parse_UnicodeEscapeSequence,
                        PrimaryExpression: parse_PrimaryExpression,
                        ArrayLiteral: parse_ArrayLiteral,
                        ElementList: parse_ElementList,
                        Elision: parse_Elision,
                        ObjectLiteral: parse_ObjectLiteral,
                        PropertyNameAndValueList: parse_PropertyNameAndValueList,
                        PropertyAssignment: parse_PropertyAssignment,
                        PropertyName: parse_PropertyName,
                        MemberExpression: parse_MemberExpression,
                        CallExpression: parse_CallExpression,
                        Arguments: parse_Arguments,
                        ArgumentList: parse_ArgumentList,
                        LeftHandSideExpression: parse_LeftHandSideExpression,
                        PostfixExpression: parse_PostfixExpression,
                        PostfixOperator: parse_PostfixOperator,
                        UnaryExpression: parse_UnaryExpression,
                        UnaryOperator: parse_UnaryOperator,
                        MultiplicativeExpression: parse_MultiplicativeExpression,
                        MultiplicativeOperator: parse_MultiplicativeOperator,
                        AdditiveExpression: parse_AdditiveExpression,
                        AdditiveOperator: parse_AdditiveOperator,
                        ShiftExpression: parse_ShiftExpression,
                        ShiftOperator: parse_ShiftOperator,
                        RelationalExpression: parse_RelationalExpression,
                        RelationalOperator: parse_RelationalOperator,
                        RelationalExpressionNoIn: parse_RelationalExpressionNoIn,
                        RelationalOperatorNoIn: parse_RelationalOperatorNoIn,
                        EqualityExpression: parse_EqualityExpression,
                        EqualityExpressionNoIn: parse_EqualityExpressionNoIn,
                        EqualityOperator: parse_EqualityOperator,
                        BitwiseANDExpression: parse_BitwiseANDExpression,
                        BitwiseANDExpressionNoIn: parse_BitwiseANDExpressionNoIn,
                        BitwiseANDOperator: parse_BitwiseANDOperator,
                        BitwiseXORExpression: parse_BitwiseXORExpression,
                        BitwiseXORExpressionNoIn: parse_BitwiseXORExpressionNoIn,
                        BitwiseXOROperator: parse_BitwiseXOROperator,
                        BitwiseORExpression: parse_BitwiseORExpression,
                        BitwiseORExpressionNoIn: parse_BitwiseORExpressionNoIn,
                        BitwiseOROperator: parse_BitwiseOROperator,
                        LogicalANDExpression: parse_LogicalANDExpression,
                        LogicalANDExpressionNoIn: parse_LogicalANDExpressionNoIn,
                        LogicalANDOperator: parse_LogicalANDOperator,
                        LogicalORExpression: parse_LogicalORExpression,
                        LogicalORExpressionNoIn: parse_LogicalORExpressionNoIn,
                        LogicalOROperator: parse_LogicalOROperator,
                        ConditionalExpression: parse_ConditionalExpression,
                        ConditionalExpressionNoIn: parse_ConditionalExpressionNoIn,
                        AssignmentExpression: parse_AssignmentExpression,
                        AssignmentExpressionNoIn: parse_AssignmentExpressionNoIn,
                        AssignmentOperator: parse_AssignmentOperator,
                        Expression: parse_Expression,
                        ExpressionNoIn: parse_ExpressionNoIn
                    };
                    if (startRule !== undefined) {
                        if (parseFunctions[startRule] === undefined) {
                            throw new Error("Invalid rule name: " + quote(startRule) + ".");
                        }
                    } else {
                        startRule = "TemplateFile";
                    }
                    var pos = {
                        offset: 0,
                        line: 1,
                        column: 1,
                        seenCR: false
                    };
                    var reportFailures = 0;
                    var rightmostFailuresPos = {
                        offset: 0,
                        line: 1,
                        column: 1,
                        seenCR: false
                    };
                    var rightmostFailuresExpected = [];
                    function padLeft(input, padding, length) {
                        var result = input;
                        var padLength = length - input.length;
                        for (var i = 0; i < padLength; i++) {
                            result = padding + result;
                        }
                        return result;
                    }
                    function escape(ch) {
                        var charCode = ch.charCodeAt(0);
                        var escapeChar;
                        var length;
                        if (charCode <= 255) {
                            escapeChar = "x";
                            length = 2;
                        } else {
                            escapeChar = "u";
                            length = 4;
                        }
                        return "\\" + escapeChar + padLeft(charCode.toString(16).toUpperCase(), "0", length);
                    }
                    function clone(object) {
                        var result = {};
                        for (var key in object) {
                            result[key] = object[key];
                        }
                        return result;
                    }
                    function advance(pos, n) {
                        var endOffset = pos.offset + n;
                        for (var offset = pos.offset; offset < endOffset; offset++) {
                            var ch = input.charAt(offset);
                            if (ch === "\n") {
                                if (!pos.seenCR) {
                                    pos.line++;
                                }
                                pos.column = 1;
                                pos.seenCR = false;
                            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                                pos.line++;
                                pos.column = 1;
                                pos.seenCR = true;
                            } else {
                                pos.column++;
                                pos.seenCR = false;
                            }
                        }
                        pos.offset += n;
                    }
                    function matchFailed(failure) {
                        if (pos.offset < rightmostFailuresPos.offset) {
                            return;
                        }
                        if (pos.offset > rightmostFailuresPos.offset) {
                            rightmostFailuresPos = clone(pos);
                            rightmostFailuresExpected = [];
                        }
                        rightmostFailuresExpected.push(failure);
                    }
                    function parse_TemplateFile() {
                        var result0, result1;
                        var pos0;
                        pos0 = clone(pos);
                        result0 = [];
                        result1 = parse_TemplateBlock();
                        if (result1 === null) {
                            result1 = parse_TextBlock();
                        }
                        while (result1 !== null) {
                            result0.push(result1);
                            result1 = parse_TemplateBlock();
                            if (result1 === null) {
                                result1 = parse_TextBlock();
                            }
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, blocks) {
                                return blocks;
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_TextBlock() {
                        var result0, result1, result2, result3, result4, result5, result6, result7;
                        var pos0, pos1, pos2, pos3, pos4;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        pos3 = clone(pos);
                        reportFailures++;
                        pos4 = clone(pos);
                        result1 = parse__();
                        if (result1 !== null) {
                            if (input.charCodeAt(pos.offset) === 35) {
                                result2 = "#";
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"#"');
                                }
                            }
                            if (result2 !== null) {
                                result3 = parse__();
                                if (result3 !== null) {
                                    if (input.substr(pos.offset, 8) === "template") {
                                        result4 = "template";
                                        advance(pos, 8);
                                    } else {
                                        result4 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"template"');
                                        }
                                    }
                                    if (result4 !== null) {
                                        result1 = [ result1, result2, result3, result4 ];
                                    } else {
                                        result1 = null;
                                        pos = clone(pos4);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos4);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos4);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos4);
                        }
                        reportFailures--;
                        if (result1 === null) {
                            result1 = "";
                        } else {
                            result1 = null;
                            pos = clone(pos3);
                        }
                        if (result1 !== null) {
                            pos3 = clone(pos);
                            reportFailures++;
                            pos4 = clone(pos);
                            result2 = parse__();
                            if (result2 !== null) {
                                if (input.charCodeAt(pos.offset) === 35) {
                                    result3 = "#";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"#"');
                                    }
                                }
                                if (result3 !== null) {
                                    result4 = parse__();
                                    if (result4 !== null) {
                                        if (/^[a-zA-Z0-9]/.test(input.charAt(pos.offset))) {
                                            result6 = input.charAt(pos.offset);
                                            advance(pos, 1);
                                        } else {
                                            result6 = null;
                                            if (reportFailures === 0) {
                                                matchFailed("[a-zA-Z0-9]");
                                            }
                                        }
                                        if (result6 !== null) {
                                            result5 = [];
                                            while (result6 !== null) {
                                                result5.push(result6);
                                                if (/^[a-zA-Z0-9]/.test(input.charAt(pos.offset))) {
                                                    result6 = input.charAt(pos.offset);
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed("[a-zA-Z0-9]");
                                                    }
                                                }
                                            }
                                        } else {
                                            result5 = null;
                                        }
                                        if (result5 !== null) {
                                            result6 = parse__();
                                            if (result6 !== null) {
                                                if (input.substr(pos.offset, 8) === "template") {
                                                    result7 = "template";
                                                    advance(pos, 8);
                                                } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"template"');
                                                    }
                                                }
                                                if (result7 !== null) {
                                                    result2 = [ result2, result3, result4, result5, result6, result7 ];
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos4);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos4);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos4);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos4);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos4);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos4);
                            }
                            reportFailures--;
                            if (result2 === null) {
                                result2 = "";
                            } else {
                                result2 = null;
                                pos = clone(pos3);
                            }
                            if (result2 !== null) {
                                pos3 = clone(pos);
                                reportFailures++;
                                pos4 = clone(pos);
                                if (input.charCodeAt(pos.offset) === 35) {
                                    result3 = "#";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"#"');
                                    }
                                }
                                if (result3 !== null) {
                                    result4 = parse__();
                                    if (result4 !== null) {
                                        if (input.substr(pos.offset, 7) === "require") {
                                            result5 = "require";
                                            advance(pos, 7);
                                        } else {
                                            result5 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"require"');
                                            }
                                        }
                                        if (result5 !== null) {
                                            result3 = [ result3, result4, result5 ];
                                        } else {
                                            result3 = null;
                                            pos = clone(pos4);
                                        }
                                    } else {
                                        result3 = null;
                                        pos = clone(pos4);
                                    }
                                } else {
                                    result3 = null;
                                    pos = clone(pos4);
                                }
                                reportFailures--;
                                if (result3 === null) {
                                    result3 = "";
                                } else {
                                    result3 = null;
                                    pos = clone(pos3);
                                }
                                if (result3 !== null) {
                                    result4 = [];
                                    if (/^[^\n\r]/.test(input.charAt(pos.offset))) {
                                        result5 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result5 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("[^\\n\\r]");
                                        }
                                    }
                                    while (result5 !== null) {
                                        result4.push(result5);
                                        if (/^[^\n\r]/.test(input.charAt(pos.offset))) {
                                            result5 = input.charAt(pos.offset);
                                            advance(pos, 1);
                                        } else {
                                            result5 = null;
                                            if (reportFailures === 0) {
                                                matchFailed("[^\\n\\r]");
                                            }
                                        }
                                    }
                                    if (result4 !== null) {
                                        result5 = parse_EOL();
                                        if (result5 !== null) {
                                            result1 = [ result1, result2, result3, result4, result5 ];
                                        } else {
                                            result1 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result1 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos2);
                        }
                        if (result1 !== null) {
                            result1 = function(offset, line, column, chars, eol) {
                                return chars.join("") + eol;
                            }(pos1.offset, pos1.line, pos1.column, result1[3], result1[4]);
                        }
                        if (result1 === null) {
                            pos = clone(pos1);
                        }
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                pos1 = clone(pos);
                                pos2 = clone(pos);
                                pos3 = clone(pos);
                                reportFailures++;
                                pos4 = clone(pos);
                                result1 = parse__();
                                if (result1 !== null) {
                                    if (input.charCodeAt(pos.offset) === 35) {
                                        result2 = "#";
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"#"');
                                        }
                                    }
                                    if (result2 !== null) {
                                        result3 = parse__();
                                        if (result3 !== null) {
                                            if (input.substr(pos.offset, 8) === "template") {
                                                result4 = "template";
                                                advance(pos, 8);
                                            } else {
                                                result4 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"template"');
                                                }
                                            }
                                            if (result4 !== null) {
                                                result1 = [ result1, result2, result3, result4 ];
                                            } else {
                                                result1 = null;
                                                pos = clone(pos4);
                                            }
                                        } else {
                                            result1 = null;
                                            pos = clone(pos4);
                                        }
                                    } else {
                                        result1 = null;
                                        pos = clone(pos4);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos4);
                                }
                                reportFailures--;
                                if (result1 === null) {
                                    result1 = "";
                                } else {
                                    result1 = null;
                                    pos = clone(pos3);
                                }
                                if (result1 !== null) {
                                    pos3 = clone(pos);
                                    reportFailures++;
                                    pos4 = clone(pos);
                                    result2 = parse__();
                                    if (result2 !== null) {
                                        if (input.charCodeAt(pos.offset) === 35) {
                                            result3 = "#";
                                            advance(pos, 1);
                                        } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"#"');
                                            }
                                        }
                                        if (result3 !== null) {
                                            result4 = parse__();
                                            if (result4 !== null) {
                                                if (/^[a-zA-Z0-9]/.test(input.charAt(pos.offset))) {
                                                    result6 = input.charAt(pos.offset);
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed("[a-zA-Z0-9]");
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result5 = [];
                                                    while (result6 !== null) {
                                                        result5.push(result6);
                                                        if (/^[a-zA-Z0-9]/.test(input.charAt(pos.offset))) {
                                                            result6 = input.charAt(pos.offset);
                                                            advance(pos, 1);
                                                        } else {
                                                            result6 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed("[a-zA-Z0-9]");
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    result5 = null;
                                                }
                                                if (result5 !== null) {
                                                    result6 = parse__();
                                                    if (result6 !== null) {
                                                        if (input.substr(pos.offset, 8) === "template") {
                                                            result7 = "template";
                                                            advance(pos, 8);
                                                        } else {
                                                            result7 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed('"template"');
                                                            }
                                                        }
                                                        if (result7 !== null) {
                                                            result2 = [ result2, result3, result4, result5, result6, result7 ];
                                                        } else {
                                                            result2 = null;
                                                            pos = clone(pos4);
                                                        }
                                                    } else {
                                                        result2 = null;
                                                        pos = clone(pos4);
                                                    }
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos4);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos4);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos4);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos4);
                                    }
                                    reportFailures--;
                                    if (result2 === null) {
                                        result2 = "";
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                    if (result2 !== null) {
                                        pos3 = clone(pos);
                                        reportFailures++;
                                        pos4 = clone(pos);
                                        if (input.charCodeAt(pos.offset) === 35) {
                                            result3 = "#";
                                            advance(pos, 1);
                                        } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"#"');
                                            }
                                        }
                                        if (result3 !== null) {
                                            result4 = parse__();
                                            if (result4 !== null) {
                                                if (input.substr(pos.offset, 7) === "require") {
                                                    result5 = "require";
                                                    advance(pos, 7);
                                                } else {
                                                    result5 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"require"');
                                                    }
                                                }
                                                if (result5 !== null) {
                                                    result3 = [ result3, result4, result5 ];
                                                } else {
                                                    result3 = null;
                                                    pos = clone(pos4);
                                                }
                                            } else {
                                                result3 = null;
                                                pos = clone(pos4);
                                            }
                                        } else {
                                            result3 = null;
                                            pos = clone(pos4);
                                        }
                                        reportFailures--;
                                        if (result3 === null) {
                                            result3 = "";
                                        } else {
                                            result3 = null;
                                            pos = clone(pos3);
                                        }
                                        if (result3 !== null) {
                                            result4 = [];
                                            if (/^[^\n\r]/.test(input.charAt(pos.offset))) {
                                                result5 = input.charAt(pos.offset);
                                                advance(pos, 1);
                                            } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed("[^\\n\\r]");
                                                }
                                            }
                                            while (result5 !== null) {
                                                result4.push(result5);
                                                if (/^[^\n\r]/.test(input.charAt(pos.offset))) {
                                                    result5 = input.charAt(pos.offset);
                                                    advance(pos, 1);
                                                } else {
                                                    result5 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed("[^\\n\\r]");
                                                    }
                                                }
                                            }
                                            if (result4 !== null) {
                                                result5 = parse_EOL();
                                                if (result5 !== null) {
                                                    result1 = [ result1, result2, result3, result4, result5 ];
                                                } else {
                                                    result1 = null;
                                                    pos = clone(pos2);
                                                }
                                            } else {
                                                result1 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result1 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result1 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                                if (result1 !== null) {
                                    result1 = function(offset, line, column, chars, eol) {
                                        return chars.join("") + eol;
                                    }(pos1.offset, pos1.line, pos1.column, result1[3], result1[4]);
                                }
                                if (result1 === null) {
                                    pos = clone(pos1);
                                }
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, lines) {
                                return {
                                    type: "plaintext",
                                    value: lines.join("")
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_RequireBlock() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse__();
                        if (result0 !== null) {
                            if (input.substr(pos.offset, 2) === "# ") {
                                result1 = "# ";
                                advance(pos, 2);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"# "');
                                }
                            }
                            if (result1 !== null) {
                                result2 = parse__();
                                if (result2 !== null) {
                                    if (input.substr(pos.offset, 7) === "require") {
                                        result3 = "require";
                                        advance(pos, 7);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"require"');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse__();
                                        if (result4 !== null) {
                                            result5 = parse_EOL();
                                            if (result5 === null) {
                                                result5 = parse_EOF();
                                            }
                                            if (result5 !== null) {
                                                result0 = [ result0, result1, result2, result3, result4, result5 ];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return {
                                    type: "require"
                                };
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("require block");
                        }
                        return result0;
                    }
                    function parse_TemplateBlock() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_TemplateStart();
                        if (result0 !== null) {
                            result1 = parse_TemplateContent();
                            result1 = result1 !== null ? result1 : "";
                            if (result1 !== null) {
                                result2 = parse_TemplateEnd();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, start, content, end) {
                                start.content = content;
                                if (end) {
                                    start.closed = true;
                                    start.endLine = end.line;
                                }
                                return start;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1], result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("template block");
                        }
                        return result0;
                    }
                    function parse_TemplateStart() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
                        var pos0, pos1, pos2, pos3;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse__();
                        if (result0 !== null) {
                            if (input.charCodeAt(pos.offset) === 35) {
                                result1 = "#";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"#"');
                                }
                            }
                            if (result1 !== null) {
                                result2 = parse__();
                                if (result2 !== null) {
                                    if (input.substr(pos.offset, 8) === "template") {
                                        result3 = "template";
                                        advance(pos, 8);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"template"');
                                        }
                                    }
                                    if (result3 === null) {
                                        pos2 = clone(pos);
                                        pos3 = clone(pos);
                                        if (/^[a-zA-Z0-9]/.test(input.charAt(pos.offset))) {
                                            result4 = input.charAt(pos.offset);
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed("[a-zA-Z0-9]");
                                            }
                                        }
                                        if (result4 !== null) {
                                            result3 = [];
                                            while (result4 !== null) {
                                                result3.push(result4);
                                                if (/^[a-zA-Z0-9]/.test(input.charAt(pos.offset))) {
                                                    result4 = input.charAt(pos.offset);
                                                    advance(pos, 1);
                                                } else {
                                                    result4 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed("[a-zA-Z0-9]");
                                                    }
                                                }
                                            }
                                        } else {
                                            result3 = null;
                                        }
                                        if (result3 !== null) {
                                            result4 = parse__();
                                            if (result4 !== null) {
                                                if (input.substr(pos.offset, 8) === "template") {
                                                    result5 = "template";
                                                    advance(pos, 8);
                                                } else {
                                                    result5 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"template"');
                                                    }
                                                }
                                                if (result5 !== null) {
                                                    result3 = [ result3, result4, result5 ];
                                                } else {
                                                    result3 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result3 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result3 = null;
                                            pos = clone(pos3);
                                        }
                                        if (result3 !== null) {
                                            result3 = function(offset, line, column, c) {
                                                return c.join("");
                                            }(pos2.offset, pos2.line, pos2.column, result3[0]);
                                        }
                                        if (result3 === null) {
                                            pos = clone(pos2);
                                        }
                                    }
                                    if (result3 !== null) {
                                        result5 = parse_S();
                                        if (result5 !== null) {
                                            result4 = [];
                                            while (result5 !== null) {
                                                result4.push(result5);
                                                result5 = parse_S();
                                            }
                                        } else {
                                            result4 = null;
                                        }
                                        if (result4 !== null) {
                                            result5 = parse_Identifier();
                                            if (result5 !== null) {
                                                result6 = parse_TemplateController();
                                                if (result6 === null) {
                                                    result6 = parse_ArgumentsDefinition();
                                                    if (result6 === null) {
                                                        result6 = parse_InvalidTplArgs();
                                                    }
                                                }
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                    result7 = parse__();
                                                    if (result7 !== null) {
                                                        result8 = parse_EOL();
                                                        if (result8 !== null) {
                                                            result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8 ];
                                                        } else {
                                                            result0 = null;
                                                            pos = clone(pos1);
                                                        }
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, m, name, args) {
                                var mod = "";
                                // modifier (e.g. "export")
                                if (m !== "template") {
                                    mod = m;
                                }
                                if (args && args.invalidTplArg) {
                                    if (mod) {
                                        mod += " ";
                                    }
                                    return {
                                        type: "invalidtemplate",
                                        line: line,
                                        column: column,
                                        code: "# " + mod + "template " + name + " " + args.invalidTplArg
                                    };
                                } else {
                                    if (args && args.ctl && args.constructor !== Array) {
                                        // this template uses a controller
                                        return {
                                            type: "template",
                                            name: name,
                                            mod: mod,
                                            controller: args.ctl,
                                            controllerRef: args.ctlref,
                                            line: line,
                                            column: column
                                        };
                                    }
                                    return {
                                        type: "template",
                                        name: name,
                                        mod: mod,
                                        args: args === "" ? [] : args,
                                        line: line,
                                        column: column
                                    };
                                }
                            }(pos0.offset, pos0.line, pos0.column, result0[3], result0[5], result0[6]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("template statement");
                        }
                        return result0;
                    }
                    function parse_TemplateController() {
                        var result0, result1, result2, result3, result4, result5, result6, result7;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result1 = parse_S();
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                result1 = parse_S();
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            if (input.substr(pos.offset, 5) === "using") {
                                result1 = "using";
                                advance(pos, 5);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"using"');
                                }
                            }
                            if (result1 !== null) {
                                result3 = parse_S();
                                if (result3 !== null) {
                                    result2 = [];
                                    while (result3 !== null) {
                                        result2.push(result3);
                                        result3 = parse_S();
                                    }
                                } else {
                                    result2 = null;
                                }
                                if (result2 !== null) {
                                    result3 = parse_Identifier();
                                    if (result3 !== null) {
                                        result4 = parse__();
                                        if (result4 !== null) {
                                            if (input.charCodeAt(pos.offset) === 58) {
                                                result5 = ":";
                                                advance(pos, 1);
                                            } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('":"');
                                                }
                                            }
                                            if (result5 !== null) {
                                                result6 = parse__();
                                                if (result6 !== null) {
                                                    result7 = parse_JSObjectRef();
                                                    if (result7 !== null) {
                                                        result0 = [ result0, result1, result2, result3, result4, result5, result6, result7 ];
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, ref, ctl) {
                                return {
                                    ctl: ctl,
                                    ctlref: ref
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[3], result0[7]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("controller");
                        }
                        return result0;
                    }
                    function parse_ArgumentsDefinition() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
                        var pos0, pos1, pos2, pos3;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse__();
                        if (result0 !== null) {
                            if (input.charCodeAt(pos.offset) === 40) {
                                result1 = "(";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"("');
                                }
                            }
                            if (result1 !== null) {
                                result2 = parse__();
                                if (result2 !== null) {
                                    result3 = parse_VarIdentifier();
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                        result4 = [];
                                        pos2 = clone(pos);
                                        pos3 = clone(pos);
                                        result5 = parse__();
                                        if (result5 !== null) {
                                            if (input.charCodeAt(pos.offset) === 44) {
                                                result6 = ",";
                                                advance(pos, 1);
                                            } else {
                                                result6 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('","');
                                                }
                                            }
                                            if (result6 !== null) {
                                                result7 = parse__();
                                                if (result7 !== null) {
                                                    result8 = parse_VarIdentifier();
                                                    if (result8 !== null) {
                                                        result5 = [ result5, result6, result7, result8 ];
                                                    } else {
                                                        result5 = null;
                                                        pos = clone(pos3);
                                                    }
                                                } else {
                                                    result5 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result5 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result5 = null;
                                            pos = clone(pos3);
                                        }
                                        if (result5 !== null) {
                                            result5 = function(offset, line, column, arg) {
                                                return arg;
                                            }(pos2.offset, pos2.line, pos2.column, result5[3]);
                                        }
                                        if (result5 === null) {
                                            pos = clone(pos2);
                                        }
                                        while (result5 !== null) {
                                            result4.push(result5);
                                            pos2 = clone(pos);
                                            pos3 = clone(pos);
                                            result5 = parse__();
                                            if (result5 !== null) {
                                                if (input.charCodeAt(pos.offset) === 44) {
                                                    result6 = ",";
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('","');
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result7 = parse__();
                                                    if (result7 !== null) {
                                                        result8 = parse_VarIdentifier();
                                                        if (result8 !== null) {
                                                            result5 = [ result5, result6, result7, result8 ];
                                                        } else {
                                                            result5 = null;
                                                            pos = clone(pos3);
                                                        }
                                                    } else {
                                                        result5 = null;
                                                        pos = clone(pos3);
                                                    }
                                                } else {
                                                    result5 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result5 = null;
                                                pos = clone(pos3);
                                            }
                                            if (result5 !== null) {
                                                result5 = function(offset, line, column, arg) {
                                                    return arg;
                                                }(pos2.offset, pos2.line, pos2.column, result5[3]);
                                            }
                                            if (result5 === null) {
                                                pos = clone(pos2);
                                            }
                                        }
                                        if (result4 !== null) {
                                            result5 = parse__();
                                            if (result5 !== null) {
                                                if (input.charCodeAt(pos.offset) === 41) {
                                                    result6 = ")";
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('")"');
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result0 = [ result0, result1, result2, result3, result4, result5, result6 ];
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, first, others) {
                                var args = first ? [ first ] : [];
                                if (others && others.length) args = args.concat(others);
                                return args;
                            }(pos0.offset, pos0.line, pos0.column, result0[3], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("arguments");
                        }
                        return result0;
                    }
                    function parse_InvalidTplArgs() {
                        var result0, result1, result2;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse__();
                        if (result0 !== null) {
                            if (/^[^\n\r]/.test(input.charAt(pos.offset))) {
                                result2 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[^\\n\\r]");
                                }
                            }
                            if (result2 !== null) {
                                result1 = [];
                                while (result2 !== null) {
                                    result1.push(result2);
                                    if (/^[^\n\r]/.test(input.charAt(pos.offset))) {
                                        result2 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("[^\\n\\r]");
                                        }
                                    }
                                }
                            } else {
                                result1 = null;
                            }
                            if (result1 !== null) {
                                pos2 = clone(pos);
                                reportFailures++;
                                result2 = parse_EOL();
                                reportFailures--;
                                if (result2 !== null) {
                                    result2 = "";
                                    pos = clone(pos2);
                                } else {
                                    result2 = null;
                                }
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return {
                                    invalidTplArg: chars.join("")
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_TemplateEnd() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse__();
                        if (result0 !== null) {
                            if (input.charCodeAt(pos.offset) === 35) {
                                result1 = "#";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"#"');
                                }
                            }
                            if (result1 !== null) {
                                result2 = parse__();
                                if (result2 !== null) {
                                    if (input.substr(pos.offset, 9) === "/template") {
                                        result3 = "/template";
                                        advance(pos, 9);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"/template"');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse__();
                                        if (result4 !== null) {
                                            result5 = parse_EOL();
                                            if (result5 === null) {
                                                result5 = parse_EOF();
                                            }
                                            if (result5 !== null) {
                                                result0 = [ result0, result1, result2, result3, result4, result5 ];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return {
                                    type: "/template",
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("template end statement");
                        }
                        return result0;
                    }
                    function parse_TemplateContent() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse__();
                        if (result0 !== null) {
                            result1 = [];
                            result2 = parse_TplTextBlock();
                            if (result2 === null) {
                                result2 = parse_CommentBlock();
                                if (result2 === null) {
                                    result2 = parse_HTMLCommentBlock();
                                    if (result2 === null) {
                                        result2 = parse_IfBlock();
                                        if (result2 === null) {
                                            result2 = parse_ElseIfBlock();
                                            if (result2 === null) {
                                                result2 = parse_ElseBlock();
                                                if (result2 === null) {
                                                    result2 = parse_EndIfBlock();
                                                    if (result2 === null) {
                                                        result2 = parse_ForeachBlock();
                                                        if (result2 === null) {
                                                            result2 = parse_EndForeachBlock();
                                                            if (result2 === null) {
                                                                result2 = parse_HTMLElement();
                                                                if (result2 === null) {
                                                                    result2 = parse_EndHTMLElement();
                                                                    if (result2 === null) {
                                                                        result2 = parse_HspComponent();
                                                                        if (result2 === null) {
                                                                            result2 = parse_EndHspComponent();
                                                                            if (result2 === null) {
                                                                                result2 = parse_HspCptAttribute();
                                                                                if (result2 === null) {
                                                                                    result2 = parse_EndHspCptAttribute();
                                                                                    if (result2 === null) {
                                                                                        result2 = parse_LetBlock();
                                                                                        if (result2 === null) {
                                                                                            result2 = parse_LogBlock();
                                                                                            if (result2 === null) {
                                                                                                result2 = parse_ExpressionBlock();
                                                                                                if (result2 === null) {
                                                                                                    result2 = parse_InvalidHTMLElement();
                                                                                                    if (result2 === null) {
                                                                                                        result2 = parse_InvalidBlock();
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                result2 = parse_TplTextBlock();
                                if (result2 === null) {
                                    result2 = parse_CommentBlock();
                                    if (result2 === null) {
                                        result2 = parse_HTMLCommentBlock();
                                        if (result2 === null) {
                                            result2 = parse_IfBlock();
                                            if (result2 === null) {
                                                result2 = parse_ElseIfBlock();
                                                if (result2 === null) {
                                                    result2 = parse_ElseBlock();
                                                    if (result2 === null) {
                                                        result2 = parse_EndIfBlock();
                                                        if (result2 === null) {
                                                            result2 = parse_ForeachBlock();
                                                            if (result2 === null) {
                                                                result2 = parse_EndForeachBlock();
                                                                if (result2 === null) {
                                                                    result2 = parse_HTMLElement();
                                                                    if (result2 === null) {
                                                                        result2 = parse_EndHTMLElement();
                                                                        if (result2 === null) {
                                                                            result2 = parse_HspComponent();
                                                                            if (result2 === null) {
                                                                                result2 = parse_EndHspComponent();
                                                                                if (result2 === null) {
                                                                                    result2 = parse_HspCptAttribute();
                                                                                    if (result2 === null) {
                                                                                        result2 = parse_EndHspCptAttribute();
                                                                                        if (result2 === null) {
                                                                                            result2 = parse_LetBlock();
                                                                                            if (result2 === null) {
                                                                                                result2 = parse_LogBlock();
                                                                                                if (result2 === null) {
                                                                                                    result2 = parse_ExpressionBlock();
                                                                                                    if (result2 === null) {
                                                                                                        result2 = parse_InvalidHTMLElement();
                                                                                                        if (result2 === null) {
                                                                                                            result2 = parse_InvalidBlock();
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, blocks) {
                                return blocks;
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("template content");
                        }
                        return result0;
                    }
                    function parse_TplTextBlock() {
                        var result0, result1;
                        var pos0;
                        reportFailures++;
                        pos0 = clone(pos);
                        result1 = parse_TplTextChar();
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                result1 = parse_TplTextChar();
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return {
                                    type: "text",
                                    value: chars.join(""),
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("text");
                        }
                        return result0;
                    }
                    function parse_TplTextChar() {
                        var result0, result1, result2;
                        var pos0, pos1, pos2, pos3;
                        reportFailures++;
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 2) === "\\{") {
                            result0 = "\\{";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"\\\\{"');
                            }
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "{";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            if (input.substr(pos.offset, 2) === "\\}") {
                                result0 = "\\}";
                                advance(pos, 2);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\\\\}"');
                                }
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column) {
                                    return "}";
                                }(pos0.offset, pos0.line, pos0.column);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                            if (result0 === null) {
                                pos0 = clone(pos);
                                if (input.substr(pos.offset, 2) === "\\n") {
                                    result0 = "\\n";
                                    advance(pos, 2);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"\\\\n"');
                                    }
                                }
                                if (result0 !== null) {
                                    result0 = function(offset, line, column) {
                                        return "\n";
                                    }(pos0.offset, pos0.line, pos0.column);
                                }
                                if (result0 === null) {
                                    pos = clone(pos0);
                                }
                                if (result0 === null) {
                                    pos0 = clone(pos);
                                    pos1 = clone(pos);
                                    result0 = parse_EOL();
                                    if (result0 !== null) {
                                        pos2 = clone(pos);
                                        reportFailures++;
                                        result1 = parse_TemplateEnd();
                                        reportFailures--;
                                        if (result1 !== null) {
                                            result1 = "";
                                            pos = clone(pos2);
                                        } else {
                                            result1 = null;
                                        }
                                        if (result1 !== null) {
                                            result0 = [ result0, result1 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                    if (result0 !== null) {
                                        result0 = function(offset, line, column) {
                                            return "";
                                        }(pos0.offset, pos0.line, pos0.column);
                                    }
                                    if (result0 === null) {
                                        pos = clone(pos0);
                                    }
                                    if (result0 === null) {
                                        pos0 = clone(pos);
                                        pos1 = clone(pos);
                                        result0 = parse_EOL();
                                        if (result0 !== null) {
                                            result1 = parse__();
                                            if (result1 !== null) {
                                                result0 = [ result0, result1 ];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                        if (result0 !== null) {
                                            result0 = function(offset, line, column) {
                                                return " ";
                                            }(pos0.offset, pos0.line, pos0.column);
                                        }
                                        if (result0 === null) {
                                            pos = clone(pos0);
                                        }
                                        if (result0 === null) {
                                            pos0 = clone(pos);
                                            pos1 = clone(pos);
                                            if (input.charCodeAt(pos.offset) === 35) {
                                                result0 = "#";
                                                advance(pos, 1);
                                            } else {
                                                result0 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"#"');
                                                }
                                            }
                                            if (result0 !== null) {
                                                pos2 = clone(pos);
                                                reportFailures++;
                                                pos3 = clone(pos);
                                                result1 = parse__();
                                                if (result1 !== null) {
                                                    if (input.substr(pos.offset, 9) === "/template") {
                                                        result2 = "/template";
                                                        advance(pos, 9);
                                                    } else {
                                                        result2 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"/template"');
                                                        }
                                                    }
                                                    if (result2 !== null) {
                                                        result1 = [ result1, result2 ];
                                                    } else {
                                                        result1 = null;
                                                        pos = clone(pos3);
                                                    }
                                                } else {
                                                    result1 = null;
                                                    pos = clone(pos3);
                                                }
                                                reportFailures--;
                                                if (result1 === null) {
                                                    result1 = "";
                                                } else {
                                                    result1 = null;
                                                    pos = clone(pos2);
                                                }
                                                if (result1 !== null) {
                                                    result0 = [ result0, result1 ];
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                            if (result0 !== null) {
                                                result0 = function(offset, line, column) {
                                                    return "#";
                                                }(pos0.offset, pos0.line, pos0.column);
                                            }
                                            if (result0 === null) {
                                                pos = clone(pos0);
                                            }
                                            if (result0 === null) {
                                                pos0 = clone(pos);
                                                pos1 = clone(pos);
                                                if (input.charCodeAt(pos.offset) === 47) {
                                                    result0 = "/";
                                                    advance(pos, 1);
                                                } else {
                                                    result0 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"/"');
                                                    }
                                                }
                                                if (result0 !== null) {
                                                    pos2 = clone(pos);
                                                    reportFailures++;
                                                    if (input.charCodeAt(pos.offset) === 47) {
                                                        result1 = "/";
                                                        advance(pos, 1);
                                                    } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"/"');
                                                        }
                                                    }
                                                    reportFailures--;
                                                    if (result1 === null) {
                                                        result1 = "";
                                                    } else {
                                                        result1 = null;
                                                        pos = clone(pos2);
                                                    }
                                                    if (result1 !== null) {
                                                        result0 = [ result0, result1 ];
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                                if (result0 !== null) {
                                                    result0 = function(offset, line, column) {
                                                        return "/";
                                                    }(pos0.offset, pos0.line, pos0.column);
                                                }
                                                if (result0 === null) {
                                                    pos = clone(pos0);
                                                }
                                                if (result0 === null) {
                                                    pos0 = clone(pos);
                                                    if (input.substr(pos.offset, 2) === "\\/") {
                                                        result0 = "\\/";
                                                        advance(pos, 2);
                                                    } else {
                                                        result0 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"\\\\/"');
                                                        }
                                                    }
                                                    if (result0 !== null) {
                                                        result0 = function(offset, line, column) {
                                                            return "/";
                                                        }(pos0.offset, pos0.line, pos0.column);
                                                    }
                                                    if (result0 === null) {
                                                        pos = clone(pos0);
                                                    }
                                                    if (result0 === null) {
                                                        pos0 = clone(pos);
                                                        if (input.substr(pos.offset, 3) === "\\//") {
                                                            result0 = "\\//";
                                                            advance(pos, 3);
                                                        } else {
                                                            result0 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed('"\\\\//"');
                                                            }
                                                        }
                                                        if (result0 !== null) {
                                                            result0 = function(offset, line, column) {
                                                                return "//";
                                                            }(pos0.offset, pos0.line, pos0.column);
                                                        }
                                                        if (result0 === null) {
                                                            pos = clone(pos0);
                                                        }
                                                        if (result0 === null) {
                                                            pos0 = clone(pos);
                                                            if (input.substr(pos.offset, 2) === "\\<") {
                                                                result0 = "\\<";
                                                                advance(pos, 2);
                                                            } else {
                                                                result0 = null;
                                                                if (reportFailures === 0) {
                                                                    matchFailed('"\\\\<"');
                                                                }
                                                            }
                                                            if (result0 !== null) {
                                                                result0 = function(offset, line, column) {
                                                                    return "<";
                                                                }(pos0.offset, pos0.line, pos0.column);
                                                            }
                                                            if (result0 === null) {
                                                                pos = clone(pos0);
                                                            }
                                                            if (result0 === null) {
                                                                if (/^[^{#\/<]/.test(input.charAt(pos.offset))) {
                                                                    result0 = input.charAt(pos.offset);
                                                                    advance(pos, 1);
                                                                } else {
                                                                    result0 = null;
                                                                    if (reportFailures === 0) {
                                                                        matchFailed("[^{#\\/<]");
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("text character");
                        }
                        return result0;
                    }
                    function parse_InvalidBlock() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            if (/^[^{}#]/.test(input.charAt(pos.offset))) {
                                result2 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[^{}#]");
                                }
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                if (/^[^{}#]/.test(input.charAt(pos.offset))) {
                                    result2 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[^{}#]");
                                    }
                                }
                            }
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 125) {
                                    result2 = "}";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"}"');
                                    }
                                }
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return {
                                    type: "invalidblock",
                                    code: chars.join(""),
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_IfBlock() {
                        var result0, result1, result2, result3, result4, result5, result6, result7;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 3) === "if ") {
                                    result2 = "if ";
                                    advance(pos, 3);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"if "');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        result4 = parse_HExpression();
                                        if (result4 !== null) {
                                            result5 = parse__();
                                            if (result5 !== null) {
                                                if (input.charCodeAt(pos.offset) === 125) {
                                                    result6 = "}";
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"}"');
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result7 = parse_EOS();
                                                    result7 = result7 !== null ? result7 : "";
                                                    if (result7 !== null) {
                                                        result0 = [ result0, result1, result2, result3, result4, result5, result6, result7 ];
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, expr) {
                                return {
                                    type: "if",
                                    condition: expr,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("if statement");
                        }
                        return result0;
                    }
                    function parse_ElseIfBlock() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 5) === "else ") {
                                    result2 = "else ";
                                    advance(pos, 5);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"else "');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        if (input.substr(pos.offset, 2) === "if") {
                                            result4 = "if";
                                            advance(pos, 2);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"if"');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result5 = parse__();
                                            if (result5 !== null) {
                                                result6 = parse_HExpression();
                                                if (result6 !== null) {
                                                    result7 = parse__();
                                                    if (result7 !== null) {
                                                        if (input.charCodeAt(pos.offset) === 125) {
                                                            result8 = "}";
                                                            advance(pos, 1);
                                                        } else {
                                                            result8 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed('"}"');
                                                            }
                                                        }
                                                        if (result8 !== null) {
                                                            result9 = parse_EOS();
                                                            result9 = result9 !== null ? result9 : "";
                                                            if (result9 !== null) {
                                                                result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8, result9 ];
                                                            } else {
                                                                result0 = null;
                                                                pos = clone(pos1);
                                                            }
                                                        } else {
                                                            result0 = null;
                                                            pos = clone(pos1);
                                                        }
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, expr) {
                                return {
                                    type: "elseif",
                                    condition: expr,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[6]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("elseif statement");
                        }
                        return result0;
                    }
                    function parse_ElseBlock() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 4) === "else") {
                                    result2 = "else";
                                    advance(pos, 4);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"else"');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 125) {
                                            result4 = "}";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"}"');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result5 = parse_EOS();
                                            result5 = result5 !== null ? result5 : "";
                                            if (result5 !== null) {
                                                result0 = [ result0, result1, result2, result3, result4, result5 ];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return {
                                    type: "else",
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_EndIfBlock() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 3) === "/if") {
                                    result2 = "/if";
                                    advance(pos, 3);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"/if"');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 125) {
                                            result4 = "}";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"}"');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result5 = parse_EOS();
                                            result5 = result5 !== null ? result5 : "";
                                            if (result5 !== null) {
                                                result0 = [ result0, result1, result2, result3, result4, result5 ];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return {
                                    type: "endif",
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_CommentBlock() {
                        var result0, result1, result2, result3;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse__();
                        if (result0 !== null) {
                            if (input.substr(pos.offset, 2) === "//") {
                                result1 = "//";
                                advance(pos, 2);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"//"');
                                }
                            }
                            if (result1 !== null) {
                                result2 = [];
                                if (/^[^\r\n]/.test(input.charAt(pos.offset))) {
                                    result3 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[^\\r\\n]");
                                    }
                                }
                                while (result3 !== null) {
                                    result2.push(result3);
                                    if (/^[^\r\n]/.test(input.charAt(pos.offset))) {
                                        result3 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("[^\\r\\n]");
                                        }
                                    }
                                }
                                if (result2 !== null) {
                                    pos2 = clone(pos);
                                    reportFailures++;
                                    result3 = parse_EOL();
                                    reportFailures--;
                                    if (result3 !== null) {
                                        result3 = "";
                                        pos = clone(pos2);
                                    } else {
                                        result3 = null;
                                    }
                                    if (result3 !== null) {
                                        result0 = [ result0, result1, result2, result3 ];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return {
                                    type: "comment",
                                    value: chars.join("")
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLCommentBlock() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.substr(pos.offset, 4) === "<!--") {
                            result0 = "<!--";
                            advance(pos, 4);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"<!--"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            result2 = parse_HTMLCommentChar();
                            while (result2 !== null) {
                                result1.push(result2);
                                result2 = parse_HTMLCommentChar();
                            }
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 3) === "-->") {
                                    result2 = "-->";
                                    advance(pos, 3);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"-->"');
                                    }
                                }
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return {
                                    type: "comment",
                                    value: chars.join("")
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLCommentChar() {
                        var result0, result1, result2;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        reportFailures++;
                        if (input.charCodeAt(pos.offset) === 45) {
                            result0 = "-";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"-"');
                            }
                        }
                        reportFailures--;
                        if (result0 === null) {
                            result0 = "";
                        } else {
                            result0 = null;
                            pos = clone(pos2);
                        }
                        if (result0 !== null) {
                            if (input.charCodeAt(pos.offset) === 45) {
                                result1 = "-";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"-"');
                                }
                            }
                            if (result1 !== null) {
                                pos2 = clone(pos);
                                reportFailures++;
                                if (input.charCodeAt(pos.offset) === 62) {
                                    result2 = ">";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('">"');
                                    }
                                }
                                reportFailures--;
                                if (result2 === null) {
                                    result2 = "";
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "-";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 45) {
                                result0 = "-";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"-"');
                                }
                            }
                            if (result0 !== null) {
                                pos2 = clone(pos);
                                reportFailures++;
                                if (input.substr(pos.offset, 2) === "->") {
                                    result1 = "->";
                                    advance(pos, 2);
                                } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"->"');
                                    }
                                }
                                reportFailures--;
                                if (result1 === null) {
                                    result1 = "";
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                                if (result1 !== null) {
                                    result0 = [ result0, result1 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column) {
                                    return "-";
                                }(pos0.offset, pos0.line, pos0.column);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                            if (result0 === null) {
                                pos0 = clone(pos);
                                pos1 = clone(pos);
                                pos2 = clone(pos);
                                reportFailures++;
                                if (input.substr(pos.offset, 2) === "--") {
                                    result0 = "--";
                                    advance(pos, 2);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"--"');
                                    }
                                }
                                reportFailures--;
                                if (result0 === null) {
                                    result0 = "";
                                } else {
                                    result0 = null;
                                    pos = clone(pos2);
                                }
                                if (result0 !== null) {
                                    if (input.charCodeAt(pos.offset) === 62) {
                                        result1 = ">";
                                        advance(pos, 1);
                                    } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('">"');
                                        }
                                    }
                                    if (result1 !== null) {
                                        result0 = [ result0, result1 ];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                                if (result0 !== null) {
                                    result0 = function(offset, line, column) {
                                        return ">";
                                    }(pos0.offset, pos0.line, pos0.column);
                                }
                                if (result0 === null) {
                                    pos = clone(pos0);
                                }
                                if (result0 === null) {
                                    if (/^[^>\-]/.test(input.charAt(pos.offset))) {
                                        result0 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("[^>\\-]");
                                        }
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_ForeachBlock() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
                        var pos0, pos1, pos2, pos3;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 8) === "foreach ") {
                                    result2 = "foreach ";
                                    advance(pos, 8);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"foreach "');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        result4 = parse_ForeachArgs();
                                        if (result4 === null) {
                                            pos2 = clone(pos);
                                            pos3 = clone(pos);
                                            if (input.charCodeAt(pos.offset) === 40) {
                                                result4 = "(";
                                                advance(pos, 1);
                                            } else {
                                                result4 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"("');
                                                }
                                            }
                                            if (result4 !== null) {
                                                result5 = parse__();
                                                if (result5 !== null) {
                                                    result6 = parse_ForeachArgs();
                                                    if (result6 !== null) {
                                                        result7 = parse__();
                                                        if (result7 !== null) {
                                                            if (input.charCodeAt(pos.offset) === 41) {
                                                                result8 = ")";
                                                                advance(pos, 1);
                                                            } else {
                                                                result8 = null;
                                                                if (reportFailures === 0) {
                                                                    matchFailed('")"');
                                                                }
                                                            }
                                                            if (result8 !== null) {
                                                                result4 = [ result4, result5, result6, result7, result8 ];
                                                            } else {
                                                                result4 = null;
                                                                pos = clone(pos3);
                                                            }
                                                        } else {
                                                            result4 = null;
                                                            pos = clone(pos3);
                                                        }
                                                    } else {
                                                        result4 = null;
                                                        pos = clone(pos3);
                                                    }
                                                } else {
                                                    result4 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result4 = null;
                                                pos = clone(pos3);
                                            }
                                            if (result4 !== null) {
                                                result4 = function(offset, line, column, a) {
                                                    return a;
                                                }(pos2.offset, pos2.line, pos2.column, result4[2]);
                                            }
                                            if (result4 === null) {
                                                pos = clone(pos2);
                                            }
                                        }
                                        if (result4 !== null) {
                                            result5 = parse__();
                                            if (result5 !== null) {
                                                if (input.charCodeAt(pos.offset) === 125) {
                                                    result6 = "}";
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"}"');
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result7 = parse_EOS();
                                                    result7 = result7 !== null ? result7 : "";
                                                    if (result7 !== null) {
                                                        result0 = [ result0, result1, result2, result3, result4, result5, result6, result7 ];
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, args) {
                                return {
                                    type: "foreach",
                                    item: args.item,
                                    key: args.key,
                                    colref: args.colref,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ForeachArgs() {
                        var result0;
                        result0 = parse_ForeachArgs1();
                        if (result0 === null) {
                            result0 = parse_ForeachArgs2();
                        }
                        return result0;
                    }
                    function parse_ForeachArgs1() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_VarIdentifier();
                        if (result0 !== null) {
                            if (input.charCodeAt(pos.offset) === 32) {
                                result1 = " ";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('" "');
                                }
                            }
                            if (result1 !== null) {
                                result2 = parse__();
                                if (result2 !== null) {
                                    if (input.substr(pos.offset, 3) === "in ") {
                                        result3 = "in ";
                                        advance(pos, 3);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"in "');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse__();
                                        if (result4 !== null) {
                                            result5 = parse_JSObjectRef();
                                            if (result5 !== null) {
                                                result0 = [ result0, result1, result2, result3, result4, result5 ];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, item, col) {
                                return {
                                    item: item,
                                    key: item + "_key",
                                    colref: col
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[5]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ForeachArgs2() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_VarIdentifier();
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 44) {
                                    result2 = ",";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('","');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        result4 = parse_VarIdentifier();
                                        if (result4 !== null) {
                                            if (input.charCodeAt(pos.offset) === 32) {
                                                result5 = " ";
                                                advance(pos, 1);
                                            } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('" "');
                                                }
                                            }
                                            if (result5 !== null) {
                                                result6 = parse__();
                                                if (result6 !== null) {
                                                    if (input.substr(pos.offset, 3) === "in ") {
                                                        result7 = "in ";
                                                        advance(pos, 3);
                                                    } else {
                                                        result7 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"in "');
                                                        }
                                                    }
                                                    if (result7 !== null) {
                                                        result8 = parse__();
                                                        if (result8 !== null) {
                                                            result9 = parse_JSObjectRef();
                                                            if (result9 !== null) {
                                                                result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8, result9 ];
                                                            } else {
                                                                result0 = null;
                                                                pos = clone(pos1);
                                                            }
                                                        } else {
                                                            result0 = null;
                                                            pos = clone(pos1);
                                                        }
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, key, item, col) {
                                return {
                                    item: item,
                                    key: key,
                                    colref: col
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[4], result0[9]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_EndForeachBlock() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 8) === "/foreach") {
                                    result2 = "/foreach";
                                    advance(pos, 8);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"/foreach"');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 125) {
                                            result4 = "}";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"}"');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return {
                                    type: "endforeach",
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLElement() {
                        var result0, result1, result2, result3, result4, result5, result6;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 60) {
                            result0 = "<";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"<"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_HTMLName();
                            if (result1 !== null) {
                                result2 = parse_HTMLElementAttributes();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    result3 = parse_S();
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 47) {
                                            result4 = "/";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"/"');
                                            }
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                            if (input.charCodeAt(pos.offset) === 62) {
                                                result5 = ">";
                                                advance(pos, 1);
                                            } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('">"');
                                                }
                                            }
                                            if (result5 !== null) {
                                                result6 = parse_EOS();
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                    result0 = [ result0, result1, result2, result3, result4, result5, result6 ];
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, name, atts, end) {
                                return {
                                    type: "element",
                                    name: name,
                                    closed: end !== "",
                                    attributes: atts,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1], result0[2], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLElementAttributes() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        result0 = [];
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result1 = parse_S();
                        if (result1 !== null) {
                            result2 = parse_HTMLAttribute();
                            if (result2 !== null) {
                                result1 = [ result1, result2 ];
                            } else {
                                result1 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result1 = null;
                            pos = clone(pos1);
                        }
                        if (result1 !== null) {
                            result1 = function(offset, line, column, att) {
                                return att;
                            }(pos0.offset, pos0.line, pos0.column, result1[1]);
                        }
                        if (result1 === null) {
                            pos = clone(pos0);
                        }
                        while (result1 !== null) {
                            result0.push(result1);
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            result1 = parse_S();
                            if (result1 !== null) {
                                result2 = parse_HTMLAttribute();
                                if (result2 !== null) {
                                    result1 = [ result1, result2 ];
                                } else {
                                    result1 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos1);
                            }
                            if (result1 !== null) {
                                result1 = function(offset, line, column, att) {
                                    return att;
                                }(pos0.offset, pos0.line, pos0.column, result1[1]);
                            }
                            if (result1 === null) {
                                pos = clone(pos0);
                            }
                        }
                        return result0;
                    }
                    function parse_EndHTMLElement() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.substr(pos.offset, 2) === "</") {
                            result0 = "</";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"</"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_HTMLName();
                            if (result1 !== null) {
                                result2 = parse_S();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 62) {
                                        result3 = ">";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('">"');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse_EOS();
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, name) {
                                return {
                                    type: "endelement",
                                    name: name,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HspComponent() {
                        var result0, result1, result2, result3, result4, result5, result6;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.substr(pos.offset, 2) === "<#") {
                            result0 = "<#";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"<#"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_JSObjectRef();
                            if (result1 !== null) {
                                result2 = parse_HTMLElementAttributes();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    result3 = parse_S();
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 47) {
                                            result4 = "/";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"/"');
                                            }
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                            if (input.charCodeAt(pos.offset) === 62) {
                                                result5 = ">";
                                                advance(pos, 1);
                                            } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('">"');
                                                }
                                            }
                                            if (result5 !== null) {
                                                result6 = parse_EOS();
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                    result0 = [ result0, result1, result2, result3, result4, result5, result6 ];
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, ref, atts, end) {
                                return {
                                    type: "component",
                                    ref: ref,
                                    closed: end !== "",
                                    attributes: atts,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1], result0[2], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_EndHspComponent() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.substr(pos.offset, 3) === "</#") {
                            result0 = "</#";
                            advance(pos, 3);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"</#"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_JSObjectRef();
                            if (result1 !== null) {
                                result2 = parse_S();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 62) {
                                        result3 = ">";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('">"');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse_EOS();
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, ref) {
                                return {
                                    type: "endcomponent",
                                    ref: ref,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HspCptAttribute() {
                        var result0, result1, result2, result3, result4, result5, result6;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.substr(pos.offset, 2) === "<@") {
                            result0 = "<@";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"<@"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_VarIdentifier();
                            if (result1 !== null) {
                                result2 = parse_HTMLElementAttributes();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    result3 = parse_S();
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 47) {
                                            result4 = "/";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"/"');
                                            }
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                            if (input.charCodeAt(pos.offset) === 62) {
                                                result5 = ">";
                                                advance(pos, 1);
                                            } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('">"');
                                                }
                                            }
                                            if (result5 !== null) {
                                                result6 = parse_EOS();
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                    result0 = [ result0, result1, result2, result3, result4, result5, result6 ];
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, ref, atts, end) {
                                return {
                                    type: "cptattribute",
                                    name: ref,
                                    closed: end !== "",
                                    attributes: atts,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1], result0[2], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_EndHspCptAttribute() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.substr(pos.offset, 3) === "</@") {
                            result0 = "</@";
                            advance(pos, 3);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"</@"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_VarIdentifier();
                            if (result1 !== null) {
                                result2 = parse_S();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 62) {
                                        result3 = ">";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('">"');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse_EOS();
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, ref) {
                                return {
                                    type: "endcptattribute",
                                    name: ref,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_InvalidHTMLElement() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 60) {
                            result0 = "<";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"<"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            if (/^[^\r\n]/.test(input.charAt(pos.offset))) {
                                result2 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[^\\r\\n]");
                                }
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                if (/^[^\r\n]/.test(input.charAt(pos.offset))) {
                                    result2 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[^\\r\\n]");
                                    }
                                }
                            }
                            if (result1 !== null) {
                                result2 = parse_EOL();
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, code) {
                                return {
                                    type: "invalidelement",
                                    code: "<" + code.join(""),
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLName() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (/^[a-z]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[a-z]");
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            if (/^[a-z]/.test(input.charAt(pos.offset))) {
                                result2 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[a-z]");
                                }
                            }
                            if (result2 === null) {
                                if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                    result2 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[0-9]");
                                    }
                                }
                                if (result2 === null) {
                                    if (input.charCodeAt(pos.offset) === 45) {
                                        result2 = "-";
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"-"');
                                        }
                                    }
                                }
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                if (/^[a-z]/.test(input.charAt(pos.offset))) {
                                    result2 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[a-z]");
                                    }
                                }
                                if (result2 === null) {
                                    if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                        result2 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("[0-9]");
                                        }
                                    }
                                    if (result2 === null) {
                                        if (input.charCodeAt(pos.offset) === 45) {
                                            result2 = "-";
                                            advance(pos, 1);
                                        } else {
                                            result2 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"-"');
                                            }
                                        }
                                    }
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, first, next) {
                                return first + next.join("");
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLAttName() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (/^[a-zA-Z#]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[a-zA-Z#]");
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            if (/^[a-zA-Z]/.test(input.charAt(pos.offset))) {
                                result2 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[a-zA-Z]");
                                }
                            }
                            if (result2 === null) {
                                if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                    result2 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[0-9]");
                                    }
                                }
                                if (result2 === null) {
                                    if (input.charCodeAt(pos.offset) === 45) {
                                        result2 = "-";
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"-"');
                                        }
                                    }
                                }
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                if (/^[a-zA-Z]/.test(input.charAt(pos.offset))) {
                                    result2 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[a-zA-Z]");
                                    }
                                }
                                if (result2 === null) {
                                    if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                        result2 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("[0-9]");
                                        }
                                    }
                                    if (result2 === null) {
                                        if (input.charCodeAt(pos.offset) === 45) {
                                            result2 = "-";
                                            advance(pos, 1);
                                        } else {
                                            result2 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"-"');
                                            }
                                        }
                                    }
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, first, next) {
                                return first + next.join("");
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLAttribute() {
                        var result0, result1, result2, result3, result4, result5, result6;
                        var pos0, pos1, pos2, pos3;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_HTMLAttName();
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            pos3 = clone(pos);
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 61) {
                                    result2 = "=";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"="');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 34) {
                                            result4 = '"';
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"\\""');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result5 = parse_HTMLAttributeValue();
                                            if (result5 !== null) {
                                                if (input.charCodeAt(pos.offset) === 34) {
                                                    result6 = '"';
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"\\""');
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result1 = [ result1, result2, result3, result4, result5, result6 ];
                                                } else {
                                                    result1 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result1 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result1 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result1 = null;
                                        pos = clone(pos3);
                                    }
                                } else {
                                    result1 = null;
                                    pos = clone(pos3);
                                }
                            } else {
                                result1 = null;
                                pos = clone(pos3);
                            }
                            if (result1 !== null) {
                                result1 = function(offset, line, column, value) {
                                    return value;
                                }(pos2.offset, pos2.line, pos2.column, result1[4]);
                            }
                            if (result1 === null) {
                                pos = clone(pos2);
                            }
                            result1 = result1 !== null ? result1 : "";
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, name, v) {
                                return {
                                    type: "attribute",
                                    name: name,
                                    value: v,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLAttributeValue() {
                        var result0, result1;
                        result0 = [];
                        result1 = parse_HTMLAttributeText();
                        if (result1 === null) {
                            result1 = parse_ExpressionBlock();
                        }
                        while (result1 !== null) {
                            result0.push(result1);
                            result1 = parse_HTMLAttributeText();
                            if (result1 === null) {
                                result1 = parse_ExpressionBlock();
                            }
                        }
                        return result0;
                    }
                    function parse_HTMLAttributeText() {
                        var result0, result1;
                        var pos0;
                        pos0 = clone(pos);
                        result1 = parse_HTMLAttributeChar();
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                result1 = parse_HTMLAttributeChar();
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return {
                                    type: "text",
                                    value: chars.join("")
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HTMLAttributeChar() {
                        var result0;
                        var pos0;
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 2) === "\\{") {
                            result0 = "\\{";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"\\\\{"');
                            }
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "{";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            if (input.substr(pos.offset, 2) === '\\"') {
                                result0 = '\\"';
                                advance(pos, 2);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\\\\\\""');
                                }
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column) {
                                    return '"';
                                }(pos0.offset, pos0.line, pos0.column);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                            if (result0 === null) {
                                if (/^[^{"\n\r]/.test(input.charAt(pos.offset))) {
                                    result0 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('[^{"\\n\\r]');
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_LogBlock() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 4) === "log ") {
                                    result2 = "log ";
                                    advance(pos, 4);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"log "');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        result4 = parse_HExpressionContent();
                                        if (result4 !== null) {
                                            result5 = parse__();
                                            if (result5 !== null) {
                                                result6 = [];
                                                pos2 = clone(pos);
                                                if (input.charCodeAt(pos.offset) === 44) {
                                                    result7 = ",";
                                                    advance(pos, 1);
                                                } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('","');
                                                    }
                                                }
                                                if (result7 !== null) {
                                                    result8 = parse__();
                                                    if (result8 !== null) {
                                                        result9 = parse_HExpressionContent();
                                                        if (result9 !== null) {
                                                            result7 = [ result7, result8, result9 ];
                                                        } else {
                                                            result7 = null;
                                                            pos = clone(pos2);
                                                        }
                                                    } else {
                                                        result7 = null;
                                                        pos = clone(pos2);
                                                    }
                                                } else {
                                                    result7 = null;
                                                    pos = clone(pos2);
                                                }
                                                while (result7 !== null) {
                                                    result6.push(result7);
                                                    pos2 = clone(pos);
                                                    if (input.charCodeAt(pos.offset) === 44) {
                                                        result7 = ",";
                                                        advance(pos, 1);
                                                    } else {
                                                        result7 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('","');
                                                        }
                                                    }
                                                    if (result7 !== null) {
                                                        result8 = parse__();
                                                        if (result8 !== null) {
                                                            result9 = parse_HExpressionContent();
                                                            if (result9 !== null) {
                                                                result7 = [ result7, result8, result9 ];
                                                            } else {
                                                                result7 = null;
                                                                pos = clone(pos2);
                                                            }
                                                        } else {
                                                            result7 = null;
                                                            pos = clone(pos2);
                                                        }
                                                    } else {
                                                        result7 = null;
                                                        pos = clone(pos2);
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result7 = parse__();
                                                    if (result7 !== null) {
                                                        if (input.charCodeAt(pos.offset) === 125) {
                                                            result8 = "}";
                                                            advance(pos, 1);
                                                        } else {
                                                            result8 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed('"}"');
                                                            }
                                                        }
                                                        if (result8 !== null) {
                                                            result9 = parse_EOS();
                                                            result9 = result9 !== null ? result9 : "";
                                                            if (result9 !== null) {
                                                                result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8, result9 ];
                                                            } else {
                                                                result0 = null;
                                                                pos = clone(pos1);
                                                            }
                                                        } else {
                                                            result0 = null;
                                                            pos = clone(pos1);
                                                        }
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, first, next) {
                                var exprs = [ first ];
                                if (next) {
                                    for (var i = 0, sz = next.length; sz > i; i++) {
                                        exprs.push(next[i][2]);
                                    }
                                }
                                return {
                                    type: "log",
                                    exprs: exprs,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[4], result0[6]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LetBlock() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 4) === "let ") {
                                    result2 = "let ";
                                    advance(pos, 4);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"let "');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        result4 = parse_LetAssignment();
                                        if (result4 !== null) {
                                            result5 = parse__();
                                            if (result5 !== null) {
                                                result6 = [];
                                                pos2 = clone(pos);
                                                if (input.charCodeAt(pos.offset) === 44) {
                                                    result7 = ",";
                                                    advance(pos, 1);
                                                } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('","');
                                                    }
                                                }
                                                if (result7 !== null) {
                                                    result8 = parse__();
                                                    if (result8 !== null) {
                                                        result9 = parse_LetAssignment();
                                                        if (result9 !== null) {
                                                            result7 = [ result7, result8, result9 ];
                                                        } else {
                                                            result7 = null;
                                                            pos = clone(pos2);
                                                        }
                                                    } else {
                                                        result7 = null;
                                                        pos = clone(pos2);
                                                    }
                                                } else {
                                                    result7 = null;
                                                    pos = clone(pos2);
                                                }
                                                while (result7 !== null) {
                                                    result6.push(result7);
                                                    pos2 = clone(pos);
                                                    if (input.charCodeAt(pos.offset) === 44) {
                                                        result7 = ",";
                                                        advance(pos, 1);
                                                    } else {
                                                        result7 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('","');
                                                        }
                                                    }
                                                    if (result7 !== null) {
                                                        result8 = parse__();
                                                        if (result8 !== null) {
                                                            result9 = parse_LetAssignment();
                                                            if (result9 !== null) {
                                                                result7 = [ result7, result8, result9 ];
                                                            } else {
                                                                result7 = null;
                                                                pos = clone(pos2);
                                                            }
                                                        } else {
                                                            result7 = null;
                                                            pos = clone(pos2);
                                                        }
                                                    } else {
                                                        result7 = null;
                                                        pos = clone(pos2);
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    if (input.charCodeAt(pos.offset) === 125) {
                                                        result7 = "}";
                                                        advance(pos, 1);
                                                    } else {
                                                        result7 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"}"');
                                                        }
                                                    }
                                                    if (result7 !== null) {
                                                        result8 = parse_EOS();
                                                        result8 = result8 !== null ? result8 : "";
                                                        if (result8 !== null) {
                                                            result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8 ];
                                                        } else {
                                                            result0 = null;
                                                            pos = clone(pos1);
                                                        }
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, first, next) {
                                var asn = [ first ];
                                if (next) {
                                    for (var i = 0, sz = next.length; sz > i; i++) {
                                        asn.push(next[i][2]);
                                    }
                                }
                                return {
                                    type: "let",
                                    assignments: asn,
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[4], result0[6]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LetAssignment() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_Identifier();
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 61) {
                                    result2 = "=";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"="');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse__();
                                    if (result3 !== null) {
                                        result4 = parse_HExpressionContent();
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, nm, val) {
                                return {
                                    identifier: nm,
                                    value: val
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ExpressionBlock() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            if (input.charCodeAt(pos.offset) === 58) {
                                result1 = ":";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('":"');
                                }
                            }
                            result1 = result1 !== null ? result1 : "";
                            if (result1 !== null) {
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = [];
                                    result4 = parse_HExpression();
                                    while (result4 !== null) {
                                        result3.push(result4);
                                        result4 = parse_HExpression();
                                    }
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 125) {
                                            result4 = "}";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"}"');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, ubflag, e) {
                                var r = {};
                                if (e.length == 1) {
                                    r = e[0];
                                    if (r.type !== "invalidexpression") {
                                        r.expType = r.type;
                                        r.type = "expression";
                                    }
                                    r.bound = ubflag.length == 0;
                                    if (!r.category) {
                                        r.category = "jsexpression";
                                    }
                                } else {
                                    var code = [], itm, valid = true, t;
                                    for (var i = 0, sz = e.length; sz > i; i++) {
                                        t = e[i].type;
                                        if (t === "invalidexpression") {
                                            valid = false;
                                            break;
                                        }
                                    }
                                    if (valid) {
                                        r.type = "expression";
                                        r.category = "jsexpression";
                                        r.expType = "CssClassExpression";
                                        r.list = e;
                                    } else {
                                        // invalid expression
                                        for (var i = 0, sz = e.length; sz > i; i++) {
                                            itm = e[i];
                                            if (itm.value) {
                                                code.push(itm.value);
                                            } else if (itm.code) {
                                                code.push(itm.code);
                                            } else {
                                                code.push("(...)");
                                            }
                                        }
                                        r.type = "expression";
                                        r.category = "invalidexpression";
                                        r.code = code.join("");
                                    }
                                }
                                r.line = line;
                                r.column = column;
                                return r;
                            }(pos0.offset, pos0.line, pos0.column, result0[1], result0[3]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HExpression() {
                        var result0, result1, result2, result3;
                        var pos0, pos1;
                        result0 = parse_HExpressionCssClassElt();
                        if (result0 === null) {
                            result0 = parse_HExpressionContent();
                            if (result0 === null) {
                                pos0 = clone(pos);
                                pos1 = clone(pos);
                                if (input.charCodeAt(pos.offset) === 44) {
                                    result0 = ",";
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('","');
                                    }
                                }
                                if (result0 !== null) {
                                    result1 = parse___();
                                    if (result1 !== null) {
                                        result2 = parse_HExpressionCssClassElt();
                                        if (result2 !== null) {
                                            result3 = parse___();
                                            if (result3 !== null) {
                                                result0 = [ result0, result1, result2, result3 ];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                                if (result0 !== null) {
                                    result0 = function(offset, line, column, cce) {
                                        return cce;
                                    }(pos0.offset, pos0.line, pos0.column, result0[2]);
                                }
                                if (result0 === null) {
                                    pos = clone(pos0);
                                }
                                if (result0 === null) {
                                    pos0 = clone(pos);
                                    pos1 = clone(pos);
                                    if (input.charCodeAt(pos.offset) === 44) {
                                        result0 = ",";
                                        advance(pos, 1);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('","');
                                        }
                                    }
                                    if (result0 !== null) {
                                        result1 = parse___();
                                        if (result1 !== null) {
                                            result2 = parse_HExpressionContent();
                                            if (result2 !== null) {
                                                result3 = parse___();
                                                if (result3 !== null) {
                                                    result0 = [ result0, result1, result2, result3 ];
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                    if (result0 !== null) {
                                        result0 = function(offset, line, column, exp) {
                                            return exp;
                                        }(pos0.offset, pos0.line, pos0.column, result0[2]);
                                    }
                                    if (result0 === null) {
                                        pos = clone(pos0);
                                    }
                                    if (result0 === null) {
                                        result0 = parse_InvalidExpressionValue();
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_HExpressionContent() {
                        var result0;
                        var pos0;
                        pos0 = clone(pos);
                        result0 = parse_ConditionalExpressionNoIn();
                        if (result0 !== null) {
                            result0 = function(offset, line, column, ce) {
                                if (!ce.category) ce.category = "jsexpression";
                                ce.expType = ce.type;
                                ce.line = line;
                                ce.column = column;
                                return ce;
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HExpressionCssClassElt() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_LogicalORExpression();
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 58) {
                                    result2 = ":";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('":"');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        result4 = parse_LogicalORExpression();
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                return {
                                    type: "CssClassElement",
                                    left: head,
                                    right: tail
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_InvalidExpressionValue() {
                        var result0, result1;
                        var pos0;
                        pos0 = clone(pos);
                        if (/^[^}]/.test(input.charAt(pos.offset))) {
                            result1 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result1 = null;
                            if (reportFailures === 0) {
                                matchFailed("[^}]");
                            }
                        }
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                if (/^[^}]/.test(input.charAt(pos.offset))) {
                                    result1 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("[^}]");
                                    }
                                }
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return {
                                    type: "invalidexpression",
                                    code: chars.join(""),
                                    line: line,
                                    column: column
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_S() {
                        var result0, result1;
                        reportFailures++;
                        result1 = parse_WhiteSpace();
                        if (result1 === null) {
                            if (input.charCodeAt(pos.offset) === 13) {
                                result1 = "\r";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\\r"');
                                }
                            }
                            if (result1 === null) {
                                if (input.charCodeAt(pos.offset) === 10) {
                                    result1 = "\n";
                                    advance(pos, 1);
                                } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"\\n"');
                                    }
                                }
                            }
                        }
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                result1 = parse_WhiteSpace();
                                if (result1 === null) {
                                    if (input.charCodeAt(pos.offset) === 13) {
                                        result1 = "\r";
                                        advance(pos, 1);
                                    } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"\\r"');
                                        }
                                    }
                                    if (result1 === null) {
                                        if (input.charCodeAt(pos.offset) === 10) {
                                            result1 = "\n";
                                            advance(pos, 1);
                                        } else {
                                            result1 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"\\n"');
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            result0 = null;
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("white space");
                        }
                        return result0;
                    }
                    function parse__() {
                        var result0, result1;
                        result0 = [];
                        result1 = parse_WhiteSpace();
                        while (result1 !== null) {
                            result0.push(result1);
                            result1 = parse_WhiteSpace();
                        }
                        return result0;
                    }
                    function parse_WhiteSpace() {
                        var result0;
                        reportFailures++;
                        if (/^[\t\x0B\f \xA0\uFEFF]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF]");
                            }
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("white space");
                        }
                        return result0;
                    }
                    function parse_EOL() {
                        var result0;
                        reportFailures++;
                        if (input.charCodeAt(pos.offset) === 10) {
                            result0 = "\n";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"\\n"');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 2) === "\r\n") {
                                result0 = "\r\n";
                                advance(pos, 2);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\\r\\n"');
                                }
                            }
                            if (result0 === null) {
                                if (input.charCodeAt(pos.offset) === 13) {
                                    result0 = "\r";
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"\\r"');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.charCodeAt(pos.offset) === 8232) {
                                        result0 = "\u2028";
                                        advance(pos, 1);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"\\u2028"');
                                        }
                                    }
                                    if (result0 === null) {
                                        if (input.charCodeAt(pos.offset) === 8233) {
                                            result0 = "\u2029";
                                            advance(pos, 1);
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"\\u2029"');
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("end of line");
                        }
                        return result0;
                    }
                    function parse_EOS() {
                        var result0, result1, result2;
                        var pos0;
                        reportFailures++;
                        pos0 = clone(pos);
                        result0 = parse__();
                        if (result0 !== null) {
                            result1 = parse_EOL();
                            if (result1 !== null) {
                                result2 = parse__();
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos0);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos0);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("end of statement");
                        }
                        return result0;
                    }
                    function parse_EOF() {
                        var result0;
                        var pos0;
                        reportFailures++;
                        pos0 = clone(pos);
                        reportFailures++;
                        if (input.length > pos.offset) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("any character");
                            }
                        }
                        reportFailures--;
                        if (result0 === null) {
                            result0 = "";
                        } else {
                            result0 = null;
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("end of file");
                        }
                        return result0;
                    }
                    function parse___() {
                        var result0, result1;
                        result0 = [];
                        result1 = parse_WhiteSpace();
                        if (result1 === null) {
                            result1 = parse_EOL();
                            if (result1 === null) {
                                result1 = parse_Comment();
                            }
                        }
                        while (result1 !== null) {
                            result0.push(result1);
                            result1 = parse_WhiteSpace();
                            if (result1 === null) {
                                result1 = parse_EOL();
                                if (result1 === null) {
                                    result1 = parse_Comment();
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_Comment() {
                        var result0;
                        reportFailures++;
                        result0 = parse_MultiLineComment();
                        if (result0 === null) {
                            result0 = parse_SingleLineComment();
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("comment");
                        }
                        return result0;
                    }
                    function parse_MultiLineComment() {
                        var result0, result1, result2, result3;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 2) === "/*") {
                            result0 = "/*";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"/*"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            pos1 = clone(pos);
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.substr(pos.offset, 2) === "*/") {
                                result2 = "*/";
                                advance(pos, 2);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"*/"');
                                }
                            }
                            reportFailures--;
                            if (result2 === null) {
                                result2 = "";
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            if (result2 !== null) {
                                if (input.length > pos.offset) {
                                    result3 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("any character");
                                    }
                                }
                                if (result3 !== null) {
                                    result2 = [ result2, result3 ];
                                } else {
                                    result2 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos1);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos1 = clone(pos);
                                pos2 = clone(pos);
                                reportFailures++;
                                if (input.substr(pos.offset, 2) === "*/") {
                                    result2 = "*/";
                                    advance(pos, 2);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"*/"');
                                    }
                                }
                                reportFailures--;
                                if (result2 === null) {
                                    result2 = "";
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                                if (result2 !== null) {
                                    if (input.length > pos.offset) {
                                        result3 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("any character");
                                        }
                                    }
                                    if (result3 !== null) {
                                        result2 = [ result2, result3 ];
                                    } else {
                                        result2 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos1);
                                }
                            }
                            if (result1 !== null) {
                                if (input.substr(pos.offset, 2) === "*/") {
                                    result2 = "*/";
                                    advance(pos, 2);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"*/"');
                                    }
                                }
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos0);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos0);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_SingleLineComment() {
                        var result0, result1, result2, result3;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 2) === "//") {
                            result0 = "//";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"//"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            pos1 = clone(pos);
                            pos2 = clone(pos);
                            reportFailures++;
                            result2 = parse_EOL();
                            reportFailures--;
                            if (result2 === null) {
                                result2 = "";
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            if (result2 !== null) {
                                if (input.length > pos.offset) {
                                    result3 = input.charAt(pos.offset);
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed("any character");
                                    }
                                }
                                if (result3 !== null) {
                                    result2 = [ result2, result3 ];
                                } else {
                                    result2 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos1);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos1 = clone(pos);
                                pos2 = clone(pos);
                                reportFailures++;
                                result2 = parse_EOL();
                                reportFailures--;
                                if (result2 === null) {
                                    result2 = "";
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                                if (result2 !== null) {
                                    if (input.length > pos.offset) {
                                        result3 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("any character");
                                        }
                                    }
                                    if (result3 !== null) {
                                        result2 = [ result2, result3 ];
                                    } else {
                                        result2 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos1);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos0);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_JSObjectRef() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1, pos2, pos3;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_VarIdentifier();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            pos3 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 46) {
                                result2 = ".";
                                advance(pos, 1);
                            } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"."');
                                }
                            }
                            if (result2 !== null) {
                                result3 = parse_Identifier();
                                if (result3 !== null) {
                                    result2 = [ result2, result3 ];
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos3);
                            }
                            if (result2 !== null) {
                                result2 = function(offset, line, column, pp) {
                                    return pp;
                                }(pos2.offset, pos2.line, pos2.column, result2[1]);
                            }
                            if (result2 === null) {
                                pos = clone(pos2);
                            }
                            if (result2 === null) {
                                pos2 = clone(pos);
                                pos3 = clone(pos);
                                if (input.charCodeAt(pos.offset) === 91) {
                                    result2 = "[";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"["');
                                    }
                                }
                                if (result2 !== null) {
                                    if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                        result4 = input.charAt(pos.offset);
                                        advance(pos, 1);
                                    } else {
                                        result4 = null;
                                        if (reportFailures === 0) {
                                            matchFailed("[0-9]");
                                        }
                                    }
                                    if (result4 !== null) {
                                        result3 = [];
                                        while (result4 !== null) {
                                            result3.push(result4);
                                            if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                                result4 = input.charAt(pos.offset);
                                                advance(pos, 1);
                                            } else {
                                                result4 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed("[0-9]");
                                                }
                                            }
                                        }
                                    } else {
                                        result3 = null;
                                    }
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 93) {
                                            result4 = "]";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"]"');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result2 = [ result2, result3, result4 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                                if (result2 !== null) {
                                    result2 = function(offset, line, column, idx) {
                                        return parseInt(idx.join(""), 10);
                                    }(pos2.offset, pos2.line, pos2.column, result2[1]);
                                }
                                if (result2 === null) {
                                    pos = clone(pos2);
                                }
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                pos3 = clone(pos);
                                if (input.charCodeAt(pos.offset) === 46) {
                                    result2 = ".";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"."');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse_Identifier();
                                    if (result3 !== null) {
                                        result2 = [ result2, result3 ];
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                                if (result2 !== null) {
                                    result2 = function(offset, line, column, pp) {
                                        return pp;
                                    }(pos2.offset, pos2.line, pos2.column, result2[1]);
                                }
                                if (result2 === null) {
                                    pos = clone(pos2);
                                }
                                if (result2 === null) {
                                    pos2 = clone(pos);
                                    pos3 = clone(pos);
                                    if (input.charCodeAt(pos.offset) === 91) {
                                        result2 = "[";
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"["');
                                        }
                                    }
                                    if (result2 !== null) {
                                        if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                            result4 = input.charAt(pos.offset);
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed("[0-9]");
                                            }
                                        }
                                        if (result4 !== null) {
                                            result3 = [];
                                            while (result4 !== null) {
                                                result3.push(result4);
                                                if (/^[0-9]/.test(input.charAt(pos.offset))) {
                                                    result4 = input.charAt(pos.offset);
                                                    advance(pos, 1);
                                                } else {
                                                    result4 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed("[0-9]");
                                                    }
                                                }
                                            }
                                        } else {
                                            result3 = null;
                                        }
                                        if (result3 !== null) {
                                            if (input.charCodeAt(pos.offset) === 93) {
                                                result4 = "]";
                                                advance(pos, 1);
                                            } else {
                                                result4 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"]"');
                                                }
                                            }
                                            if (result4 !== null) {
                                                result2 = [ result2, result3, result4 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                    if (result2 !== null) {
                                        result2 = function(offset, line, column, idx) {
                                            return parseInt(idx.join(""), 10);
                                        }(pos2.offset, pos2.line, pos2.column, result2[1]);
                                    }
                                    if (result2 === null) {
                                        pos = clone(pos2);
                                    }
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, start, tail) {
                                var r = [ start ];
                                if (tail && tail.length) r = r.concat(tail);
                                return {
                                    category: "objectref",
                                    path: r,
                                    code: r.join(".")
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("JS object reference");
                        }
                        return result0;
                    }
                    function parse_JSLiteral() {
                        var result0;
                        var pos0;
                        pos0 = clone(pos);
                        result0 = parse_NullLiteral();
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return {
                                    type: "expression",
                                    category: "null",
                                    code: "null"
                                };
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            result0 = parse_BooleanLiteral();
                            if (result0 !== null) {
                                result0 = function(offset, line, column, v) {
                                    return {
                                        type: "expression",
                                        category: "boolean",
                                        value: v.value,
                                        code: "" + v.value
                                    };
                                }(pos0.offset, pos0.line, pos0.column, result0);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                            if (result0 === null) {
                                pos0 = clone(pos);
                                result0 = parse_NumericLiteral();
                                if (result0 !== null) {
                                    result0 = function(offset, line, column, v) {
                                        return {
                                            type: "expression",
                                            category: "number",
                                            value: v,
                                            code: "" + v
                                        };
                                    }(pos0.offset, pos0.line, pos0.column, result0);
                                }
                                if (result0 === null) {
                                    pos = clone(pos0);
                                }
                                if (result0 === null) {
                                    pos0 = clone(pos);
                                    result0 = parse_StringLiteral();
                                    if (result0 !== null) {
                                        result0 = function(offset, line, column, v) {
                                            return {
                                                type: "expression",
                                                category: "string",
                                                value: v,
                                                code: "" + v
                                            };
                                        }(pos0.offset, pos0.line, pos0.column, result0);
                                    }
                                    if (result0 === null) {
                                        pos = clone(pos0);
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_SourceCharacter() {
                        var result0;
                        if (input.length > pos.offset) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("any character");
                            }
                        }
                        return result0;
                    }
                    function parse_Identifier() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        reportFailures++;
                        result0 = parse_ReservedWord();
                        reportFailures--;
                        if (result0 === null) {
                            result0 = "";
                        } else {
                            result0 = null;
                            pos = clone(pos2);
                        }
                        if (result0 !== null) {
                            result1 = parse_IdentifierName();
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, name) {
                                return name;
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("identifier");
                        }
                        return result0;
                    }
                    function parse_IdentifierName() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_IdentifierStart();
                        if (result0 !== null) {
                            result1 = [];
                            result2 = parse_IdentifierPart();
                            while (result2 !== null) {
                                result1.push(result2);
                                result2 = parse_IdentifierPart();
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, start, parts) {
                                return start + parts.join("");
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("identifier");
                        }
                        return result0;
                    }
                    function parse_IdentifierStart() {
                        var result0;
                        result0 = parse_Letter();
                        if (result0 === null) {
                            if (input.charCodeAt(pos.offset) === 36) {
                                result0 = "$";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"$"');
                                }
                            }
                            if (result0 === null) {
                                if (input.charCodeAt(pos.offset) === 95) {
                                    result0 = "_";
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"_"');
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_VarIdentifier() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        reportFailures++;
                        result0 = parse_ReservedWord();
                        reportFailures--;
                        if (result0 === null) {
                            result0 = "";
                        } else {
                            result0 = null;
                            pos = clone(pos2);
                        }
                        if (result0 !== null) {
                            result1 = parse_VarIdentifierName();
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, name) {
                                return name;
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("variable identifier");
                        }
                        return result0;
                    }
                    function parse_VarIdentifierName() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_VarIdentifierStart();
                        if (result0 !== null) {
                            result1 = [];
                            result2 = parse_IdentifierPart();
                            while (result2 !== null) {
                                result1.push(result2);
                                result2 = parse_IdentifierPart();
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, start, parts) {
                                return start + parts.join("");
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("identifier");
                        }
                        return result0;
                    }
                    function parse_VarIdentifierStart() {
                        var result0;
                        result0 = parse_Letter();
                        if (result0 === null) {
                            if (input.charCodeAt(pos.offset) === 36) {
                                result0 = "$";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"$"');
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_IdentifierPart() {
                        var result0;
                        result0 = parse_IdentifierStart();
                        if (result0 === null) {
                            result0 = parse_Digit();
                        }
                        return result0;
                    }
                    function parse_Letter() {
                        var result0;
                        if (/^[a-zA-Z]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[a-zA-Z]");
                            }
                        }
                        return result0;
                    }
                    function parse_Digit() {
                        var result0;
                        if (/^[0-9]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[0-9]");
                            }
                        }
                        return result0;
                    }
                    function parse_ReservedWord() {
                        var result0;
                        result0 = parse_Keyword();
                        if (result0 === null) {
                            result0 = parse_FutureReservedWord();
                            if (result0 === null) {
                                result0 = parse_NullLiteral();
                                if (result0 === null) {
                                    result0 = parse_BooleanLiteral();
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_Keyword() {
                        var result0, result1;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 5) === "break") {
                            result0 = "break";
                            advance(pos, 5);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"break"');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 4) === "case") {
                                result0 = "case";
                                advance(pos, 4);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"case"');
                                }
                            }
                            if (result0 === null) {
                                if (input.substr(pos.offset, 5) === "catch") {
                                    result0 = "catch";
                                    advance(pos, 5);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"catch"');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.substr(pos.offset, 8) === "continue") {
                                        result0 = "continue";
                                        advance(pos, 8);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"continue"');
                                        }
                                    }
                                    if (result0 === null) {
                                        if (input.substr(pos.offset, 8) === "debugger") {
                                            result0 = "debugger";
                                            advance(pos, 8);
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"debugger"');
                                            }
                                        }
                                        if (result0 === null) {
                                            if (input.substr(pos.offset, 7) === "default") {
                                                result0 = "default";
                                                advance(pos, 7);
                                            } else {
                                                result0 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"default"');
                                                }
                                            }
                                            if (result0 === null) {
                                                if (input.substr(pos.offset, 6) === "delete") {
                                                    result0 = "delete";
                                                    advance(pos, 6);
                                                } else {
                                                    result0 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"delete"');
                                                    }
                                                }
                                                if (result0 === null) {
                                                    if (input.substr(pos.offset, 2) === "do") {
                                                        result0 = "do";
                                                        advance(pos, 2);
                                                    } else {
                                                        result0 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"do"');
                                                        }
                                                    }
                                                    if (result0 === null) {
                                                        if (input.substr(pos.offset, 4) === "else") {
                                                            result0 = "else";
                                                            advance(pos, 4);
                                                        } else {
                                                            result0 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed('"else"');
                                                            }
                                                        }
                                                        if (result0 === null) {
                                                            if (input.substr(pos.offset, 7) === "finally") {
                                                                result0 = "finally";
                                                                advance(pos, 7);
                                                            } else {
                                                                result0 = null;
                                                                if (reportFailures === 0) {
                                                                    matchFailed('"finally"');
                                                                }
                                                            }
                                                            if (result0 === null) {
                                                                if (input.substr(pos.offset, 3) === "for") {
                                                                    result0 = "for";
                                                                    advance(pos, 3);
                                                                } else {
                                                                    result0 = null;
                                                                    if (reportFailures === 0) {
                                                                        matchFailed('"for"');
                                                                    }
                                                                }
                                                                if (result0 === null) {
                                                                    if (input.substr(pos.offset, 8) === "function") {
                                                                        result0 = "function";
                                                                        advance(pos, 8);
                                                                    } else {
                                                                        result0 = null;
                                                                        if (reportFailures === 0) {
                                                                            matchFailed('"function"');
                                                                        }
                                                                    }
                                                                    if (result0 === null) {
                                                                        if (input.substr(pos.offset, 2) === "if") {
                                                                            result0 = "if";
                                                                            advance(pos, 2);
                                                                        } else {
                                                                            result0 = null;
                                                                            if (reportFailures === 0) {
                                                                                matchFailed('"if"');
                                                                            }
                                                                        }
                                                                        if (result0 === null) {
                                                                            if (input.substr(pos.offset, 10) === "instanceof") {
                                                                                result0 = "instanceof";
                                                                                advance(pos, 10);
                                                                            } else {
                                                                                result0 = null;
                                                                                if (reportFailures === 0) {
                                                                                    matchFailed('"instanceof"');
                                                                                }
                                                                            }
                                                                            if (result0 === null) {
                                                                                if (input.substr(pos.offset, 2) === "in") {
                                                                                    result0 = "in";
                                                                                    advance(pos, 2);
                                                                                } else {
                                                                                    result0 = null;
                                                                                    if (reportFailures === 0) {
                                                                                        matchFailed('"in"');
                                                                                    }
                                                                                }
                                                                                if (result0 === null) {
                                                                                    if (input.substr(pos.offset, 3) === "new") {
                                                                                        result0 = "new";
                                                                                        advance(pos, 3);
                                                                                    } else {
                                                                                        result0 = null;
                                                                                        if (reportFailures === 0) {
                                                                                            matchFailed('"new"');
                                                                                        }
                                                                                    }
                                                                                    if (result0 === null) {
                                                                                        if (input.substr(pos.offset, 6) === "return") {
                                                                                            result0 = "return";
                                                                                            advance(pos, 6);
                                                                                        } else {
                                                                                            result0 = null;
                                                                                            if (reportFailures === 0) {
                                                                                                matchFailed('"return"');
                                                                                            }
                                                                                        }
                                                                                        if (result0 === null) {
                                                                                            if (input.substr(pos.offset, 6) === "switch") {
                                                                                                result0 = "switch";
                                                                                                advance(pos, 6);
                                                                                            } else {
                                                                                                result0 = null;
                                                                                                if (reportFailures === 0) {
                                                                                                    matchFailed('"switch"');
                                                                                                }
                                                                                            }
                                                                                            if (result0 === null) {
                                                                                                if (input.substr(pos.offset, 4) === "this") {
                                                                                                    result0 = "this";
                                                                                                    advance(pos, 4);
                                                                                                } else {
                                                                                                    result0 = null;
                                                                                                    if (reportFailures === 0) {
                                                                                                        matchFailed('"this"');
                                                                                                    }
                                                                                                }
                                                                                                if (result0 === null) {
                                                                                                    if (input.substr(pos.offset, 5) === "throw") {
                                                                                                        result0 = "throw";
                                                                                                        advance(pos, 5);
                                                                                                    } else {
                                                                                                        result0 = null;
                                                                                                        if (reportFailures === 0) {
                                                                                                            matchFailed('"throw"');
                                                                                                        }
                                                                                                    }
                                                                                                    if (result0 === null) {
                                                                                                        if (input.substr(pos.offset, 3) === "try") {
                                                                                                            result0 = "try";
                                                                                                            advance(pos, 3);
                                                                                                        } else {
                                                                                                            result0 = null;
                                                                                                            if (reportFailures === 0) {
                                                                                                                matchFailed('"try"');
                                                                                                            }
                                                                                                        }
                                                                                                        if (result0 === null) {
                                                                                                            if (input.substr(pos.offset, 6) === "typeof") {
                                                                                                                result0 = "typeof";
                                                                                                                advance(pos, 6);
                                                                                                            } else {
                                                                                                                result0 = null;
                                                                                                                if (reportFailures === 0) {
                                                                                                                    matchFailed('"typeof"');
                                                                                                                }
                                                                                                            }
                                                                                                            if (result0 === null) {
                                                                                                                if (input.substr(pos.offset, 3) === "var") {
                                                                                                                    result0 = "var";
                                                                                                                    advance(pos, 3);
                                                                                                                } else {
                                                                                                                    result0 = null;
                                                                                                                    if (reportFailures === 0) {
                                                                                                                        matchFailed('"var"');
                                                                                                                    }
                                                                                                                }
                                                                                                                if (result0 === null) {
                                                                                                                    if (input.substr(pos.offset, 4) === "void") {
                                                                                                                        result0 = "void";
                                                                                                                        advance(pos, 4);
                                                                                                                    } else {
                                                                                                                        result0 = null;
                                                                                                                        if (reportFailures === 0) {
                                                                                                                            matchFailed('"void"');
                                                                                                                        }
                                                                                                                    }
                                                                                                                    if (result0 === null) {
                                                                                                                        if (input.substr(pos.offset, 5) === "while") {
                                                                                                                            result0 = "while";
                                                                                                                            advance(pos, 5);
                                                                                                                        } else {
                                                                                                                            result0 = null;
                                                                                                                            if (reportFailures === 0) {
                                                                                                                                matchFailed('"while"');
                                                                                                                            }
                                                                                                                        }
                                                                                                                        if (result0 === null) {
                                                                                                                            if (input.substr(pos.offset, 4) === "with") {
                                                                                                                                result0 = "with";
                                                                                                                                advance(pos, 4);
                                                                                                                            } else {
                                                                                                                                result0 = null;
                                                                                                                                if (reportFailures === 0) {
                                                                                                                                    matchFailed('"with"');
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (result0 !== null) {
                            pos1 = clone(pos);
                            reportFailures++;
                            result1 = parse_IdentifierPart();
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos1);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos0);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_FutureReservedWord() {
                        var result0, result1;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 5) === "class") {
                            result0 = "class";
                            advance(pos, 5);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"class"');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 5) === "const") {
                                result0 = "const";
                                advance(pos, 5);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"const"');
                                }
                            }
                            if (result0 === null) {
                                if (input.substr(pos.offset, 4) === "enum") {
                                    result0 = "enum";
                                    advance(pos, 4);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"enum"');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.substr(pos.offset, 6) === "export") {
                                        result0 = "export";
                                        advance(pos, 6);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"export"');
                                        }
                                    }
                                    if (result0 === null) {
                                        if (input.substr(pos.offset, 7) === "extends") {
                                            result0 = "extends";
                                            advance(pos, 7);
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"extends"');
                                            }
                                        }
                                        if (result0 === null) {
                                            if (input.substr(pos.offset, 6) === "import") {
                                                result0 = "import";
                                                advance(pos, 6);
                                            } else {
                                                result0 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"import"');
                                                }
                                            }
                                            if (result0 === null) {
                                                if (input.substr(pos.offset, 5) === "super") {
                                                    result0 = "super";
                                                    advance(pos, 5);
                                                } else {
                                                    result0 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"super"');
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (result0 !== null) {
                            pos1 = clone(pos);
                            reportFailures++;
                            result1 = parse_IdentifierPart();
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos1);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos0);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_NullLiteral() {
                        var result0;
                        var pos0;
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 4) === "null") {
                            result0 = "null";
                            advance(pos, 4);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"null"');
                            }
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return {
                                    type: "nullliteral",
                                    value: null
                                };
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BooleanLiteral() {
                        var result0;
                        var pos0;
                        pos0 = clone(pos);
                        if (input.substr(pos.offset, 4) === "true") {
                            result0 = "true";
                            advance(pos, 4);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"true"');
                            }
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return {
                                    type: "booleanliteral",
                                    value: true
                                };
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            if (input.substr(pos.offset, 5) === "false") {
                                result0 = "false";
                                advance(pos, 5);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"false"');
                                }
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column) {
                                    return {
                                        type: "booleanliteral",
                                        value: false
                                    };
                                }(pos0.offset, pos0.line, pos0.column);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                        }
                        return result0;
                    }
                    function parse_NumericLiteral() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_HexIntegerLiteral();
                        if (result0 === null) {
                            result0 = parse_DecimalLiteral();
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            result1 = parse_IdentifierStart();
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, literal) {
                                return literal;
                            }(pos0.offset, pos0.line, pos0.column, result0[0]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("number");
                        }
                        return result0;
                    }
                    function parse_HexIntegerLiteral() {
                        var result0, result1, result2, result3;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 48) {
                            result0 = "0";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"0"');
                            }
                        }
                        if (result0 !== null) {
                            if (/^[xX]/.test(input.charAt(pos.offset))) {
                                result1 = input.charAt(pos.offset);
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed("[xX]");
                                }
                            }
                            if (result1 !== null) {
                                result3 = parse_HexDigit();
                                if (result3 !== null) {
                                    result2 = [];
                                    while (result3 !== null) {
                                        result2.push(result3);
                                        result3 = parse_HexDigit();
                                    }
                                } else {
                                    result2 = null;
                                }
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, digits) {
                                return parseInt("0x" + digits.join(""));
                            }(pos0.offset, pos0.line, pos0.column, result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_HexDigit() {
                        var result0;
                        if (/^[0-9a-fA-F]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[0-9a-fA-F]");
                            }
                        }
                        return result0;
                    }
                    function parse_DecimalLiteral() {
                        var result0, result1, result2, result3;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_DecimalIntegerLiteral();
                        if (result0 !== null) {
                            if (input.charCodeAt(pos.offset) === 46) {
                                result1 = ".";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"."');
                                }
                            }
                            if (result1 !== null) {
                                result2 = parse_DecimalDigits();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    result3 = parse_ExponentPart();
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                        result0 = [ result0, result1, result2, result3 ];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, before, after, exponent) {
                                return parseFloat(before + "." + after + exponent);
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[2], result0[3]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 46) {
                                result0 = ".";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"."');
                                }
                            }
                            if (result0 !== null) {
                                result1 = parse_DecimalDigits();
                                if (result1 !== null) {
                                    result2 = parse_ExponentPart();
                                    result2 = result2 !== null ? result2 : "";
                                    if (result2 !== null) {
                                        result0 = [ result0, result1, result2 ];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column, after, exponent) {
                                    return parseFloat("." + after + exponent);
                                }(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                            if (result0 === null) {
                                pos0 = clone(pos);
                                pos1 = clone(pos);
                                result0 = parse_DecimalIntegerLiteral();
                                if (result0 !== null) {
                                    result1 = parse_ExponentPart();
                                    result1 = result1 !== null ? result1 : "";
                                    if (result1 !== null) {
                                        result0 = [ result0, result1 ];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                                if (result0 !== null) {
                                    result0 = function(offset, line, column, before, exponent) {
                                        return parseFloat(before + exponent);
                                    }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                                }
                                if (result0 === null) {
                                    pos = clone(pos0);
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_DecimalIntegerLiteral() {
                        var result0, result1;
                        var pos0, pos1;
                        if (input.charCodeAt(pos.offset) === 48) {
                            result0 = "0";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"0"');
                            }
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            result0 = parse_NonZeroDigit();
                            if (result0 !== null) {
                                result1 = parse_DecimalDigits();
                                result1 = result1 !== null ? result1 : "";
                                if (result1 !== null) {
                                    result0 = [ result0, result1 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column, digit, digits) {
                                    return digit + digits;
                                }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                        }
                        return result0;
                    }
                    function parse_DecimalDigits() {
                        var result0, result1;
                        var pos0;
                        pos0 = clone(pos);
                        result1 = parse_DecimalDigit();
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                result1 = parse_DecimalDigit();
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, digits) {
                                return digits.join("");
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_DecimalDigit() {
                        var result0;
                        if (/^[0-9]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[0-9]");
                            }
                        }
                        return result0;
                    }
                    function parse_NonZeroDigit() {
                        var result0;
                        if (/^[1-9]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[1-9]");
                            }
                        }
                        return result0;
                    }
                    function parse_ExponentPart() {
                        var result0, result1;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_ExponentIndicator();
                        if (result0 !== null) {
                            result1 = parse_SignedInteger();
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, indicator, integer) {
                                return indicator + integer;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ExponentIndicator() {
                        var result0;
                        if (/^[eE]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[eE]");
                            }
                        }
                        return result0;
                    }
                    function parse_SignedInteger() {
                        var result0, result1;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (/^[\-+]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("[\\-+]");
                            }
                        }
                        result0 = result0 !== null ? result0 : "";
                        if (result0 !== null) {
                            result1 = parse_DecimalDigits();
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, sign, digits) {
                                return sign + digits;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_StringLiteral() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        reportFailures++;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 34) {
                            result0 = '"';
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"\\""');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_DoubleStringCharacters();
                            result1 = result1 !== null ? result1 : "";
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 34) {
                                    result2 = '"';
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"\\""');
                                    }
                                }
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 === null) {
                            pos1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 39) {
                                result0 = "'";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\'"');
                                }
                            }
                            if (result0 !== null) {
                                result1 = parse_SingleStringCharacters();
                                result1 = result1 !== null ? result1 : "";
                                if (result1 !== null) {
                                    if (input.charCodeAt(pos.offset) === 39) {
                                        result2 = "'";
                                        advance(pos, 1);
                                    } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"\'"');
                                        }
                                    }
                                    if (result2 !== null) {
                                        result0 = [ result0, result1, result2 ];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, parts) {
                                return parts[1];
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        reportFailures--;
                        if (reportFailures === 0 && result0 === null) {
                            matchFailed("string");
                        }
                        return result0;
                    }
                    function parse_DoubleStringCharacters() {
                        var result0, result1;
                        var pos0;
                        pos0 = clone(pos);
                        result1 = parse_DoubleStringCharacter();
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                result1 = parse_DoubleStringCharacter();
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return chars.join("");
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_SingleStringCharacters() {
                        var result0, result1;
                        var pos0;
                        pos0 = clone(pos);
                        result1 = parse_SingleStringCharacter();
                        if (result1 !== null) {
                            result0 = [];
                            while (result1 !== null) {
                                result0.push(result1);
                                result1 = parse_SingleStringCharacter();
                            }
                        } else {
                            result0 = null;
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, chars) {
                                return chars.join("");
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_DoubleStringCharacter() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        reportFailures++;
                        if (input.charCodeAt(pos.offset) === 34) {
                            result0 = '"';
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"\\""');
                            }
                        }
                        if (result0 === null) {
                            if (input.charCodeAt(pos.offset) === 92) {
                                result0 = "\\";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\\\\"');
                                }
                            }
                            if (result0 === null) {
                                result0 = parse_EOL();
                            }
                        }
                        reportFailures--;
                        if (result0 === null) {
                            result0 = "";
                        } else {
                            result0 = null;
                            pos = clone(pos2);
                        }
                        if (result0 !== null) {
                            result1 = parse_SourceCharacter();
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, char_) {
                                return char_;
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 92) {
                                result0 = "\\";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\\\\"');
                                }
                            }
                            if (result0 !== null) {
                                result1 = parse_EscapeSequence();
                                if (result1 !== null) {
                                    result0 = [ result0, result1 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column, sequence) {
                                    return sequence;
                                }(pos0.offset, pos0.line, pos0.column, result0[1]);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                        }
                        return result0;
                    }
                    function parse_SingleStringCharacter() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        reportFailures++;
                        if (input.charCodeAt(pos.offset) === 39) {
                            result0 = "'";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"\'"');
                            }
                        }
                        if (result0 === null) {
                            if (input.charCodeAt(pos.offset) === 92) {
                                result0 = "\\";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\\\\"');
                                }
                            }
                            if (result0 === null) {
                                result0 = parse_EOL();
                            }
                        }
                        reportFailures--;
                        if (result0 === null) {
                            result0 = "";
                        } else {
                            result0 = null;
                            pos = clone(pos2);
                        }
                        if (result0 !== null) {
                            result1 = parse_SourceCharacter();
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, char_) {
                                return char_;
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 92) {
                                result0 = "\\";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"\\\\"');
                                }
                            }
                            if (result0 !== null) {
                                result1 = parse_EscapeSequence();
                                if (result1 !== null) {
                                    result0 = [ result0, result1 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column, sequence) {
                                    return sequence;
                                }(pos0.offset, pos0.line, pos0.column, result0[1]);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                        }
                        return result0;
                    }
                    function parse_EscapeSequence() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        result0 = parse_CharacterEscapeSequence();
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 48) {
                                result0 = "0";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"0"');
                                }
                            }
                            if (result0 !== null) {
                                pos2 = clone(pos);
                                reportFailures++;
                                result1 = parse_DecimalDigit();
                                reportFailures--;
                                if (result1 === null) {
                                    result1 = "";
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                                if (result1 !== null) {
                                    result0 = [ result0, result1 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column) {
                                    return "\x00";
                                }(pos0.offset, pos0.line, pos0.column);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                            if (result0 === null) {
                                result0 = parse_HexEscapeSequence();
                                if (result0 === null) {
                                    result0 = parse_UnicodeEscapeSequence();
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_CharacterEscapeSequence() {
                        var result0;
                        result0 = parse_SingleEscapeCharacter();
                        if (result0 === null) {
                            result0 = parse_NonEscapeCharacter();
                        }
                        return result0;
                    }
                    function parse_SingleEscapeCharacter() {
                        var result0;
                        var pos0;
                        pos0 = clone(pos);
                        if (/^['"\\bfnrtv]/.test(input.charAt(pos.offset))) {
                            result0 = input.charAt(pos.offset);
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed("['\"\\\\bfnrtv]");
                            }
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, char_) {
                                return char_.replace("b", "\b").replace("f", "\f").replace("n", "\n").replace("r", "\r").replace("t", "	").replace("v", "");
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_NonEscapeCharacter() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        reportFailures++;
                        result0 = parse_EscapeCharacter();
                        reportFailures--;
                        if (result0 === null) {
                            result0 = "";
                        } else {
                            result0 = null;
                            pos = clone(pos2);
                        }
                        if (result0 === null) {
                            result0 = parse_EOL();
                        }
                        if (result0 !== null) {
                            result1 = parse_SourceCharacter();
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, char_) {
                                return char_;
                            }(pos0.offset, pos0.line, pos0.column, result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_EscapeCharacter() {
                        var result0;
                        result0 = parse_SingleEscapeCharacter();
                        if (result0 === null) {
                            result0 = parse_DecimalDigit();
                            if (result0 === null) {
                                if (input.charCodeAt(pos.offset) === 120) {
                                    result0 = "x";
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"x"');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.charCodeAt(pos.offset) === 117) {
                                        result0 = "u";
                                        advance(pos, 1);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"u"');
                                        }
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_HexEscapeSequence() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 120) {
                            result0 = "x";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"x"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_HexDigit();
                            if (result1 !== null) {
                                result2 = parse_HexDigit();
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, h1, h2) {
                                return String.fromCharCode(parseInt("0x" + h1 + h2));
                            }(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_UnicodeEscapeSequence() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 117) {
                            result0 = "u";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"u"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse_HexDigit();
                            if (result1 !== null) {
                                result2 = parse_HexDigit();
                                if (result2 !== null) {
                                    result3 = parse_HexDigit();
                                    if (result3 !== null) {
                                        result4 = parse_HexDigit();
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, h1, h2, h3, h4) {
                                return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
                            }(pos0.offset, pos0.line, pos0.column, result0[1], result0[2], result0[3], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_PrimaryExpression() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        result0 = parse_Identifier();
                        if (result0 !== null) {
                            result0 = function(offset, line, column, name) {
                                return {
                                    type: "Variable",
                                    name: name,
                                    code: name
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            result0 = parse_JSLiteral();
                            if (result0 === null) {
                                result0 = parse_ArrayLiteral();
                                if (result0 === null) {
                                    result0 = parse_ObjectLiteral();
                                    if (result0 === null) {
                                        pos0 = clone(pos);
                                        pos1 = clone(pos);
                                        if (input.charCodeAt(pos.offset) === 40) {
                                            result0 = "(";
                                            advance(pos, 1);
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"("');
                                            }
                                        }
                                        if (result0 !== null) {
                                            result1 = parse___();
                                            if (result1 !== null) {
                                                result2 = parse_Expression();
                                                if (result2 !== null) {
                                                    result3 = parse___();
                                                    if (result3 !== null) {
                                                        if (input.charCodeAt(pos.offset) === 41) {
                                                            result4 = ")";
                                                            advance(pos, 1);
                                                        } else {
                                                            result4 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed('")"');
                                                            }
                                                        }
                                                        if (result4 !== null) {
                                                            result0 = [ result0, result1, result2, result3, result4 ];
                                                        } else {
                                                            result0 = null;
                                                            pos = clone(pos1);
                                                        }
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                        if (result0 !== null) {
                                            result0 = function(offset, line, column, expression) {
                                                return expression;
                                            }(pos0.offset, pos0.line, pos0.column, result0[2]);
                                        }
                                        if (result0 === null) {
                                            pos = clone(pos0);
                                        }
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_ArrayLiteral() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 91) {
                            result0 = "[";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"["');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                result2 = parse_ElementList();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        pos2 = clone(pos);
                                        result4 = parse_Elision();
                                        if (result4 !== null) {
                                            result5 = parse___();
                                            if (result5 !== null) {
                                                result4 = [ result4, result5 ];
                                            } else {
                                                result4 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result4 = null;
                                            pos = clone(pos2);
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                            if (input.charCodeAt(pos.offset) === 93) {
                                                result5 = "]";
                                                advance(pos, 1);
                                            } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"]"');
                                                }
                                            }
                                            if (result5 !== null) {
                                                result0 = [ result0, result1, result2, result3, result4, result5 ];
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, elements) {
                                return {
                                    type: "ArrayLiteral",
                                    elements: elements !== "" ? elements : []
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ElementList() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        result0 = parse_Elision();
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos2);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos2);
                        }
                        result0 = result0 !== null ? result0 : "";
                        if (result0 !== null) {
                            result1 = parse_AssignmentExpression();
                            if (result1 !== null) {
                                result2 = [];
                                pos2 = clone(pos);
                                result3 = parse___();
                                if (result3 !== null) {
                                    if (input.charCodeAt(pos.offset) === 44) {
                                        result4 = ",";
                                        advance(pos, 1);
                                    } else {
                                        result4 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('","');
                                        }
                                    }
                                    if (result4 !== null) {
                                        result5 = parse___();
                                        if (result5 !== null) {
                                            result6 = parse_Elision();
                                            result6 = result6 !== null ? result6 : "";
                                            if (result6 !== null) {
                                                result7 = parse___();
                                                if (result7 !== null) {
                                                    result8 = parse_AssignmentExpression();
                                                    if (result8 !== null) {
                                                        result3 = [ result3, result4, result5, result6, result7, result8 ];
                                                    } else {
                                                        result3 = null;
                                                        pos = clone(pos2);
                                                    }
                                                } else {
                                                    result3 = null;
                                                    pos = clone(pos2);
                                                }
                                            } else {
                                                result3 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result3 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result3 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result3 = null;
                                    pos = clone(pos2);
                                }
                                while (result3 !== null) {
                                    result2.push(result3);
                                    pos2 = clone(pos);
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 44) {
                                            result4 = ",";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('","');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result5 = parse___();
                                            if (result5 !== null) {
                                                result6 = parse_Elision();
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                    result7 = parse___();
                                                    if (result7 !== null) {
                                                        result8 = parse_AssignmentExpression();
                                                        if (result8 !== null) {
                                                            result3 = [ result3, result4, result5, result6, result7, result8 ];
                                                        } else {
                                                            result3 = null;
                                                            pos = clone(pos2);
                                                        }
                                                    } else {
                                                        result3 = null;
                                                        pos = clone(pos2);
                                                    }
                                                } else {
                                                    result3 = null;
                                                    pos = clone(pos2);
                                                }
                                            } else {
                                                result3 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result3 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result3 = null;
                                        pos = clone(pos2);
                                    }
                                }
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = [ head ];
                                for (var i = 0; i < tail.length; i++) {
                                    result.push(tail[i][5]);
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[1], result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_Elision() {
                        var result0, result1, result2, result3;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 44) {
                            result0 = ",";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('","');
                            }
                        }
                        if (result0 !== null) {
                            result1 = [];
                            pos1 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                if (input.charCodeAt(pos.offset) === 44) {
                                    result3 = ",";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('","');
                                    }
                                }
                                if (result3 !== null) {
                                    result2 = [ result2, result3 ];
                                } else {
                                    result2 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos1);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos1 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 44) {
                                        result3 = ",";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('","');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result2 = [ result2, result3 ];
                                    } else {
                                        result2 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos1);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos0);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ObjectLiteral() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2, pos3;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 123) {
                            result0 = "{";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"{"');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                pos2 = clone(pos);
                                result2 = parse_PropertyNameAndValueList();
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        pos3 = clone(pos);
                                        if (input.charCodeAt(pos.offset) === 44) {
                                            result4 = ",";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('","');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result5 = parse___();
                                            if (result5 !== null) {
                                                result4 = [ result4, result5 ];
                                            } else {
                                                result4 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result4 = null;
                                            pos = clone(pos3);
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                            result2 = [ result2, result3, result4 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 125) {
                                        result3 = "}";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"}"');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result0 = [ result0, result1, result2, result3 ];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, properties) {
                                return {
                                    type: "ObjectLiteral",
                                    properties: properties !== "" ? properties[0] : []
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_PropertyNameAndValueList() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_PropertyAssignment();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                if (input.charCodeAt(pos.offset) === 44) {
                                    result3 = ",";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('","');
                                    }
                                }
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_PropertyAssignment();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 44) {
                                        result3 = ",";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('","');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_PropertyAssignment();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = [ head ];
                                for (var i = 0; i < tail.length; i++) {
                                    result.push(tail[i][3]);
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_PropertyAssignment() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_PropertyName();
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 58) {
                                    result2 = ":";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('":"');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        result4 = parse_AssignmentExpression();
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, name, value) {
                                return {
                                    type: "PropertyAssignment",
                                    name: name,
                                    value: value
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_PropertyName() {
                        var result0;
                        result0 = parse_IdentifierName();
                        if (result0 === null) {
                            result0 = parse_StringLiteral();
                            if (result0 === null) {
                                result0 = parse_NumericLiteral();
                            }
                        }
                        return result0;
                    }
                    function parse_MemberExpression() {
                        var result0, result1, result2, result3, result4, result5, result6, result7;
                        var pos0, pos1, pos2, pos3;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_PrimaryExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            pos3 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                if (input.charCodeAt(pos.offset) === 91) {
                                    result3 = "[";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"["');
                                    }
                                }
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_Expression();
                                        if (result5 !== null) {
                                            result6 = parse___();
                                            if (result6 !== null) {
                                                if (input.charCodeAt(pos.offset) === 93) {
                                                    result7 = "]";
                                                    advance(pos, 1);
                                                } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"]"');
                                                    }
                                                }
                                                if (result7 !== null) {
                                                    result2 = [ result2, result3, result4, result5, result6, result7 ];
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos3);
                            }
                            if (result2 !== null) {
                                result2 = function(offset, line, column, name) {
                                    return name;
                                }(pos2.offset, pos2.line, pos2.column, result2[3]);
                            }
                            if (result2 === null) {
                                pos = clone(pos2);
                            }
                            if (result2 === null) {
                                pos2 = clone(pos);
                                pos3 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 46) {
                                        result3 = ".";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"."');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_IdentifierName();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                                if (result2 !== null) {
                                    result2 = function(offset, line, column, name) {
                                        return name;
                                    }(pos2.offset, pos2.line, pos2.column, result2[3]);
                                }
                                if (result2 === null) {
                                    pos = clone(pos2);
                                }
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                pos3 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 91) {
                                        result3 = "[";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"["');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_Expression();
                                            if (result5 !== null) {
                                                result6 = parse___();
                                                if (result6 !== null) {
                                                    if (input.charCodeAt(pos.offset) === 93) {
                                                        result7 = "]";
                                                        advance(pos, 1);
                                                    } else {
                                                        result7 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"]"');
                                                        }
                                                    }
                                                    if (result7 !== null) {
                                                        result2 = [ result2, result3, result4, result5, result6, result7 ];
                                                    } else {
                                                        result2 = null;
                                                        pos = clone(pos3);
                                                    }
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                                if (result2 !== null) {
                                    result2 = function(offset, line, column, name) {
                                        return name;
                                    }(pos2.offset, pos2.line, pos2.column, result2[3]);
                                }
                                if (result2 === null) {
                                    pos = clone(pos2);
                                }
                                if (result2 === null) {
                                    pos2 = clone(pos);
                                    pos3 = clone(pos);
                                    result2 = parse___();
                                    if (result2 !== null) {
                                        if (input.charCodeAt(pos.offset) === 46) {
                                            result3 = ".";
                                            advance(pos, 1);
                                        } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"."');
                                            }
                                        }
                                        if (result3 !== null) {
                                            result4 = parse___();
                                            if (result4 !== null) {
                                                result5 = parse_IdentifierName();
                                                if (result5 !== null) {
                                                    result2 = [ result2, result3, result4, result5 ];
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                    if (result2 !== null) {
                                        result2 = function(offset, line, column, name) {
                                            return name;
                                        }(pos2.offset, pos2.line, pos2.column, result2[3]);
                                    }
                                    if (result2 === null) {
                                        pos = clone(pos2);
                                    }
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, base, accessors) {
                                var result = base;
                                for (var i = 0; i < accessors.length; i++) {
                                    result = {
                                        type: "PropertyAccess",
                                        base: result,
                                        name: accessors[i]
                                    };
                                }
                                result.code = base.code;
                                if (accessors.length) {
                                    var acc;
                                    for (var i = 0, sz = accessors.length; sz > i; i++) {
                                        acc = accessors[i];
                                        if (acc.code) {
                                            accessors[i] = acc.code;
                                        }
                                    }
                                    result.code += "." + accessors.join(".");
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_CallExpression() {
                        var result0, result1, result2, result3, result4, result5, result6, result7;
                        var pos0, pos1, pos2, pos3;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        pos2 = clone(pos);
                        pos3 = clone(pos);
                        result0 = parse_MemberExpression();
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                result2 = parse_Arguments();
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos3);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos3);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos3);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, name, arguments) {
                                return {
                                    type: "FunctionCall",
                                    name: name,
                                    arguments: arguments
                                };
                            }(pos2.offset, pos2.line, pos2.column, result0[0], result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos2);
                        }
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            pos3 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_Arguments();
                                if (result3 !== null) {
                                    result2 = [ result2, result3 ];
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos3);
                            }
                            if (result2 !== null) {
                                result2 = function(offset, line, column, arguments) {
                                    return {
                                        type: "FunctionCallArguments",
                                        arguments: arguments
                                    };
                                }(pos2.offset, pos2.line, pos2.column, result2[1]);
                            }
                            if (result2 === null) {
                                pos = clone(pos2);
                            }
                            if (result2 === null) {
                                pos2 = clone(pos);
                                pos3 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 91) {
                                        result3 = "[";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"["');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_Expression();
                                            if (result5 !== null) {
                                                result6 = parse___();
                                                if (result6 !== null) {
                                                    if (input.charCodeAt(pos.offset) === 93) {
                                                        result7 = "]";
                                                        advance(pos, 1);
                                                    } else {
                                                        result7 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"]"');
                                                        }
                                                    }
                                                    if (result7 !== null) {
                                                        result2 = [ result2, result3, result4, result5, result6, result7 ];
                                                    } else {
                                                        result2 = null;
                                                        pos = clone(pos3);
                                                    }
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                                if (result2 !== null) {
                                    result2 = function(offset, line, column, name) {
                                        return {
                                            type: "PropertyAccessProperty",
                                            name: name
                                        };
                                    }(pos2.offset, pos2.line, pos2.column, result2[3]);
                                }
                                if (result2 === null) {
                                    pos = clone(pos2);
                                }
                                if (result2 === null) {
                                    pos2 = clone(pos);
                                    pos3 = clone(pos);
                                    result2 = parse___();
                                    if (result2 !== null) {
                                        if (input.charCodeAt(pos.offset) === 46) {
                                            result3 = ".";
                                            advance(pos, 1);
                                        } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"."');
                                            }
                                        }
                                        if (result3 !== null) {
                                            result4 = parse___();
                                            if (result4 !== null) {
                                                result5 = parse_IdentifierName();
                                                if (result5 !== null) {
                                                    result2 = [ result2, result3, result4, result5 ];
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                    if (result2 !== null) {
                                        result2 = function(offset, line, column, name) {
                                            return {
                                                type: "PropertyAccessProperty",
                                                name: name
                                            };
                                        }(pos2.offset, pos2.line, pos2.column, result2[3]);
                                    }
                                    if (result2 === null) {
                                        pos = clone(pos2);
                                    }
                                }
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                pos3 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_Arguments();
                                    if (result3 !== null) {
                                        result2 = [ result2, result3 ];
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos3);
                                }
                                if (result2 !== null) {
                                    result2 = function(offset, line, column, arguments) {
                                        return {
                                            type: "FunctionCallArguments",
                                            arguments: arguments
                                        };
                                    }(pos2.offset, pos2.line, pos2.column, result2[1]);
                                }
                                if (result2 === null) {
                                    pos = clone(pos2);
                                }
                                if (result2 === null) {
                                    pos2 = clone(pos);
                                    pos3 = clone(pos);
                                    result2 = parse___();
                                    if (result2 !== null) {
                                        if (input.charCodeAt(pos.offset) === 91) {
                                            result3 = "[";
                                            advance(pos, 1);
                                        } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"["');
                                            }
                                        }
                                        if (result3 !== null) {
                                            result4 = parse___();
                                            if (result4 !== null) {
                                                result5 = parse_Expression();
                                                if (result5 !== null) {
                                                    result6 = parse___();
                                                    if (result6 !== null) {
                                                        if (input.charCodeAt(pos.offset) === 93) {
                                                            result7 = "]";
                                                            advance(pos, 1);
                                                        } else {
                                                            result7 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed('"]"');
                                                            }
                                                        }
                                                        if (result7 !== null) {
                                                            result2 = [ result2, result3, result4, result5, result6, result7 ];
                                                        } else {
                                                            result2 = null;
                                                            pos = clone(pos3);
                                                        }
                                                    } else {
                                                        result2 = null;
                                                        pos = clone(pos3);
                                                    }
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos3);
                                    }
                                    if (result2 !== null) {
                                        result2 = function(offset, line, column, name) {
                                            return {
                                                type: "PropertyAccessProperty",
                                                name: name
                                            };
                                        }(pos2.offset, pos2.line, pos2.column, result2[3]);
                                    }
                                    if (result2 === null) {
                                        pos = clone(pos2);
                                    }
                                    if (result2 === null) {
                                        pos2 = clone(pos);
                                        pos3 = clone(pos);
                                        result2 = parse___();
                                        if (result2 !== null) {
                                            if (input.charCodeAt(pos.offset) === 46) {
                                                result3 = ".";
                                                advance(pos, 1);
                                            } else {
                                                result3 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"."');
                                                }
                                            }
                                            if (result3 !== null) {
                                                result4 = parse___();
                                                if (result4 !== null) {
                                                    result5 = parse_IdentifierName();
                                                    if (result5 !== null) {
                                                        result2 = [ result2, result3, result4, result5 ];
                                                    } else {
                                                        result2 = null;
                                                        pos = clone(pos3);
                                                    }
                                                } else {
                                                    result2 = null;
                                                    pos = clone(pos3);
                                                }
                                            } else {
                                                result2 = null;
                                                pos = clone(pos3);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos3);
                                        }
                                        if (result2 !== null) {
                                            result2 = function(offset, line, column, name) {
                                                return {
                                                    type: "PropertyAccessProperty",
                                                    name: name
                                                };
                                            }(pos2.offset, pos2.line, pos2.column, result2[3]);
                                        }
                                        if (result2 === null) {
                                            pos = clone(pos2);
                                        }
                                    }
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, base, argumentsOrAccessors) {
                                var result = base;
                                for (var i = 0; i < argumentsOrAccessors.length; i++) {
                                    switch (argumentsOrAccessors[i].type) {
                                      case "FunctionCallArguments":
                                        result = {
                                            type: "FunctionCall",
                                            name: result,
                                            arguments: argumentsOrAccessors[i].arguments
                                        };
                                        break;

                                      case "PropertyAccessProperty":
                                        result = {
                                            type: "PropertyAccess",
                                            base: result,
                                            name: argumentsOrAccessors[i].name
                                        };
                                        break;

                                      default:
                                        throw new Error("Invalid expression type: " + argumentsOrAccessors[i].type);
                                    }
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_Arguments() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 40) {
                            result0 = "(";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"("');
                            }
                        }
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                result2 = parse_ArgumentList();
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        if (input.charCodeAt(pos.offset) === 41) {
                                            result4 = ")";
                                            advance(pos, 1);
                                        } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('")"');
                                            }
                                        }
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, arguments) {
                                return arguments !== "" ? arguments : [];
                            }(pos0.offset, pos0.line, pos0.column, result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ArgumentList() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_AssignmentExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                if (input.charCodeAt(pos.offset) === 44) {
                                    result3 = ",";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('","');
                                    }
                                }
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_AssignmentExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 44) {
                                        result3 = ",";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('","');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_AssignmentExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = [ head ];
                                for (var i = 0; i < tail.length; i++) {
                                    result.push(tail[i][3]);
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LeftHandSideExpression() {
                        var result0;
                        result0 = parse_CallExpression();
                        if (result0 === null) {
                            result0 = parse_MemberExpression();
                        }
                        return result0;
                    }
                    function parse_PostfixExpression() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_LeftHandSideExpression();
                        if (result0 !== null) {
                            result1 = parse__();
                            if (result1 !== null) {
                                result2 = parse_PostfixOperator();
                                if (result2 !== null) {
                                    result0 = [ result0, result1, result2 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, expression, operator) {
                                return {
                                    type: "PostfixExpression",
                                    operator: operator,
                                    expression: expression
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[2]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            result0 = parse_LeftHandSideExpression();
                        }
                        return result0;
                    }
                    function parse_PostfixOperator() {
                        var result0;
                        if (input.substr(pos.offset, 2) === "++") {
                            result0 = "++";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"++"');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 2) === "--") {
                                result0 = "--";
                                advance(pos, 2);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"--"');
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_UnaryExpression() {
                        var result0, result1, result2;
                        var pos0, pos1;
                        result0 = parse_PostfixExpression();
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            result0 = parse_UnaryOperator();
                            if (result0 !== null) {
                                result1 = parse___();
                                if (result1 !== null) {
                                    result2 = parse_UnaryExpression();
                                    if (result2 !== null) {
                                        result0 = [ result0, result1, result2 ];
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column, operator, expression) {
                                    return {
                                        type: "UnaryExpression",
                                        operator: operator,
                                        expression: expression
                                    };
                                }(pos0.offset, pos0.line, pos0.column, result0[0], result0[2]);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                        }
                        return result0;
                    }
                    function parse_UnaryOperator() {
                        var result0;
                        if (input.substr(pos.offset, 4) === "void") {
                            result0 = "void";
                            advance(pos, 4);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"void"');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 6) === "typeof") {
                                result0 = "typeof";
                                advance(pos, 6);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"typeof"');
                                }
                            }
                            if (result0 === null) {
                                if (input.substr(pos.offset, 2) === "++") {
                                    result0 = "++";
                                    advance(pos, 2);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"++"');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.substr(pos.offset, 2) === "--") {
                                        result0 = "--";
                                        advance(pos, 2);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"--"');
                                        }
                                    }
                                    if (result0 === null) {
                                        if (input.charCodeAt(pos.offset) === 43) {
                                            result0 = "+";
                                            advance(pos, 1);
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"+"');
                                            }
                                        }
                                        if (result0 === null) {
                                            if (input.charCodeAt(pos.offset) === 45) {
                                                result0 = "-";
                                                advance(pos, 1);
                                            } else {
                                                result0 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"-"');
                                                }
                                            }
                                            if (result0 === null) {
                                                if (input.charCodeAt(pos.offset) === 126) {
                                                    result0 = "~";
                                                    advance(pos, 1);
                                                } else {
                                                    result0 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"~"');
                                                    }
                                                }
                                                if (result0 === null) {
                                                    if (input.charCodeAt(pos.offset) === 33) {
                                                        result0 = "!";
                                                        advance(pos, 1);
                                                    } else {
                                                        result0 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('"!"');
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_MultiplicativeExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_UnaryExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_MultiplicativeOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_UnaryExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_MultiplicativeOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_UnaryExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_MultiplicativeOperator() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 42) {
                            result0 = "*";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"*"');
                            }
                        }
                        if (result0 === null) {
                            if (input.charCodeAt(pos.offset) === 47) {
                                result0 = "/";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"/"');
                                }
                            }
                            if (result0 === null) {
                                if (input.charCodeAt(pos.offset) === 37) {
                                    result0 = "%";
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"%"');
                                    }
                                }
                            }
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.charCodeAt(pos.offset) === 61) {
                                result1 = "=";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"="');
                                }
                            }
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, operator) {
                                return operator;
                            }(pos0.offset, pos0.line, pos0.column, result0[0]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_AdditiveExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_MultiplicativeExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_AdditiveOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_MultiplicativeExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_AdditiveOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_MultiplicativeExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_AdditiveOperator() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 43) {
                            result0 = "+";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"+"');
                            }
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.charCodeAt(pos.offset) === 43) {
                                result1 = "+";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"+"');
                                }
                            }
                            if (result1 === null) {
                                if (input.charCodeAt(pos.offset) === 61) {
                                    result1 = "=";
                                    advance(pos, 1);
                                } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"="');
                                    }
                                }
                            }
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "+";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            pos0 = clone(pos);
                            pos1 = clone(pos);
                            if (input.charCodeAt(pos.offset) === 45) {
                                result0 = "-";
                                advance(pos, 1);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"-"');
                                }
                            }
                            if (result0 !== null) {
                                pos2 = clone(pos);
                                reportFailures++;
                                if (input.charCodeAt(pos.offset) === 45) {
                                    result1 = "-";
                                    advance(pos, 1);
                                } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"-"');
                                    }
                                }
                                if (result1 === null) {
                                    if (input.charCodeAt(pos.offset) === 61) {
                                        result1 = "=";
                                        advance(pos, 1);
                                    } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"="');
                                        }
                                    }
                                }
                                reportFailures--;
                                if (result1 === null) {
                                    result1 = "";
                                } else {
                                    result1 = null;
                                    pos = clone(pos2);
                                }
                                if (result1 !== null) {
                                    result0 = [ result0, result1 ];
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                            if (result0 !== null) {
                                result0 = function(offset, line, column) {
                                    return "-";
                                }(pos0.offset, pos0.line, pos0.column);
                            }
                            if (result0 === null) {
                                pos = clone(pos0);
                            }
                        }
                        return result0;
                    }
                    function parse_ShiftExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_AdditiveExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_ShiftOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_AdditiveExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_ShiftOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_AdditiveExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ShiftOperator() {
                        var result0;
                        if (input.substr(pos.offset, 2) === "<<") {
                            result0 = "<<";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"<<"');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 3) === ">>>") {
                                result0 = ">>>";
                                advance(pos, 3);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('">>>"');
                                }
                            }
                            if (result0 === null) {
                                if (input.substr(pos.offset, 2) === ">>") {
                                    result0 = ">>";
                                    advance(pos, 2);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('">>"');
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_RelationalExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_ShiftExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_RelationalOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_ShiftExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_RelationalOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_ShiftExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_RelationalOperator() {
                        var result0;
                        if (input.substr(pos.offset, 2) === "<=") {
                            result0 = "<=";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"<="');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 2) === ">=") {
                                result0 = ">=";
                                advance(pos, 2);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('">="');
                                }
                            }
                            if (result0 === null) {
                                if (input.charCodeAt(pos.offset) === 60) {
                                    result0 = "<";
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"<"');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.charCodeAt(pos.offset) === 62) {
                                        result0 = ">";
                                        advance(pos, 1);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('">"');
                                        }
                                    }
                                    if (result0 === null) {
                                        if (input.substr(pos.offset, 10) === "instanceof") {
                                            result0 = "instanceof";
                                            advance(pos, 10);
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"instanceof"');
                                            }
                                        }
                                        if (result0 === null) {
                                            if (input.substr(pos.offset, 2) === "in") {
                                                result0 = "in";
                                                advance(pos, 2);
                                            } else {
                                                result0 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"in"');
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_RelationalExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_ShiftExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_RelationalOperatorNoIn();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_ShiftExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_RelationalOperatorNoIn();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_ShiftExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_RelationalOperatorNoIn() {
                        var result0;
                        if (input.substr(pos.offset, 2) === "<=") {
                            result0 = "<=";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"<="');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 2) === ">=") {
                                result0 = ">=";
                                advance(pos, 2);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('">="');
                                }
                            }
                            if (result0 === null) {
                                if (input.charCodeAt(pos.offset) === 60) {
                                    result0 = "<";
                                    advance(pos, 1);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"<"');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.charCodeAt(pos.offset) === 62) {
                                        result0 = ">";
                                        advance(pos, 1);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('">"');
                                        }
                                    }
                                    if (result0 === null) {
                                        if (input.substr(pos.offset, 10) === "instanceof") {
                                            result0 = "instanceof";
                                            advance(pos, 10);
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"instanceof"');
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_EqualityExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_RelationalExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_EqualityOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_RelationalExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_EqualityOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_RelationalExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_EqualityExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_RelationalExpressionNoIn();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_EqualityOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_RelationalExpressionNoIn();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_EqualityOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_RelationalExpressionNoIn();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_EqualityOperator() {
                        var result0;
                        if (input.substr(pos.offset, 3) === "===") {
                            result0 = "===";
                            advance(pos, 3);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"==="');
                            }
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 3) === "!==") {
                                result0 = "!==";
                                advance(pos, 3);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"!=="');
                                }
                            }
                            if (result0 === null) {
                                if (input.substr(pos.offset, 2) === "==") {
                                    result0 = "==";
                                    advance(pos, 2);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"=="');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.substr(pos.offset, 2) === "!=") {
                                        result0 = "!=";
                                        advance(pos, 2);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"!="');
                                        }
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_BitwiseANDExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_EqualityExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_BitwiseANDOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_EqualityExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_BitwiseANDOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_EqualityExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BitwiseANDExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_EqualityExpressionNoIn();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_BitwiseANDOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_EqualityExpressionNoIn();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_BitwiseANDOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_EqualityExpressionNoIn();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BitwiseANDOperator() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 38) {
                            result0 = "&";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"&"');
                            }
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.charCodeAt(pos.offset) === 38) {
                                result1 = "&";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"&"');
                                }
                            }
                            if (result1 === null) {
                                if (input.charCodeAt(pos.offset) === 61) {
                                    result1 = "=";
                                    advance(pos, 1);
                                } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"="');
                                    }
                                }
                            }
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "&";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BitwiseXORExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_BitwiseANDExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_BitwiseXOROperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_BitwiseANDExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_BitwiseXOROperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_BitwiseANDExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BitwiseXORExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_BitwiseANDExpressionNoIn();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_BitwiseXOROperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_BitwiseANDExpressionNoIn();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_BitwiseXOROperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_BitwiseANDExpressionNoIn();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BitwiseXOROperator() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 94) {
                            result0 = "^";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"^"');
                            }
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.charCodeAt(pos.offset) === 94) {
                                result1 = "^";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"^"');
                                }
                            }
                            if (result1 === null) {
                                if (input.charCodeAt(pos.offset) === 61) {
                                    result1 = "=";
                                    advance(pos, 1);
                                } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"="');
                                    }
                                }
                            }
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "^";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BitwiseORExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_BitwiseXORExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_BitwiseOROperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_BitwiseXORExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_BitwiseOROperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_BitwiseXORExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BitwiseORExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_BitwiseXORExpressionNoIn();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_BitwiseOROperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_BitwiseXORExpressionNoIn();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_BitwiseOROperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_BitwiseXORExpressionNoIn();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_BitwiseOROperator() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 124) {
                            result0 = "|";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"|"');
                            }
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.charCodeAt(pos.offset) === 124) {
                                result1 = "|";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"|"');
                                }
                            }
                            if (result1 === null) {
                                if (input.charCodeAt(pos.offset) === 61) {
                                    result1 = "=";
                                    advance(pos, 1);
                                } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"="');
                                    }
                                }
                            }
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "|";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LogicalANDExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_BitwiseORExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_LogicalANDOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_BitwiseORExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_LogicalANDOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_BitwiseORExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LogicalANDExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_BitwiseORExpressionNoIn();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_LogicalANDOperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_BitwiseORExpressionNoIn();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_LogicalANDOperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_BitwiseORExpressionNoIn();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LogicalANDOperator() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.substr(pos.offset, 2) === "&&") {
                            result0 = "&&";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"&&"');
                            }
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.charCodeAt(pos.offset) === 61) {
                                result1 = "=";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"="');
                                }
                            }
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "&&";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LogicalORExpression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_LogicalANDExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_LogicalOROperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_LogicalANDExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_LogicalOROperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_LogicalANDExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LogicalORExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_LogicalANDExpressionNoIn();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                result3 = parse_LogicalOROperator();
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_LogicalANDExpressionNoIn();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    result3 = parse_LogicalOROperator();
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_LogicalANDExpressionNoIn();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_LogicalOROperator() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.substr(pos.offset, 2) === "||") {
                            result0 = "||";
                            advance(pos, 2);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"||"');
                            }
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.charCodeAt(pos.offset) === 61) {
                                result1 = "=";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"="');
                                }
                            }
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "||";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ConditionalExpression() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_LogicalORExpression();
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 63) {
                                    result2 = "?";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"?"');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        result4 = parse_AssignmentExpression();
                                        if (result4 !== null) {
                                            result5 = parse___();
                                            if (result5 !== null) {
                                                if (input.charCodeAt(pos.offset) === 58) {
                                                    result6 = ":";
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('":"');
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result7 = parse___();
                                                    if (result7 !== null) {
                                                        result8 = parse_AssignmentExpression();
                                                        if (result8 !== null) {
                                                            result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8 ];
                                                        } else {
                                                            result0 = null;
                                                            pos = clone(pos1);
                                                        }
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, condition, trueExpression, falseExpression) {
                                return {
                                    type: "ConditionalExpression",
                                    condition: condition,
                                    trueExpression: trueExpression,
                                    falseExpression: falseExpression
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[4], result0[8]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            result0 = parse_LogicalORExpression();
                        }
                        return result0;
                    }
                    function parse_ConditionalExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_LogicalORExpressionNoIn();
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                if (input.charCodeAt(pos.offset) === 63) {
                                    result2 = "?";
                                    advance(pos, 1);
                                } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"?"');
                                    }
                                }
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        result4 = parse_AssignmentExpressionNoIn();
                                        if (result4 !== null) {
                                            result5 = parse___();
                                            if (result5 !== null) {
                                                if (input.charCodeAt(pos.offset) === 58) {
                                                    result6 = ":";
                                                    advance(pos, 1);
                                                } else {
                                                    result6 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('":"');
                                                    }
                                                }
                                                if (result6 !== null) {
                                                    result7 = parse___();
                                                    if (result7 !== null) {
                                                        result8 = parse_AssignmentExpressionNoIn();
                                                        if (result8 !== null) {
                                                            result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8 ];
                                                        } else {
                                                            result0 = null;
                                                            pos = clone(pos1);
                                                        }
                                                    } else {
                                                        result0 = null;
                                                        pos = clone(pos1);
                                                    }
                                                } else {
                                                    result0 = null;
                                                    pos = clone(pos1);
                                                }
                                            } else {
                                                result0 = null;
                                                pos = clone(pos1);
                                            }
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, condition, trueExpression, falseExpression) {
                                return {
                                    type: "ConditionalExpression",
                                    condition: condition,
                                    trueExpression: trueExpression,
                                    falseExpression: falseExpression
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[4], result0[8]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            result0 = parse_LogicalORExpressionNoIn();
                        }
                        return result0;
                    }
                    function parse_AssignmentExpression() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_LeftHandSideExpression();
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                result2 = parse_AssignmentOperator();
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        result4 = parse_AssignmentExpression();
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, left, operator, right) {
                                return {
                                    type: "AssignmentExpression",
                                    operator: operator,
                                    left: left,
                                    right: right
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[2], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            result0 = parse_ConditionalExpression();
                        }
                        return result0;
                    }
                    function parse_AssignmentExpressionNoIn() {
                        var result0, result1, result2, result3, result4;
                        var pos0, pos1;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_LeftHandSideExpression();
                        if (result0 !== null) {
                            result1 = parse___();
                            if (result1 !== null) {
                                result2 = parse_AssignmentOperator();
                                if (result2 !== null) {
                                    result3 = parse___();
                                    if (result3 !== null) {
                                        result4 = parse_AssignmentExpressionNoIn();
                                        if (result4 !== null) {
                                            result0 = [ result0, result1, result2, result3, result4 ];
                                        } else {
                                            result0 = null;
                                            pos = clone(pos1);
                                        }
                                    } else {
                                        result0 = null;
                                        pos = clone(pos1);
                                    }
                                } else {
                                    result0 = null;
                                    pos = clone(pos1);
                                }
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, left, operator, right) {
                                return {
                                    type: "AssignmentExpression",
                                    operator: operator,
                                    left: left,
                                    right: right
                                };
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[2], result0[4]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            result0 = parse_ConditionalExpressionNoIn();
                        }
                        return result0;
                    }
                    function parse_AssignmentOperator() {
                        var result0, result1;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        if (input.charCodeAt(pos.offset) === 61) {
                            result0 = "=";
                            advance(pos, 1);
                        } else {
                            result0 = null;
                            if (reportFailures === 0) {
                                matchFailed('"="');
                            }
                        }
                        if (result0 !== null) {
                            pos2 = clone(pos);
                            reportFailures++;
                            if (input.charCodeAt(pos.offset) === 61) {
                                result1 = "=";
                                advance(pos, 1);
                            } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"="');
                                }
                            }
                            reportFailures--;
                            if (result1 === null) {
                                result1 = "";
                            } else {
                                result1 = null;
                                pos = clone(pos2);
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column) {
                                return "=";
                            }(pos0.offset, pos0.line, pos0.column);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        if (result0 === null) {
                            if (input.substr(pos.offset, 2) === "*=") {
                                result0 = "*=";
                                advance(pos, 2);
                            } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                    matchFailed('"*="');
                                }
                            }
                            if (result0 === null) {
                                if (input.substr(pos.offset, 2) === "/=") {
                                    result0 = "/=";
                                    advance(pos, 2);
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('"/="');
                                    }
                                }
                                if (result0 === null) {
                                    if (input.substr(pos.offset, 2) === "%=") {
                                        result0 = "%=";
                                        advance(pos, 2);
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('"%="');
                                        }
                                    }
                                    if (result0 === null) {
                                        if (input.substr(pos.offset, 2) === "+=") {
                                            result0 = "+=";
                                            advance(pos, 2);
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) {
                                                matchFailed('"+="');
                                            }
                                        }
                                        if (result0 === null) {
                                            if (input.substr(pos.offset, 2) === "-=") {
                                                result0 = "-=";
                                                advance(pos, 2);
                                            } else {
                                                result0 = null;
                                                if (reportFailures === 0) {
                                                    matchFailed('"-="');
                                                }
                                            }
                                            if (result0 === null) {
                                                if (input.substr(pos.offset, 3) === "<<=") {
                                                    result0 = "<<=";
                                                    advance(pos, 3);
                                                } else {
                                                    result0 = null;
                                                    if (reportFailures === 0) {
                                                        matchFailed('"<<="');
                                                    }
                                                }
                                                if (result0 === null) {
                                                    if (input.substr(pos.offset, 3) === ">>=") {
                                                        result0 = ">>=";
                                                        advance(pos, 3);
                                                    } else {
                                                        result0 = null;
                                                        if (reportFailures === 0) {
                                                            matchFailed('">>="');
                                                        }
                                                    }
                                                    if (result0 === null) {
                                                        if (input.substr(pos.offset, 4) === ">>>=") {
                                                            result0 = ">>>=";
                                                            advance(pos, 4);
                                                        } else {
                                                            result0 = null;
                                                            if (reportFailures === 0) {
                                                                matchFailed('">>>="');
                                                            }
                                                        }
                                                        if (result0 === null) {
                                                            if (input.substr(pos.offset, 2) === "&=") {
                                                                result0 = "&=";
                                                                advance(pos, 2);
                                                            } else {
                                                                result0 = null;
                                                                if (reportFailures === 0) {
                                                                    matchFailed('"&="');
                                                                }
                                                            }
                                                            if (result0 === null) {
                                                                if (input.substr(pos.offset, 2) === "^=") {
                                                                    result0 = "^=";
                                                                    advance(pos, 2);
                                                                } else {
                                                                    result0 = null;
                                                                    if (reportFailures === 0) {
                                                                        matchFailed('"^="');
                                                                    }
                                                                }
                                                                if (result0 === null) {
                                                                    if (input.substr(pos.offset, 2) === "|=") {
                                                                        result0 = "|=";
                                                                        advance(pos, 2);
                                                                    } else {
                                                                        result0 = null;
                                                                        if (reportFailures === 0) {
                                                                            matchFailed('"|="');
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return result0;
                    }
                    function parse_Expression() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_AssignmentExpression();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                if (input.charCodeAt(pos.offset) === 44) {
                                    result3 = ",";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('","');
                                    }
                                }
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_AssignmentExpression();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 44) {
                                        result3 = ",";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('","');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_AssignmentExpression();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function parse_ExpressionNoIn() {
                        var result0, result1, result2, result3, result4, result5;
                        var pos0, pos1, pos2;
                        pos0 = clone(pos);
                        pos1 = clone(pos);
                        result0 = parse_AssignmentExpressionNoIn();
                        if (result0 !== null) {
                            result1 = [];
                            pos2 = clone(pos);
                            result2 = parse___();
                            if (result2 !== null) {
                                if (input.charCodeAt(pos.offset) === 44) {
                                    result3 = ",";
                                    advance(pos, 1);
                                } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                        matchFailed('","');
                                    }
                                }
                                if (result3 !== null) {
                                    result4 = parse___();
                                    if (result4 !== null) {
                                        result5 = parse_AssignmentExpressionNoIn();
                                        if (result5 !== null) {
                                            result2 = [ result2, result3, result4, result5 ];
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            } else {
                                result2 = null;
                                pos = clone(pos2);
                            }
                            while (result2 !== null) {
                                result1.push(result2);
                                pos2 = clone(pos);
                                result2 = parse___();
                                if (result2 !== null) {
                                    if (input.charCodeAt(pos.offset) === 44) {
                                        result3 = ",";
                                        advance(pos, 1);
                                    } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                            matchFailed('","');
                                        }
                                    }
                                    if (result3 !== null) {
                                        result4 = parse___();
                                        if (result4 !== null) {
                                            result5 = parse_AssignmentExpressionNoIn();
                                            if (result5 !== null) {
                                                result2 = [ result2, result3, result4, result5 ];
                                            } else {
                                                result2 = null;
                                                pos = clone(pos2);
                                            }
                                        } else {
                                            result2 = null;
                                            pos = clone(pos2);
                                        }
                                    } else {
                                        result2 = null;
                                        pos = clone(pos2);
                                    }
                                } else {
                                    result2 = null;
                                    pos = clone(pos2);
                                }
                            }
                            if (result1 !== null) {
                                result0 = [ result0, result1 ];
                            } else {
                                result0 = null;
                                pos = clone(pos1);
                            }
                        } else {
                            result0 = null;
                            pos = clone(pos1);
                        }
                        if (result0 !== null) {
                            result0 = function(offset, line, column, head, tail) {
                                var result = head;
                                for (var i = 0; i < tail.length; i++) {
                                    result = {
                                        type: "BinaryExpression",
                                        operator: tail[i][1],
                                        left: result,
                                        right: tail[i][3]
                                    };
                                }
                                return result;
                            }(pos0.offset, pos0.line, pos0.column, result0[0], result0[1]);
                        }
                        if (result0 === null) {
                            pos = clone(pos0);
                        }
                        return result0;
                    }
                    function cleanupExpected(expected) {
                        expected.sort();
                        var lastExpected = null;
                        var cleanExpected = [];
                        for (var i = 0; i < expected.length; i++) {
                            if (expected[i] !== lastExpected) {
                                cleanExpected.push(expected[i]);
                                lastExpected = expected[i];
                            }
                        }
                        return cleanExpected;
                    }
                    var result = parseFunctions[startRule]();
                    /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos.offset === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos.offset < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos.offset === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
                    if (result === null || pos.offset !== input.length) {
                        var offset = Math.max(pos.offset, rightmostFailuresPos.offset);
                        var found = offset < input.length ? input.charAt(offset) : null;
                        var errorPosition = pos.offset > rightmostFailuresPos.offset ? pos : rightmostFailuresPos;
                        throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);
                    }
                    return result;
                },
                /* Returns the parser source code. */
                toSource: function() {
                    return this._source;
                }
            };
            /* Thrown when a parser encounters a syntax error. */
            result.SyntaxError = function(expected, found, offset, line, column) {
                function buildMessage(expected, found) {
                    var expectedHumanized, foundHumanized;
                    switch (expected.length) {
                      case 0:
                        expectedHumanized = "end of input";
                        break;

                      case 1:
                        expectedHumanized = expected[0];
                        break;

                      default:
                        expectedHumanized = expected.slice(0, expected.length - 1).join(", ") + " or " + expected[expected.length - 1];
                    }
                    foundHumanized = found ? quote(found) : "end of input";
                    return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
                }
                this.name = "SyntaxError";
                this.expected = expected;
                this.found = found;
                this.message = buildMessage(expected, found);
                this.offset = offset;
                this.line = line;
                this.column = column;
            };
            result.SyntaxError.prototype = Error.prototype;
            return result;
        }();
    });
    define("hsp/compiler/parser/index.js", [ "./hspblocks.peg.js" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var blockParser = require("./hspblocks.peg.js");
        /**
 * Return the list of instruction blocks that compose a template file.
 * At this stage the template AST is not complete, it is built in the next step of the compilation process, i.e. the treebuilder.
 * Note: this function is exposed for unit test purposes and should not be used directly
 * @param {String} template the template to parse
 * @return {Object} the parse result
 */
        exports.parse = function(template) {
            // add a last line feed a the end of the template as the parser parses the plaintext
            // sequences only when ending with a new line sequence (workaround to solve pegjs issue)
            return blockParser.parse(template + "\r\n");
        };
    });
    define("hsp/compiler/treebuilder/hExpression.js", [ "../../klass" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var klass = require("../../klass");
        var HExpression = klass({
            /**
     * Process the HExpression node parsed by the PEG grammar to generate a more digestable format for the syntax tree
     * (note:processing is mostly for the JSExpression parts)
     * @param {JSON} node the node generated by the PEG Grammar (cf. HExpression)
     * @param {SyntaxTree} globalSyntaxTree the parent syntax tree
     */
            $constructor: function(node, globalSyntaxTree) {
                this.rootExpression = node;
                this.errors = null;
                this.globalSyntaxTree = globalSyntaxTree;
                if (node.expType) {
                    node.type = node.expType;
                }
                if (node.category !== "jsexpression") {
                    // we only reprocess jsexpression
                    this.syntaxTree = node;
                } else {
                    this._objectRefs = [];
                    // list of objectref expressions found in the jsexpression
                    var code = this._process(node);
                    this.rootExpression.code = code;
                    this.syntaxTree = {
                        type: "expression",
                        category: "jsexpression",
                        objectrefs: this._objectRefs,
                        code: code
                    };
                    // if we have only one variable, we can simplify the syntaxtree
                    if (code === "a0") {
                        this.syntaxTree = this._objectRefs[0];
                    } else if (code.match(/^ *$/)) {
                        // there is no code to display
                        this.syntaxTree = {
                            type: "text",
                            value: code
                        };
                    }
                    // add line / column nbr if present
                    if (node.line) {
                        this.syntaxTree.line = node.line;
                        this.syntaxTree.column = node.column;
                    }
                    // check errors
                    if (this.errors) {
                        for (var i = 0; i < this.errors.length; i++) {
                            globalSyntaxTree._logError(this.errors[i], this.rootExpression);
                        }
                    }
                }
            },
            /**
     * Return the syntax tree node to put in the global syntax tree
     */
            getSyntaxTree: function() {
                return this.syntaxTree;
            },
            /**
     * Log an error on the syntax tree associated to this expression
     */
            _logError: function(msg) {
                if (!this.errors) {
                    this.errors = [];
                }
                this.errors.push(msg);
            },
            /**
     * Internal recursive method to process a node
     * @param {JSON} node the expression node to be processed
     * @return {String} the JS code associated to this node
     */
            _process: function(node) {
                var result = "";
                switch (node.type) {
                  case "expression":
                    result = this._getValue(node);
                    break;

                  case "BinaryExpression":
                    result = "(" + this._process(node.left) + " " + node.operator + " " + this._process(node.right) + ")";
                    break;

                  case "UnaryExpression":
                    // e.g. !x +x -x typeof x. Note that ++x and --x will not be supported
                    result = "" + node.operator + "(" + this._process(node.expression) + ")";
                    if (node.operator === "++" || node.operator === "--") {
                        this._logError("Unary operator " + node.operator + " is not allowed");
                    }
                    break;

                  case "PostfixExpression":
                    // e.g. x++ or x-- (not allowed)
                    result = "" + "(" + this._process(node.expression) + ")" + node.operator;
                    this._logError("Postfix operator " + node.operator + " is not allowed");
                    break;

                  case "Variable":
                    result = this._getValue({
                        type: "expression",
                        category: "objectref",
                        bound: node.bound,
                        path: [ node.name ]
                    });
                    break;

                  case "PropertyAccess":
                    // this is an object ref
                    var n = node, path = [], name;
                    while (n) {
                        name = n.name;
                        if (name.type && name.type === "expression") {
                            path.push(name.value);
                        } else {
                            path.push(name);
                        }
                        n = n.base;
                    }
                    path.reverse();
                    result = this._getValue({
                        type: "expression",
                        category: "objectref",
                        bound: node.bound,
                        path: path
                    });
                    break;

                  case "ConditionalExpression":
                    result = "(" + this._process(node.condition) + "? " + this._process(node.trueExpression) + " : " + this._process(node.falseExpression) + ")";
                    break;

                  case "FunctionCall":
                    // this is an object ref
                    var n = node.name, path = [];
                    while (n) {
                        path.push(n.name);
                        n = n.base;
                    }
                    path.reverse();
                    var n = {
                        type: "expression",
                        category: "functionref",
                        bound: node.bound,
                        path: path
                    };
                    result = this._getValue(n);
                    // add arguments
                    var outArgs = [], args = node.arguments;
                    for (var i = 0; i < (args ? args.length : 0); i++) {
                        if (!args[i].category) {
                            // add category otherwise HExpression will not be parsed
                            args[i].category = "jsexpression";
                        }
                        var expr = new HExpression(args[i], this.globalSyntaxTree);
                        outArgs[i] = expr.getSyntaxTree();
                    }
                    n.args = outArgs;
                    break;

                  case "CssClassElement":
                    result = "((" + this._process(node.right) + ")? ''+" + this._process(node.left) + ":'')";
                    break;

                  case "CssClassExpression":
                    var list = node.list, length = list.length, code = [];
                    for (var i = 0; i < length; i++) {
                        code[i] = this._process(list[i]);
                    }
                    if (length < 1) {
                        result = "";
                    } else {
                        result = "[" + code.join(",") + "].join(' ')";
                    }
                    break;

                  case "ObjectLiteral":
                    var properties = node.properties, length = properties.length, code = [];
                    for (var i = 0; i < length; i++) {
                        code[i] = this._process(properties[i]);
                    }
                    if (length < 1) {
                        result = "";
                    } else {
                        result = "{" + code.join(",") + "}";
                    }
                    break;

                  case "PropertyAssignment":
                    var name = node.name, child = node.value;
                    var code = this._process(child);
                    result = name + ":" + code;
                    break;

                  default:
                    this._logError(node.type + "(s) are not supported yet");
                    console.warn("[HExpression] " + node.type + "(s) are not supported yet:");
                    console.dir(node);
                    break;
                }
                return result;
            },
            /**
     * Returns the code value for a node of type "expression" (i.e. literals, objectrefs...).
     * @param {Object} node the node.
     * @return {String} the value of the node.
     */
            _getValue: function(node) {
                var result = "";
                switch (node.category) {
                  case "objectref":
                    var length = this._objectRefs.length, expr, pathLength, ok;
                    // check if an indentical expression already exist
                    for (var i = 0; i < length; i++) {
                        expr = this._objectRefs[i], pathLength = expr.path.length, ok = true;
                        // only the path may vary
                        if (expr.category !== "objectref") {
                            continue;
                        }
                        if (pathLength === node.path.length) {
                            for (var j = 0; j < pathLength; j++) {
                                if (expr.path[j] !== node.path[j]) {
                                    ok = false;
                                    break;
                                }
                            }
                            if (ok) {
                                result = "a" + i;
                                break;
                            }
                        }
                    }
                    if (!result) {
                        // objectref doesn't exist in previous expressions
                        result = "a" + length;
                        // argument variable
                        this._objectRefs[length] = node;
                    }
                    break;

                  case "functionref":
                    // add the function call to the object ref list
                    // we don't optimize the storeage as it is less likely to have the same combination repeated
                    // than with simple object refs
                    var length = this._objectRefs.length;
                    result = "a" + length;
                    // argument variable
                    this._objectRefs[length] = node;
                    break;

                  case "string":
                    result = '"' + node.value.replace(/\"/g, '\\"') + '"';
                    break;

                  case "boolean":
                  case "number":
                    result = node.value;
                    break;

                  case "null":
                    result = "null";
                    break;
                }
                return result;
            }
        });
        exports.HExpression = HExpression;
    });
    define("hsp/compiler/treebuilder/htmlEntities.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var NAMED_HTML_ENTITIES = {
            quot: 34,
            amp: 38,
            apos: 39,
            lt: 60,
            gt: 62,
            nbsp: 160,
            iexcl: 161,
            cent: 162,
            pound: 163,
            curren: 164,
            yen: 165,
            brvbar: 166,
            sect: 167,
            uml: 168,
            copy: 169,
            ordf: 170,
            laquo: 171,
            not: 172,
            shy: 173,
            reg: 174,
            macr: 175,
            deg: 176,
            plusmn: 177,
            sup2: 178,
            sup3: 179,
            acute: 180,
            micro: 181,
            para: 182,
            middot: 183,
            cedil: 184,
            sup1: 185,
            ordm: 186,
            raquo: 187,
            frac14: 188,
            frac12: 189,
            frac34: 190,
            iquest: 191,
            Agrave: 192,
            Aacute: 193,
            Acirc: 194,
            Atilde: 195,
            Auml: 196,
            Aring: 197,
            AElig: 198,
            Ccedil: 199,
            Egrave: 200,
            Eacute: 201,
            Ecirc: 202,
            Euml: 203,
            Igrave: 204,
            Iacute: 205,
            Icirc: 206,
            Iuml: 207,
            ETH: 208,
            Ntilde: 209,
            Ograve: 210,
            Oacute: 211,
            Ocirc: 212,
            Otilde: 213,
            Ouml: 214,
            times: 215,
            Oslash: 216,
            Ugrave: 217,
            Uacute: 218,
            Ucirc: 219,
            Uuml: 220,
            Yacute: 221,
            THORN: 222,
            szlig: 223,
            agrave: 224,
            aacute: 225,
            acirc: 226,
            atilde: 227,
            auml: 228,
            aring: 229,
            aelig: 230,
            ccedil: 231,
            egrave: 232,
            eacute: 233,
            ecirc: 234,
            euml: 235,
            igrave: 236,
            iacute: 237,
            icirc: 238,
            iuml: 239,
            eth: 240,
            ntilde: 241,
            ograve: 242,
            oacute: 243,
            ocirc: 244,
            otilde: 245,
            ouml: 246,
            divide: 247,
            oslash: 248,
            ugrave: 249,
            uacute: 250,
            ucirc: 251,
            uuml: 252,
            yacute: 253,
            thorn: 254,
            yuml: 255,
            OElig: 338,
            oelig: 339,
            Scaron: 352,
            scaron: 353,
            Yuml: 376,
            fnof: 402,
            circ: 710,
            tilde: 732,
            Alpha: 913,
            Beta: 914,
            Gamma: 915,
            Delta: 916,
            Epsilon: 917,
            Zeta: 918,
            Eta: 919,
            Theta: 920,
            Iota: 921,
            Kappa: 922,
            Lambda: 923,
            Mu: 924,
            Nu: 925,
            Xi: 926,
            Omicron: 927,
            Pi: 928,
            Rho: 929,
            Sigma: 931,
            Tau: 932,
            psilon: 933,
            Phi: 934,
            Chi: 935,
            Psi: 936,
            Omega: 937,
            alpha: 945,
            beta: 946,
            gamma: 947,
            delta: 948,
            epsilon: 949,
            zeta: 950,
            eta: 951,
            theta: 952,
            iota: 953,
            kappa: 954,
            lambda: 955,
            mu: 956,
            nu: 957,
            xi: 958,
            omicron: 959,
            pi: 960,
            rho: 961,
            sigmaf: 962,
            sigma: 963,
            tau: 964,
            upsilon: 965,
            phi: 966,
            chi: 967,
            psi: 968,
            omega: 969,
            thetasym: 977,
            upsih: 978,
            piv: 982,
            ensp: 8194,
            emsp: 8195,
            thinsp: 8201,
            zwnj: 8204,
            zwj: 8205,
            lrm: 8206,
            rlm: 8207,
            ndash: 8211,
            mdash: 8212,
            lsquo: 8216,
            rsquo: 8217,
            sbquo: 8218,
            ldquo: 8220,
            rdquo: 8221,
            bdquo: 8222,
            dagger: 8224,
            Dagger: 8225,
            bull: 8226,
            hellip: 8230,
            permil: 8240,
            prime: 8242,
            Prime: 8243,
            lsaquo: 8249,
            rsaquo: 8250,
            oline: 8254,
            frasl: 8260,
            euro: 8364,
            image: 8465,
            weierp: 8472,
            real: 8476,
            trade: 8482,
            alefsym: 8501,
            larr: 8592,
            uarr: 8593,
            rarr: 8594,
            darr: 8595,
            harr: 8596,
            crarr: 8629,
            lArr: 8656,
            uArr: 8657,
            rArr: 8658,
            dArr: 8659,
            hArr: 8660,
            forall: 8704,
            part: 8706,
            exist: 8707,
            empty: 8709,
            nabla: 8711,
            isin: 8712,
            notin: 8713,
            ni: 8715,
            prod: 8719,
            sum: 8721,
            minus: 8722,
            lowast: 8727,
            radic: 8730,
            prop: 8733,
            infin: 8734,
            ang: 8736,
            and: 8743,
            or: 8744,
            cap: 8745,
            cup: 8746,
            "int": 8747,
            there4: 8756,
            sim: 8764,
            cong: 8773,
            asymp: 8776,
            ne: 8800,
            equiv: 8801,
            le: 8804,
            ge: 8805,
            sub: 8834,
            sup: 8835,
            nsub: 8836,
            sube: 8838,
            supe: 8839,
            oplus: 8853,
            otimes: 8855,
            perp: 8869,
            sdot: 8901,
            vellip: 8942,
            lceil: 8968,
            rceil: 8969,
            lfloor: 8970,
            rfloor: 8971,
            lang: 9001,
            rang: 9002,
            loz: 9674,
            spades: 9824,
            clubs: 9827,
            hearts: 9829,
            diams: 9830
        };
        /**
 * A utility function that accepts a string and converts all the HTML character references
 * (both named and numeric) into their unicode representation.
 * @param {String} inputText text in which HTML entities should be replaced.
 * @return {String} The converted string.
 */
        exports.htmlEntitiesToUtf8 = function(inputText) {
            //http://www.w3.org/TR/html5/syntax.html#character-references
            var entitiesPattern = /&(#([xX])?)?([A-Za-z0-9]+);/g;
            return inputText ? inputText.replace(entitiesPattern, function(match, isNumeric, isHex, entityName) {
                var replacementCode;
                if (isNumeric) {
                    replacementCode = parseInt(entityName, isHex ? 16 : 10);
                } else {
                    //named entities
                    if (NAMED_HTML_ENTITIES.hasOwnProperty(entityName)) {
                        replacementCode = NAMED_HTML_ENTITIES[entityName];
                    } else {
                        throw new Error('"' + match + '" is not a valid HTML entity.');
                    }
                }
                return String.fromCharCode(replacementCode);
            }) : inputText;
        };
    });
    define("hsp/compiler/treebuilder/syntaxTree.js", [ "../../klass", "./hExpression", "./htmlEntities" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var klass = require("../../klass");
        var HExpression = require("./hExpression").HExpression;
        var htmlEntitiesToUtf8 = require("./htmlEntities").htmlEntitiesToUtf8;
        //http://www.w3.org/TR/html-markup/syntax.html#syntax-elements
        var VOID_HTML_ELEMENTS = {
            area: true,
            base: true,
            br: true,
            col: true,
            command: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
        };
        /**
 * Checks if an element is a void one.
 * @param {String} the element name.
 * @return {Boolean} true if the element is a void one.
 */
        function isVoidElement(elName) {
            var result = false;
            if (elName && elName.toLowerCase) {
                result = VOID_HTML_ELEMENTS.hasOwnProperty(elName.toLowerCase());
            }
            return result;
        }
        /**
 * Node of the Syntax tree
 */
        var Node = klass({
            $constructor: function(type, parent) {
                this.type = type;
                this.parent = parent;
            }
        });
        /**
 * A map of the reserved keywords.
 */
        var reservedKeywords = {
            event: true,
            scope: true
        };
        /**
 * The SyntaxTree class made to build the syntax tree from the block list from the parser. 
 * Entry point: generateTree()
 */
        var SyntaxTree = klass({
            /**
     * Generate the syntax tree from the root block list.
     * @param {Object} blockList the block list.
     */
            generateTree: function(blockList) {
                this.errors = [];
                this.tree = new Node("file", null);
                this.tree.content = [];
                this._advance(blockList, 0, this.tree.content);
                this._postProcessTree();
            },
            /**
     * Adds an error to the current error list.
     * @param {String} description the error description
     * @param {Object} errdesc additional object (block, node, ...) which can contain additional info about the error (line/column number, code).
     */
            _logError: function(description, errdesc) {
                //TODO: errdesc is a bit vague
                var desc = {
                    description: description
                };
                if (errdesc) {
                    if (errdesc.line) {
                        desc.line = errdesc.line;
                        desc.column = errdesc.column;
                    }
                    if (errdesc.code) {
                        desc.code = errdesc.code;
                    }
                }
                this.errors.push(desc);
            },
            /**
     * Process a list of blocks and advance the cursor index that scans the collection.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} startIndex the index from which the process has to start.
     * @param {Array} out the output as an array of Node.
     * @param {Function} optEndFn an optional end function that takes a node type as argument.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            _advance: function(blocks, startIndex, out, optEndFn) {
                var block, type;
                if (blocks) {
                    for (var i = startIndex; i < blocks.length; i++) {
                        block = blocks[i];
                        type = block.type;
                        if (optEndFn && optEndFn(type, block.name)) {
                            // we stop here
                            return i;
                        }
                        //by convention, a block of type xyz is managed by a __xyz function in the class 
                        if (this["__" + type]) {
                            i = this["__" + type](i, blocks, out);
                        } else {
                            this._logError("Invalid statement: " + type, block);
                        }
                    }
                    return blocks.length;
                }
            },
            /**
     * Post validation once the tree is properly parsed.
     */
            _postProcessTree: function() {
                var nodes = this.tree.content;
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i].type === "template") {
                        this._processNodeContent(nodes[i].content, nodes[i]);
                    }
                }
            },
            /**
     * Validates the content of a container node.
     * @param {Array} nodeList the content of a container node
     * @param {Node} parent the parent node
     */
            _processNodeContent: function(nodeList, parent) {
                // Ensure that {let} nodes are always at the beginning of a containter element
                var node, contentFound = false;
                // true when a node different from let is found
                for (var i = 0; i < nodeList.length; i++) {
                    node = nodeList[i];
                    //console.log(i+":"+node.type)
                    if (node.type === "comment") {
                        continue;
                    }
                    if (node.type === "text") {
                        // tolerate static white space text
                        if (node.value.match(/^\s*$/)) {
                            continue;
                        }
                    }
                    if (node.type === "let") {
                        if (contentFound) {
                            // error: let must be defined before any piece of content
                            this._logError("Let statements must be defined at the beginning of a block", node);
                        } else {
                            parent.needSubScope = true;
                        }
                    } else {
                        contentFound = true;
                        if (node.content) {
                            this._processNodeContent(node.content, node);
                        }
                        if (node.content1) {
                            this._processNodeContent(node.content1, node);
                        }
                        if (node.content2) {
                            this._processNodeContent(node.content2, node);
                        }
                    }
                }
            },
            /**
     * Manages a template block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __template: function(index, blocks, out) {
                var node = new Node("template"), block = blocks[index];
                node.name = block.name;
                if (block.controller) {
                    node.controller = block.controller;
                    node.controller.ref = block.controllerRef;
                } else {
                    node.args = block.args;
                    // check args
                    for (var i = 0; i < node.args.length; i++) {
                        if (reservedKeywords[node.args[i]]) {
                            this._logError("Reserved keywords cannot be used as template argument: " + node.args[i], block);
                        }
                    }
                }
                node.export = block.mod === "export";
                node.startLine = block.line;
                node.endLine = block.endLine;
                node.content = [];
                out.push(node);
                if (block.mod !== "" && block.mod !== "export") {
                    this._logError("Invalid template template modifier: " + block.mod, blocks[index]);
                }
                if (!block.closed) {
                    this._logError("Missing end template statement", block);
                }
                // parse sub-list of blocks
                this._advance(block.content, 0, node.content);
                return index;
            },
            /**
     * Catches invalid template definitions.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __invalidtemplate: function(index, blocks, out) {
                this._logError("Invalid template declaration", blocks[index]);
                return index;
            },
            /**
     * Manages a text block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __plaintext: function(index, blocks, out) {
                var node = new Node("plaintext"), block = blocks[index];
                node.value = block.value;
                out.push(node);
                return index;
            },
            /**
     * Manages a log statement.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __log: function(index, blocks, out) {
                var node = new Node("log"), block = blocks[index], exprs = [];
                node.line = block.line;
                node.column = block.column;
                for (var i = 0; i < block.exprs.length; i++) {
                    var expr = new HExpression(block.exprs[i], this);
                    exprs[i] = expr.getSyntaxTree();
                }
                node.exprs = exprs;
                out.push(node);
                return index;
            },
            /**
     * Manages a let statement.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __let: function(index, blocks, out) {
                var node = new Node("let"), block = blocks[index], assignments = [];
                node.line = block.line;
                node.column = block.column;
                for (var i = 0; i < block.assignments.length; i++) {
                    var expr = new HExpression(block.assignments[i].value, this);
                    assignments.push({
                        identifier: block.assignments[i].identifier,
                        value: expr.getSyntaxTree()
                    });
                }
                node.assignments = assignments;
                out.push(node);
                return index;
            },
            /**
     * Manages a text block: regroups adjacent text and expression blocks
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __text: function(index, blocks, out) {
                var length = blocks.length, buffer = [], insertIndex = -1;
                //Regroups adjacent text and expression blocks by looking at the next ones
                var nextIndex = index, goAhead = length > nextIndex, block;
                while (goAhead) {
                    block = blocks[nextIndex];
                    if (block.type === "text") {
                        if (block.value !== "") {
                            try {
                                block.value = htmlEntitiesToUtf8(block.value);
                                buffer.push(block);
                            } catch (e) {
                                this._logError(e.message, block);
                            }
                        }
                    } else if (block.type === "expression") {
                        if (block.category === "jsexpression") {
                            // pre-process expression
                            var expr = new HExpression(block, this);
                            // inject the processed expression in the block list
                            block = blocks[nextIndex] = expr.getSyntaxTree();
                        }
                        if (block.category === "invalidexpression") {
                            this._logError("Invalid expression", block);
                        } else if (block.category !== "functionref") {
                            buffer.push(block);
                        } else {
                            // this is an insert statement
                            insertIndex = nextIndex;
                            nextIndex++;
                            // will be handled below
                            goAhead = false;
                        }
                    } else if (block.type === "comment") {} else {
                        goAhead = false;
                    }
                    if (goAhead) {
                        nextIndex++;
                        goAhead = length > nextIndex;
                    }
                }
                //Manages the adjacent text and expression blocks found
                var node = null;
                if (buffer.length === 1 && buffer[0].type === "text") {
                    // only one text block
                    node = new Node("text");
                    node.value = buffer[0].value;
                } else if (buffer.length > 0) {
                    // if buffer is composed of only text expressions we concatenate them
                    var onlyText = true;
                    for (var i = 0; i < buffer.length; i++) {
                        if (buffer[i].type !== "text") {
                            onlyText = false;
                            break;
                        }
                    }
                    if (onlyText) {
                        var texts = [];
                        for (var i = 0; i < buffer.length; i++) {
                            texts.push(buffer[i].value);
                        }
                        node = new Node("text");
                        node.value = texts.join("");
                    } else {
                        // an expression or several blocks have to be aggregated
                        node = new Node("textblock");
                        node.content = buffer;
                    }
                }
                if (node) {
                    out.push(node);
                }
                if (insertIndex > -1) {
                    // an insert block has to be added after the text block
                    this.__insert(insertIndex, blocks, out);
                }
                // return the last index that was handled
                return nextIndex > index ? nextIndex - 1 : index;
            },
            /**
     * Manages an expression block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __expression: function(index, blocks, out) {
                var block = blocks[index];
                if (block.category === "invalidexpression") {
                    this._logError("Invalid expression", block);
                    return index;
                }
                return this.__text(index, blocks, out);
            },
            /**
     * Catches invalid expressions.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __invalidexpression: function(index, blocks, out) {
                this._logError("Invalid expression", blocks[index]);
                return index;
            },
            /**
     * Manages an insert block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __insert: function(index, blocks, out) {
                var node = new Node("insert"), block = blocks[index];
                node.path = block.path;
                node.args = block.args;
                if (node.path.length > 1) {
                    this._logError("Long paths for insert statements are not supported yet: " + node.path.join("."), block);
                } else {
                    out.push(node);
                }
                return index;
            },
            /**
     * Manages an if block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __if: function(index, blocks, out) {
                //creates the if node
                var node = new Node("if"), block = blocks[index], lastValidIndex = index;
                var condition = new HExpression(block.condition, this);
                node.condition = condition.getSyntaxTree();
                node.condition.bound = true;
                node.content1 = [];
                out.push(node);
                var endFound = false, out2 = node.content1;
                if (node.condition.type === "invalidexpression") {
                    this._logError("Invalid if condition", node.condition);
                }
                //process the content of the if block, until one of the if end is found (i.e. endif, else or elseif), if any
                while (!endFound) {
                    //fills node.content1 with the next blocks
                    index = this._advance(blocks, index + 1, out2, this._ifEndTypes);
                    if (index < 0 || !blocks[index]) {
                        this._logError("Missing end if statement", blocks[lastValidIndex]);
                        endFound = true;
                    } else {
                        var type = blocks[index].type;
                        if (type === "endif") {
                            endFound = true;
                        } else if (type === "else") {
                            //loop will restrat, filling node.content2 with the next blocks
                            node.content2 = [];
                            out2 = node.content2;
                            lastValidIndex = index;
                        } else if (type === "elseif") {
                            // consider as a standard else statement
                            node.content2 = [];
                            out2 = node.content2;
                            lastValidIndex = index;
                            endFound = true;
                            // process as if it were an if node
                            index = this.__if(index, blocks, out2);
                        }
                    }
                }
                return index;
            },
            /**
     * Detects if blocks end types.
     * @param {String} type the block type.
     * @retrun {Boolean} true if the block terminates an if.
     */
            _ifEndTypes: function(type) {
                return type === "endif" || type === "else" || type === "elseif";
            },
            /**
     * Manages an endif block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endif: function(index, blocks, out) {
                // only called in case of error, i.e not digested by __if
                var block = blocks[index];
                this._logError("{/if} statement does not match any {if} block", block);
                return index;
            },
            /**
     * Manages an else block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __else: function(index, blocks, out) {
                // only called in case of error, i.e not digested by __if
                var block = blocks[index];
                this._logError("{else} statement found outside any {if} block", block);
                return index;
            },
            /**
     * Manages an elseif block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __elseif: function(index, blocks, out) {
                // only called in case of error, i.e not digested by __if
                var block = blocks[index];
                this._logError("{else if} statement found outside any {if} block", block);
                return index;
            },
            /**
     * Manages a foreach block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __foreach: function(index, blocks, out) {
                //creates the foreach node
                var node = new Node("foreach"), block = blocks[index];
                node.item = block.item;
                node.key = block.key;
                node.collection = block.colref;
                node.collection.bound = true;
                node.content = [];
                out.push(node);
                //fills node.content with the next blocks, until an endforeach is found, if any
                var nextIndex = this._advance(blocks, index + 1, node.content, this._foreachEndTypes);
                if (nextIndex < 0 || !blocks[nextIndex]) {
                    this._logError("Missing end foreach statement", blocks[index]);
                }
                return nextIndex;
            },
            /**
     * Detects foreach end.
     * @param {String} type the block type.
     * @retrun {Boolean} true if the block terminates an foreach.
     */
            _foreachEndTypes: function(type) {
                return type === "endforeach";
            },
            /**
     * Manages an endforeach block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endforeach: function(index, blocks, out) {
                // only called in case of error, i.e not digested by __foreach
                var block = blocks[index];
                this._logError("{/foreach} statement does not match any {foreach} block", block);
                return index;
            },
            /**
     * Manages an element block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __element: function(index, blocks, out) {
                var block = blocks[index];
                if (isVoidElement(block.name)) {
                    block.closed = true;
                }
                return this._elementOrComponent("element", index, blocks, out);
            },
            /**
     * Manages a component block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __component: function(index, blocks, out) {
                return this._elementOrComponent("component", index, blocks, out);
            },
            /**
     * Manages a component attribute block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __cptattribute: function(index, blocks, out) {
                return this._elementOrComponent("cptattribute", index, blocks, out);
            },
            /**
     * Processing function for elements, components and component attributes
     * @arg blockType {String} "element", "component" or "cptattribute".
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            _elementOrComponent: function(blockType, index, blocks, out) {
                var node = new Node(blockType), block = blocks[index];
                node.name = block.name;
                node.closed = block.closed;
                if (block.ref) {
                    // only for components
                    node.ref = block.ref;
                }
                // Handle attributes
                var attributes = block.attributes, attribute, outAttribute;
                node.attributes = [];
                for (var i = 0; i < attributes.length; i++) {
                    attribute = attributes[i];
                    var length = attribute.value.length;
                    if (length === 0) {
                        // this case arises when the attibute is empty - so let's create an empty text node
                        if (attribute.value === "") {
                            // attribute has no value - e.g. autocomplete in an input element
                            outAttribute = {
                                name: attribute.name,
                                type: "name",
                                line: attribute.line,
                                column: attribute.column
                            };
                            node.attributes.push(outAttribute);
                            continue;
                        } else {
                            attribute.value.push({
                                type: "text",
                                value: ""
                            });
                        }
                        length = 1;
                    }
                    if (length === 1) {
                        // literal or expression
                        var type = attribute.value[0].type;
                        if (type === "text" || type === "expression") {
                            if (type === "expression") {
                                var value = attribute.value[0], category = value.category;
                                if (category === "jsexpression") {
                                    // pre-process expression
                                    var expr = new HExpression(value, this);
                                    // inject the processed expression in the block list
                                    attribute.value[0] = expr.getSyntaxTree();
                                } else if (category === "invalidexpression") {
                                    this._logError("Invalid expression", value);
                                } else if (attribute.name.match(/^on/i) && category !== "functionref") {
                                    this._logError("Event handler attribute only support function expressions", value);
                                }
                            }
                            outAttribute = attribute.value[0];
                            outAttribute.name = attribute.name;
                        } else {
                            this._logError("Invalid attribute type: " + type, attribute);
                            continue;
                        }
                    } else {
                        // length > 1 so attribute is a text block
                        // if attribute is an event handler, raise an error
                        if (attribute.name.match(/^on/i)) {
                            this._logError("Event handler attributes don't support text and expression mix", attribute);
                        }
                        // raise errors if we have invalid attributes
                        for (var j = 0; j < length; j++) {
                            var value = attribute.value[j];
                            if (value.type === "expression") {
                                if (value.category === "jsexpression") {
                                    // pre-process expression
                                    var expr = new HExpression(value, this);
                                    // inject the processed expression in the block list
                                    attribute.value[j] = expr.getSyntaxTree();
                                } else if (value.category === "invalidexpression") {
                                    this._logError("Invalid expression", value);
                                }
                            }
                        }
                        outAttribute = {
                            name: attribute.name,
                            type: "textblock",
                            content: attribute.value
                        };
                    }
                    node.attributes.push(outAttribute);
                }
                //fills node.content with the next blocks, until an matching end element is found, if any
                node.content = [];
                out.push(node);
                if (!block.closed) {
                    var endFound = false, blockName = block.name;
                    while (!endFound) {
                        index = this._advance(blocks, index + 1, node.content, function(type, name) {
                            return type === "end" + blockType;
                        });
                        if (index < 0 || !blocks[index]) {
                            // we didn't find any endelement or endcomponent
                            this._logError("Missing end " + blockType + " </" + blockName + ">", block);
                            endFound = true;
                        } else {
                            // check if the end name is correct
                            var endBlock = blocks[index];
                            if (endBlock.type === "endelement" || endBlock.type === "endcptattribute") {
                                if (endBlock.name !== blockName) {
                                    this._logError("Missing end " + blockType + " </" + blockName + ">", block);
                                    index -= 1;
                                }
                            } else {
                                // endcomponent
                                var beginPath = this._getComponentPathAsString(block.ref), endPath = this._getComponentPathAsString(endBlock.ref);
                                if (beginPath !== endPath) {
                                    this._logError("Missing end component </#" + beginPath + ">", block);
                                    index -= 1;
                                }
                            }
                            endFound = true;
                        }
                    }
                }
                return index;
            },
            /**
     * Transform a component path into a string - useful for error checking
     * If path is invalid null is returned
     * @param {Object} ref the ref structure returned by the PEG parser for components and endcomponents
     * @retrun {String} the path as a string
     */
            _getComponentPathAsString: function(ref) {
                if (ref.category !== "objectref" || !ref.path || !ref.path.length || !ref.path.join) {
                    return null;
                }
                return ref.path.join(".");
            },
            /**
     * Catches invalid element errors.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __invalidelement: function(index, blocks, out) {
                // only called in case of error
                var block = blocks[index];
                var msg = "Invalid HTML element syntax";
                if (block.code && block.code.match(/^<\/?\@/gi)) {
                    msg = "Invalid component attribute syntax";
                }
                this._logError(msg, block);
                return index;
            },
            /**
     * Ignores comment blocks.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __comment: function(index, blocks, out) {
                return index;
            },
            /**
     * Captures isolated end elements to raise an error.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endelement: function(index, blocks, out) {
                // only called in case of error, i.e not digested by _elementOrComponent
                var block = blocks[index], name = block.name;
                if (isVoidElement(name)) {
                    this._logError("The end element </" + name + "> was rejected as <" + name + "> is a void HTML element and can't have a closing element", block);
                } else {
                    this._logError("End element </" + name + "> does not match any <" + name + "> element", block);
                }
                return index;
            },
            /**
     * Captures isolated end components to raise an error.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endcomponent: function(index, blocks, out) {
                // only called in case of error, i.e not digested by _elementOrComponent
                var block = blocks[index], path = this._getComponentPathAsString(block.ref);
                this._logError("End component </#" + path + "> does not match any <#" + path + "> component", block);
                return index;
            },
            /**
     * Captures isolated end component attributes to raise an error.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endcptattribute: function(index, blocks, out) {
                // only called in case of error, i.e not digested by _elementOrComponent
                var block = blocks[index], name = block.name;
                this._logError("End component attribute </@" + name + "> does not match any <@" + name + "> component attribute", block);
                return index;
            }
        });
        exports.SyntaxTree = SyntaxTree;
    });
    define("hsp/compiler/treebuilder/index.js", [ "./syntaxTree" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var SyntaxTree = require("./syntaxTree").SyntaxTree;
        /**
 * Builds the syntax tree from the block list generated by the parser.
 * @param {Object} blockList the blockList
 * @return {Object} a JSON structure with the following properties:
 *      syntaxTree: {Object} the syntax tree
 *      errors: {Array} the error list
 */
        exports.build = function(blockList) {
            var result = {};
            try {
                var syntaxTree = new SyntaxTree();
                syntaxTree.generateTree(blockList);
                result = {
                    syntaxTree: syntaxTree.tree.content,
                    errors: syntaxTree.errors
                };
            } catch (ex) {
                result = {
                    syntaxTree: null,
                    errors: [ {
                        description: ex.toString(),
                        line: ex.line,
                        column: ex.column
                    } ]
                };
            }
            return result;
        };
    });
    define("hsp/compiler/jsgenerator/treeWalker.js", [ "../../klass" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var klass = require("../../klass");
        var TreeWalker = klass({
            /**
     * Start traversing a parse tree. This method takes the intermediate representation created by the parser and
     * executes, for each of the nodes, a function defined on the processor object.
     * @param {SyntaxTree} tree the syntax tree.
     * @param {Object} processor a set of function to process the tree elements.
     * @return {[type]} [description]
     */
            walk: function(tree, processor) {
                var out = [];
                if (tree) {
                    for (var i = 0; i < tree.length; i += 1) {
                        var type = tree[i].type;
                        if (processor[type]) {
                            out.push(processor[type](tree[i], this));
                        }
                    }
                }
                return out;
            },
            /**
     * Execute a callback on each element of an array. The callback receives the value of the array. This method returns
     * an array with the return value of the callbacks if not null.
     * @param {Array} array the input array.
     * @param {Function} callback the callback.
     * @return {Array} an array made with the result of each callback.
     */
            each: function(array, callback) {
                var result = [];
                for (var i = 0; i < array.length; i += 1) {
                    var value = callback(array[i]);
                    if (value !== null) {
                        result.push(value);
                    }
                }
                return result;
            }
        });
        exports.TreeWalker = TreeWalker;
    });
    define("hsp/compiler/jsgenerator/templateWalker.js", [ "../../klass", "./treeWalker" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var klass = require("../../klass");
        var TreeWalker = require("./treeWalker").TreeWalker;
        /**
 * Walker object used to generate the template script and store some contextual information such as errors or scope..
 */
        var TemplateWalker = klass({
            $extends: TreeWalker,
            /**
     * Constructor.
     * @param {String} fileName the name of the file being compiled.
     * @param {String} dirPath the directory path.
     */
            $constructor: function(fileName, dirPath) {
                this.fileName = fileName;
                this.dirPath = dirPath;
                this.templates = {};
                // used by processors to store intermediate values in order to ease testing
                this.globals = {};
                // global validation code for each template - used for unit testing
                this.errors = [];
                this.resetGlobalRefs();
                this.resetScope();
            },
            /**
     * Adds an error to the current error list.
     * @param {String} description the error description
     * @param {Object} errdesc additional object (block, node, ...) which can contain additional info about the error (line/column number, code).
     */
            logError: function(description, errdesc) {
                var desc = {
                    description: description
                };
                if (errdesc) {
                    if (errdesc.line) {
                        desc.line = errdesc.line;
                        desc.column = errdesc.column;
                    }
                    if (errdesc.code) {
                        desc.code = errdesc.code;
                    }
                }
                this.errors.push(desc);
            },
            /**
     * Resets the list of global variables that have been found since the last reset
     */
            resetGlobalRefs: function() {
                this._globals = [];
                this._globalKeys = {};
            },
            /**
     * Adds a global reference (e.g. "foo") to the current _globals list.
     * @param {String} ref the reference key.
     */
            addGlobalRef: function(ref) {
                if (!this._globalKeys[ref]) {
                    this._globals.push(ref);
                    this._globalKeys[ref] = true;
                }
            },
            /**
     * Resets the scope variables that are used to determine if a variable name is in the current scope.
     */
            resetScope: function() {
                this._scopes = [ {} ];
                this._scope = this._scopes[0];
            },
            /**
     * Adds a scope variable.
     * @param {String} varName the variable name.
     */
            addScopeVariable: function(varName) {
                this._scope[varName] = true;
            },
            /**
     * Removes a scope variable.
     * @param {String} varName the variable name.
     */
            rmScopeVariable: function(varName) {
                this._scope[varName] = null;
            },
            /**
     * Checks if a scope variable exists.
     * @param {String} varName the variable name.
     * @return {Boolean} true if it exists.
     */
            isInScope: function(varName) {
                if (varName === "scope") {
                    return true;
                }
                return this._scope[varName] ? true : false;
            },
            /**
     * Pushes a sub scope.
     * @param {Array} varArray an array of variable.
     */
            pushSubScope: function(varArray) {
                var newScope = Object.create(this._scope);
                for (var i = 0; i < varArray.length; i++) {
                    newScope[varArray[i]] = true;
                }
                this._scopes.push(newScope);
                this._scope = this._scopes[this._scopes.length - 1];
            },
            /**
     * Pops a sub scope.
     */
            popSubScope: function() {
                this._scopes.pop();
                this._scope = this._scopes[this._scopes.length - 1];
            }
        });
        exports.TemplateWalker = TemplateWalker;
    });
    define("hsp/compiler/jsgenerator/processors.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /**
 * Escapes new lines characters in a string.
 * @param {String} text the input string.
 * @return {String} the excaped strin.
 */
        function escapeNewLines(text) {
            return text.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\n/g, "\\n");
        }
        /**
 * Text outside a template, just return what we've got.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["plaintext"] = function(node, walker) {
            return node.value;
        };
        /**
 * Template definition, this is the root of the tree, return a self calling function that recursively applies
 * - walker.walk on its content array
 * - walker.each on its arguments definition, used for simple serialization
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["template"] = function(node, walker) {
            var templateName = node.name;
            var CRLF = "\r\n";
            //Adds template arguments to the scope
            if (node.args) {
                for (var i = 0; i < node.args.length; i++) {
                    walker.addScopeVariable(node.args[i]);
                }
            } else if (node.controller) {
                walker.addScopeVariable(node.controller.ref);
            }
            //Generates the code of the template's content
            var templateCode = [ "[", walker.walk(node.content, module.exports).join(","), "]" ].join("");
            var globals = walker._globals;
            //Generates globals validation statement - e.g. var _c;try {_c=c} catch(e) {};
            var globalsStatement = [], globalsLength = globals.length;
            if (globalsLength) {
                globalsStatement = [ "  var _" + globals.join(",_") + ";" ];
                for (var i = 0; i < globalsLength; i++) {
                    globalsStatement.push("try {_" + globals[i] + "=" + globals[i] + "} catch(e) {};");
                }
                globalsStatement.push(CRLF);
            }
            var globalsStatementString = globalsStatement.join("");
            //Resets template scope and global list
            walker.resetScope();
            walker.resetGlobalRefs();
            walker.templates[templateName] = templateCode;
            var exportString = "";
            if (node.export === true) {
                exportString = " =exports." + templateName;
            }
            if (node.controller) {
                var path = node.controller.path;
                return [ "var ", templateName, exportString, ' = require("hsp/rt").template({ctl:[', path[0], ",", walker.each(path, argAsString), '],ref:"', node.controller.ref, '"}, function(n){', CRLF, globalsStatementString, "  return ", templateCode, ";", CRLF, "});", CRLF ].join("");
            } else {
                return [ "var ", templateName, exportString, ' = require("hsp/rt").template([', walker.each(node.args, argAsString), "], function(n){", CRLF, globalsStatementString, "  return ", templateCode, ";", CRLF, "});", CRLF ].join("");
            }
        };
        /**
 * Generates a text node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["text"] = function(node, walker) {
            if (node.value === undefined) {
                console.dir(node);
                return 'n.$text(0,[""])';
            }
            return [ 'n.$text(0,["', escapeNewLines(node.value.replace(/"/g, '\\"')), '"])' ].join("");
        };
        /**
 * For a given value double it's definition returning "value",value.
 * This method should only be called on object literals (strings).
 * @param {String} value the initial value.
 * @return {String} the doubled value.
 */
        function argAsString(value) {
            // No need to toString because it's already a string
            return '"' + value + '"';
        }
        /**
 * Generate a textblock node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["textblock"] = function(node, walker) {
            // we should generate sth like
            // n.$text({e1:[1,"person","firstName"],e2:[1,"person","lastName"]},["Hello ",1," ",2,"!"])
            var textBlock = formatTextBlock(node, 1, walker);
            return [ "n.$text(", textBlock.exprArg, ",", textBlock.blockArgs, ")" ].join("");
        };
        /**
 * Generates a log expression.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["log"] = function(node, walker) {
            var expr, index = 1, code = [], indexes = [];
            for (var i = 0; i < node.exprs.length; i++) {
                expr = formatExpression(node.exprs[i], index, walker);
                index = expr.nextIndex;
                indexes.push(expr.exprIdx);
                code.push(expr.code);
            }
            return [ "n.log({", code.join(","), "},[", indexes.join(","), "],'", walker.fileName, "','", walker.dirPath, "',", node.line, ",", node.column, ")" ].join("");
        };
        /**
 * Generates a let expression.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["let"] = function(node, walker) {
            var expr, index = 1, code = [], assignment = [], varName;
            for (var i = 0; i < node.assignments.length; i++) {
                expr = formatExpression(node.assignments[i].value, index, walker);
                index = expr.nextIndex;
                varName = node.assignments[i].identifier;
                walker.addScopeVariable(varName);
                assignment.push("'" + varName + "'");
                assignment.push(expr.exprIdx);
                code.push(expr.code);
            }
            return [ "n.let({", code.join(","), "},[", assignment.join(","), "])" ].join("");
        };
        /**
 * Generates an if node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["if"] = function(node, walker) {
            // we should generate sth like
            // n.$if({e1:[1,"person","firstName"]}, 1, [n.$text({e1:[1,"person","firstName"]},["Hello ",1])], [..])
            var expr = formatExpression(node.condition, 1, walker);
            var content1 = ",[]", content2 = "";
            if (node.content1) {
                content1 = ",[" + walker.walk(node.content1, module.exports).join(",") + "]";
            }
            if (node.content2) {
                content2 = ",[" + walker.walk(node.content2, module.exports).join(",") + "]";
            }
            if (expr.code !== "") {
                expr.code = "{" + expr.code + "}";
            }
            return [ "n.$if(", expr.code, ",", expr.exprIdx, content1, content2, ")" ].join("");
        };
        /**
 * Generates a foreach node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["foreach"] = function(node, walker) {
            // we should generate sth like
            // n.$foreach( {e1: [1, 0, "things"]}, "thing", "thing_key", 1, [...])
            var expr = formatExpression(node.collection, 1, walker);
            var content = "[]";
            if (node.content) {
                // add all contextual variables
                walker.pushSubScope([ node.item, node.key, node.item + "_isfirst", node.item + "_islast" ]);
                content = "[" + walker.walk(node.content, module.exports).join(",") + "]";
                walker.popSubScope();
            }
            if (expr.code !== "") {
                expr.code = "{" + expr.code + "}";
            }
            var forType = 0;
            // to support types than 'in'
            return [ "n.$foreach(", expr.code, ',"', node.key, '","', node.item, '",', forType, ",", expr.exprIdx, ",", content, ")" ].join("");
        };
        /*
 * Manages insertion expressions.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["insert"] = function(node, walker) {
            node.category = "functionref";
            var expr = formatExpression(node, 1, walker);
            var exprcode = expr.code.length === 0 ? "0" : "{" + expr.code + "}";
            return [ "n.$insert(", exprcode, ",", expr.exprIdx, ")" ].join("");
        };
        /*
 * Manages element and component nodes.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        function elementOrComponent(node, walker) {
            // we should generate sth like
            // n.elt("div", {e1:[0,0,"arg"]}, {"title":["",1]}, 0, [...])
            var attributeContent = "0", eventContent = "0", exprCode = "0", attributes = node.attributes, length = attributes.length;
            if (length > 0) {
                var list, attributeName, attributesList = [], eventList = [], exprList = [], attribute, type, exprIndex = 1;
                for (var i = 0; length > i; i++) {
                    attribute = attributes[i];
                    list = attributesList;
                    attributeName = attribute.name;
                    if (attribute.name.match(/^on/i)) {
                        // this is an event handler
                        list = eventList;
                        attributeName = attribute.name.slice(2);
                    }
                    type = attribute.type;
                    if (type === "text") {
                        list.push('"' + attributeName + '":"' + attribute.value + '"');
                    } else if (type === "expression") {
                        var expr = formatExpression(attribute, exprIndex, walker);
                        exprIndex = expr.nextIndex;
                        exprList.push(expr.code);
                        if (list === eventList) {
                            list.push('"' + attributeName + '":' + expr.exprIdx);
                        } else {
                            list.push('"' + attributeName + '":["",' + expr.exprIdx + "]");
                        }
                    } else if (type === "textblock") {
                        var textBlock = formatTextBlock(attribute, exprIndex, walker);
                        exprIndex = textBlock.nextIndex;
                        if (textBlock.exprArg !== "0") {
                            exprList.push(textBlock.exprArg.slice(1, -1));
                        }
                        list.push('"' + attributeName + '":' + textBlock.blockArgs);
                    } else if (type === "name") {
                        list.push('"' + attributeName + '":null');
                    } else {
                        walker.logError("Invalid attribute type: " + type);
                    }
                }
                if (attributesList.length) {
                    attributeContent = "{" + attributesList.join(",") + "}";
                }
                if (eventList.length) {
                    eventContent = "{" + eventList.join(",") + "}";
                }
                exprCode = exprList.length === 0 ? "0" : "{" + exprList.join(",") + "}";
            }
            var content = "";
            if (node.content && node.content.length) {
                content = ",[" + walker.walk(node.content, module.exports).join(",") + "]";
            }
            return [ exprCode, ",", attributeContent, ",", eventContent, content ].join("");
        }
        /**
 * Generates an element node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["element"] = function(node, walker) {
            var generatedNode = elementOrComponent(node, walker);
            var subScope = node.needSubScope === true ? ",1" : "";
            return [ 'n.elt("', node.name, '",', generatedNode, subScope, ")" ].join("");
        };
        /**
 * Generates a component node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["component"] = function(node, walker) {
            var generatedNode = elementOrComponent(node, walker);
            var path = node.ref.path;
            walker.addGlobalRef(path[0]);
            return [ "n.cpt([_", path[0], ',"', path.join('","'), '"],', generatedNode, ")" ].join("");
        };
        /**
 * Generates a cptattribute node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["cptattribute"] = function(node, walker) {
            var generatedNode = elementOrComponent(node, walker);
            return [ 'n.catt("', node.name, '",', generatedNode, ")" ].join("");
        };
        /**
 * Formats an expression according to its category.
 * @param {Object} expression the expression to format.
 * @param {Integer} firstIndex index of the expression.
 * @param {TemplateWalker} walker the template walker instance.
 * @return {Object} the expression string and the next expression index that can be used
 */
        function formatExpression(expression, firstIndex, walker) {
            var category = expression.category, code = "", nextIndex = firstIndex, bound = expression.bound === false ? 0 : 1;
            var exprIndex = firstIndex;
            if (category === "objectref" || category === "functionref") {
                var path = expression.path, argExprs = null, argExprIndex = null, args = expression.args;
                if (path.length === 0) {
                    walker.logError("Expression path cannot be empty");
                } else {
                    var root = path[0], isRootInScope = walker.isInScope(root);
                    /* Possible expression types are:
             * 0: unbound data ref - e.g. {e1:[0,1,"item_key"]}
             * 1: bound data ref - e.g. {e1:[1,2,"person","name"]}
             * 2: literal data ref - e.g. {e1:[2,2,person,"name"]}
             * 3: function call - e.g. {e1:[3,2,"ctl","deleteItem",1,2,1,0]}
             * 4: function call literal- e.g. {e1:[4,1,myfunc,1,2,1,0]}
             * 5: literal value - e.g. {e1:[5,"some value"]}
             * 6: function expression - e.g. {e1:[6,function(a0,a1){return a0+a1;},2,3]}*/
                    var exprType = isRootInScope ? bound : 2;
                    if (root === "event") {
                        exprType = 0;
                    }
                    if (exprType === 2) {
                        // root is a global reference
                        walker.addGlobalRef(root);
                        root = "_" + root;
                        path[0] = "_" + path[0];
                    }
                    if (category === "functionref") {
                        exprType = isRootInScope ? 3 : 4;
                        argExprs = [];
                        argExprIndex = [];
                        var arg, argCategory, expr, index = exprIndex + 1;
                        for (var i = 0; i < args.length; i++) {
                            arg = args[i];
                            argCategory = arg.category;
                            if (argCategory === "string" || argCategory === "boolean" || argCategory === "number") {
                                continue;
                            }
                            expr = formatExpression(arg, index, walker);
                            argExprs.push(expr.code);
                            argExprIndex[i] = expr.exprIdx;
                            index = expr.nextIndex;
                        }
                        nextIndex = index;
                    } else {
                        nextIndex++;
                    }
                    var result, rootRef = path[0];
                    if (isRootInScope || root === "event") {
                        rootRef = '"' + rootRef + '"';
                    }
                    var pathLength = path.length;
                    var generatedPath = [], pathItem;
                    generatedPath.push(rootRef);
                    for (var i = 1; i < pathLength; i++) {
                        pathItem = path[i];
                        if (typeof pathItem === "string") {
                            generatedPath.push('"' + pathItem + '"');
                        } else {
                            generatedPath.push(pathItem);
                        }
                    }
                    result = [ "e", exprIndex, ":[", exprType, ",", pathLength, ",", generatedPath.join(",") ];
                    if (args && args.length > 0) {
                        var argCategory, arg;
                        for (var i = 0; i < args.length; i++) {
                            arg = args[i];
                            argCategory = arg.category;
                            if (argCategory === "string") {
                                result.push(',0,"' + escapeNewLines(arg.value.replace(/"/g, '\\"')) + '"');
                            } else if (argCategory === "boolean" || argCategory === "number") {
                                result.push(",0," + arg.value);
                            } else {
                                // this is not a literal
                                result.push(",1," + argExprIndex[i]);
                            }
                        }
                        if (argExprs && argExprs.length > 0) {
                            result.push("],");
                            result.push(argExprs.join(","));
                        } else {
                            result.push("]");
                        }
                    } else {
                        result.push("]");
                    }
                    code = result.join("");
                }
            } else if (category === "boolean" || category === "number") {
                code = [ "e", exprIndex, ":[5,", expression.value, "]" ].join("");
                nextIndex++;
            } else if (category === "string") {
                code = [ "e", exprIndex, ':[5,"', ("" + expression.value).replace(/"/g, '\\"'), '"]' ].join("");
                nextIndex++;
            } else if (category === "jsexpression") {
                var refs = expression.objectrefs, ref, expr, index = exprIndex + 1, exprs = [], exprIdxs = [];
                if (refs === undefined) {
                    console.warn("[formatExpression] The following expression has not been pre-processed - parser should be updated: ");
                    console.dir(expression);
                }
                var args = [], length = refs.length, argSeparator = length > 0 ? "," : "";
                for (var i = 0; length > i; i++) {
                    ref = refs[i];
                    args[i] = "a" + i;
                    expr = formatExpression(ref, index, walker);
                    exprs.push(expr.code);
                    exprIdxs[i] = expr.exprIdx;
                    index = expr.nextIndex;
                }
                var func = [ "function(", args.join(","), ") {return ", expression.code, ";}" ].join("");
                var code0 = [ "e", exprIndex, ":[6,", func, argSeparator, exprIdxs.join(","), "]" ].join("");
                exprs.splice(0, 0, code0);
                code = exprs.join(",");
                nextIndex = exprIdxs[exprIdxs.length - 1] + 1;
            } else {
                walker.logError("Unsupported expression: " + category, expression);
            }
            return {
                code: code,
                exprIdx: exprIndex,
                nextIndex: nextIndex
            };
        }
        /**
 * Format the textblock content for textblock and attribute nodes.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {Integer} nextExprIndex the index of the next expression.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        function formatTextBlock(node, nextExprIndex, walker) {
            var content = node.content, item, exprArray = [], args = [], index = 0;
            // idx is the index in the $text array
            // (=args)
            for (var i = 0; i < content.length; i++) {
                item = content[i];
                if (item.type === "text") {
                    if (index % 2 === 0) {
                        // even index: arg must be a string
                        args[index] = '"' + escapeNewLines(item.value.replace(/"/g, '\\"')) + '"';
                        index++;
                    } else {
                        // odd index: arg must be an expression - so add the text to the previous item
                        if (index > 0) {
                            args[index - 1] = args[index - 1].slice(0, -1) + escapeNewLines(item.value.replace(/"/g, '\\"')) + '"';
                        } else {
                            // we should never get there as index is odd !
                            walker.logError("Invalid textblock structure", node);
                        }
                    }
                } else if (item.type === "expression") {
                    if (index % 2 === 0) {
                        // even index: arg must be a string
                        args[index] = '""';
                        index++;
                    }
                    var expr = formatExpression(item, nextExprIndex, walker);
                    nextExprIndex = expr.nextIndex;
                    if (expr.code) {
                        exprArray.push(expr.code);
                        args[index] = expr.exprIdx;
                    } else {
                        args[index] = 0;
                    }
                    index++;
                }
            }
            var exprArg = "0";
            if (exprArray.length) {
                exprArg = "{" + exprArray.join(",") + "}";
            }
            var blockArgs = "[]";
            if (args.length) {
                blockArgs = "[" + args.join(",") + "]";
            }
            return {
                exprArg: exprArg,
                nextIndex: nextExprIndex,
                blockArgs: blockArgs
            };
        }
    });
    define("acorn/acorn.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        // Acorn is a tiny, fast JavaScript parser written in JavaScript.
        //
        // Acorn was written by Marijn Haverbeke and released under an MIT
        // license. The Unicode regexps (for identifiers and whitespace) were
        // taken from [Esprima](http://esprima.org) by Ariya Hidayat.
        //
        // Git repositories for Acorn are available at
        //
        //     http://marijnhaverbeke.nl/git/acorn
        //     https://github.com/marijnh/acorn.git
        //
        // Please use the [github bug tracker][ghbt] to report issues.
        //
        // [ghbt]: https://github.com/marijnh/acorn/issues
        //
        // This file defines the main parser interface. The library also comes
        // with a [error-tolerant parser][dammit] and an
        // [abstract syntax tree walker][walk], defined in other files.
        //
        // [dammit]: acorn_loose.js
        // [walk]: util/walk.js
        (function(exports) {
            "use strict";
            exports.version = "0.1.0";
            // The main exported interface (under `self.acorn` when in the
            // browser) is a `parse` function that takes a code string and
            // returns an abstract syntax tree as specified by [Mozilla parser
            // API][api], with the caveat that the SpiderMonkey-specific syntax
            // (`let`, `yield`, inline XML, etc) is not recognized.
            //
            // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
            var options, input, inputLen, sourceFile;
            exports.parse = function(inpt, opts) {
                input = String(inpt);
                inputLen = input.length;
                setOptions(opts);
                initTokenState();
                return parseTopLevel(options.program);
            };
            // A second optional argument can be given to further configure
            // the parser process. These options are recognized:
            var defaultOptions = exports.defaultOptions = {
                // `ecmaVersion` indicates the ECMAScript version to parse. Must
                // be either 3 or 5. This
                // influences support for strict mode, the set of reserved words, and
                // support for getters and setter.
                ecmaVersion: 5,
                // Turn on `strictSemicolons` to prevent the parser from doing
                // automatic semicolon insertion.
                strictSemicolons: false,
                // When `allowTrailingCommas` is false, the parser will not allow
                // trailing commas in array and object literals.
                allowTrailingCommas: true,
                // By default, reserved words are not enforced. Enable
                // `forbidReserved` to enforce them.
                forbidReserved: false,
                // When `locations` is on, `loc` properties holding objects with
                // `start` and `end` properties in `{line, column}` form (with
                // line being 1-based and column 0-based) will be attached to the
                // nodes.
                locations: false,
                // A function can be passed as `onComment` option, which will
                // cause Acorn to call that function with `(block, text, start,
                // end)` parameters whenever a comment is skipped. `block` is a
                // boolean indicating whether this is a block (`/* */`) comment,
                // `text` is the content of the comment, and `start` and `end` are
                // character offsets that denote the start and end of the comment.
                // When the `locations` option is on, two more parameters are
                // passed, the full `{line, column}` locations of the start and
                // end of the comments.
                onComment: null,
                // Nodes have their start and end characters offsets recorded in
                // `start` and `end` properties (directly on the node, rather than
                // the `loc` object, which holds line/column data. To also add a
                // [semi-standardized][range] `range` property holding a `[start,
                // end]` array with the same numbers, set the `ranges` option to
                // `true`.
                //
                // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
                ranges: false,
                // It is possible to parse multiple files into a single AST by
                // passing the tree produced by parsing the first file as
                // `program` option in subsequent parses. This will add the
                // toplevel forms of the parsed file to the `Program` (top) node
                // of an existing parse tree.
                program: null,
                // When `location` is on, you can pass this to record the source
                // file in every node's `loc` object.
                sourceFile: null
            };
            function setOptions(opts) {
                options = opts || {};
                for (var opt in defaultOptions) if (!options.hasOwnProperty(opt)) options[opt] = defaultOptions[opt];
                sourceFile = options.sourceFile || null;
            }
            // The `getLineInfo` function is mostly useful when the
            // `locations` option is off (for performance reasons) and you
            // want to find the line/column position for a given character
            // offset. `input` should be the code string that the offset refers
            // into.
            var getLineInfo = exports.getLineInfo = function(input, offset) {
                for (var line = 1, cur = 0; ;) {
                    lineBreak.lastIndex = cur;
                    var match = lineBreak.exec(input);
                    if (match && match.index < offset) {
                        ++line;
                        cur = match.index + match[0].length;
                    } else break;
                }
                return {
                    line: line,
                    column: offset - cur
                };
            };
            // Acorn is organized as a tokenizer and a recursive-descent parser.
            // The `tokenize` export provides an interface to the tokenizer.
            // Because the tokenizer is optimized for being efficiently used by
            // the Acorn parser itself, this interface is somewhat crude and not
            // very modular. Performing another parse or call to `tokenize` will
            // reset the internal state, and invalidate existing tokenizers.
            exports.tokenize = function(inpt, opts) {
                input = String(inpt);
                inputLen = input.length;
                setOptions(opts);
                initTokenState();
                var t = {};
                function getToken(forceRegexp) {
                    readToken(forceRegexp);
                    t.start = tokStart;
                    t.end = tokEnd;
                    t.startLoc = tokStartLoc;
                    t.endLoc = tokEndLoc;
                    t.type = tokType;
                    t.value = tokVal;
                    return t;
                }
                getToken.jumpTo = function(pos, reAllowed) {
                    tokPos = pos;
                    if (options.locations) {
                        tokCurLine = tokLineStart = lineBreak.lastIndex = 0;
                        var match;
                        while ((match = lineBreak.exec(input)) && match.index < pos) {
                            ++tokCurLine;
                            tokLineStart = match.index + match[0].length;
                        }
                    }
                    var ch = input.charAt(pos - 1);
                    tokRegexpAllowed = reAllowed;
                    skipSpace();
                };
                return getToken;
            };
            // State is kept in (closure-)global variables. We already saw the
            // `options`, `input`, and `inputLen` variables above.
            // The current position of the tokenizer in the input.
            var tokPos;
            // The start and end offsets of the current token.
            var tokStart, tokEnd;
            // When `options.locations` is true, these hold objects
            // containing the tokens start and end line/column pairs.
            var tokStartLoc, tokEndLoc;
            // The type and value of the current token. Token types are objects,
            // named by variables against which they can be compared, and
            // holding properties that describe them (indicating, for example,
            // the precedence of an infix operator, and the original name of a
            // keyword token). The kind of value that's held in `tokVal` depends
            // on the type of the token. For literals, it is the literal value,
            // for operators, the operator name, and so on.
            var tokType, tokVal;
            // Interal state for the tokenizer. To distinguish between division
            // operators and regular expressions, it remembers whether the last
            // token was one that is allowed to be followed by an expression.
            // (If it is, a slash is probably a regexp, if it isn't it's a
            // division operator. See the `parseStatement` function for a
            // caveat.)
            var tokRegexpAllowed;
            // When `options.locations` is true, these are used to keep
            // track of the current line, and know when a new line has been
            // entered.
            var tokCurLine, tokLineStart;
            // These store the position of the previous token, which is useful
            // when finishing a node and assigning its `end` position.
            var lastStart, lastEnd, lastEndLoc;
            // This is the parser's state. `inFunction` is used to reject
            // `return` statements outside of functions, `labels` to verify that
            // `break` and `continue` have somewhere to jump to, and `strict`
            // indicates whether strict mode is on.
            var inFunction, labels, strict;
            // This function is used to raise exceptions on parse errors. It
            // takes an offset integer (into the current `input`) to indicate
            // the location of the error, attaches the position to the end
            // of the error message, and then raises a `SyntaxError` with that
            // message.
            function raise(pos, message) {
                var loc = getLineInfo(input, pos);
                message += " (" + loc.line + ":" + loc.column + ")";
                var err = new SyntaxError(message);
                err.pos = pos;
                err.loc = loc;
                err.raisedAt = tokPos;
                throw err;
            }
            // ## Token types
            // The assignment of fine-grained, information-carrying type objects
            // allows the tokenizer to store the information it has about a
            // token in a way that is very cheap for the parser to look up.
            // All token type variables start with an underscore, to make them
            // easy to recognize.
            // These are the general types. The `type` property is only used to
            // make them recognizeable when debugging.
            var _num = {
                type: "num"
            }, _regexp = {
                type: "regexp"
            }, _string = {
                type: "string"
            };
            var _name = {
                type: "name"
            }, _eof = {
                type: "eof"
            };
            // Keyword tokens. The `keyword` property (also used in keyword-like
            // operators) indicates that the token originated from an
            // identifier-like word, which is used when parsing property names.
            //
            // The `beforeExpr` property is used to disambiguate between regular
            // expressions and divisions. It is set on all token types that can
            // be followed by an expression (thus, a slash after them would be a
            // regular expression).
            //
            // `isLoop` marks a keyword as starting a loop, which is important
            // to know when parsing a label, in order to allow or disallow
            // continue jumps to that label.
            var _break = {
                keyword: "break"
            }, _case = {
                keyword: "case",
                beforeExpr: true
            }, _catch = {
                keyword: "catch"
            };
            var _continue = {
                keyword: "continue"
            }, _debugger = {
                keyword: "debugger"
            }, _default = {
                keyword: "default"
            };
            var _do = {
                keyword: "do",
                isLoop: true
            }, _else = {
                keyword: "else",
                beforeExpr: true
            };
            var _finally = {
                keyword: "finally"
            }, _for = {
                keyword: "for",
                isLoop: true
            }, _function = {
                keyword: "function"
            };
            var _if = {
                keyword: "if"
            }, _return = {
                keyword: "return",
                beforeExpr: true
            }, _switch = {
                keyword: "switch"
            };
            var _throw = {
                keyword: "throw",
                beforeExpr: true
            }, _try = {
                keyword: "try"
            }, _var = {
                keyword: "var"
            };
            var _while = {
                keyword: "while",
                isLoop: true
            }, _with = {
                keyword: "with"
            }, _new = {
                keyword: "new",
                beforeExpr: true
            };
            var _this = {
                keyword: "this"
            };
            // The keywords that denote values.
            var _null = {
                keyword: "null",
                atomValue: null
            }, _true = {
                keyword: "true",
                atomValue: true
            };
            var _false = {
                keyword: "false",
                atomValue: false
            };
            // Some keywords are treated as regular operators. `in` sometimes
            // (when parsing `for`) needs to be tested against specifically, so
            // we assign a variable name to it for quick comparing.
            var _in = {
                keyword: "in",
                binop: 7,
                beforeExpr: true
            };
            // Map keyword names to token types.
            var keywordTypes = {
                "break": _break,
                "case": _case,
                "catch": _catch,
                "continue": _continue,
                "debugger": _debugger,
                "default": _default,
                "do": _do,
                "else": _else,
                "finally": _finally,
                "for": _for,
                "function": _function,
                "if": _if,
                "return": _return,
                "switch": _switch,
                "throw": _throw,
                "try": _try,
                "var": _var,
                "while": _while,
                "with": _with,
                "null": _null,
                "true": _true,
                "false": _false,
                "new": _new,
                "in": _in,
                "instanceof": {
                    keyword: "instanceof",
                    binop: 7,
                    beforeExpr: true
                },
                "this": _this,
                "typeof": {
                    keyword: "typeof",
                    prefix: true,
                    beforeExpr: true
                },
                "void": {
                    keyword: "void",
                    prefix: true,
                    beforeExpr: true
                },
                "delete": {
                    keyword: "delete",
                    prefix: true,
                    beforeExpr: true
                }
            };
            // Punctuation token types. Again, the `type` property is purely for debugging.
            var _bracketL = {
                type: "[",
                beforeExpr: true
            }, _bracketR = {
                type: "]"
            }, _braceL = {
                type: "{",
                beforeExpr: true
            };
            var _braceR = {
                type: "}"
            }, _parenL = {
                type: "(",
                beforeExpr: true
            }, _parenR = {
                type: ")"
            };
            var _comma = {
                type: ",",
                beforeExpr: true
            }, _semi = {
                type: ";",
                beforeExpr: true
            };
            var _colon = {
                type: ":",
                beforeExpr: true
            }, _dot = {
                type: "."
            }, _question = {
                type: "?",
                beforeExpr: true
            };
            // Operators. These carry several kinds of properties to help the
            // parser use them properly (the presence of these properties is
            // what categorizes them as operators).
            //
            // `binop`, when present, specifies that this operator is a binary
            // operator, and will refer to its precedence.
            //
            // `prefix` and `postfix` mark the operator as a prefix or postfix
            // unary operator. `isUpdate` specifies that the node produced by
            // the operator should be of type UpdateExpression rather than
            // simply UnaryExpression (`++` and `--`).
            //
            // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
            // binary operators with a very low precedence, that should result
            // in AssignmentExpression nodes.
            var _slash = {
                binop: 10,
                beforeExpr: true
            }, _eq = {
                isAssign: true,
                beforeExpr: true
            };
            var _assign = {
                isAssign: true,
                beforeExpr: true
            }, _plusmin = {
                binop: 9,
                prefix: true,
                beforeExpr: true
            };
            var _incdec = {
                postfix: true,
                prefix: true,
                isUpdate: true
            }, _prefix = {
                prefix: true,
                beforeExpr: true
            };
            var _bin1 = {
                binop: 1,
                beforeExpr: true
            }, _bin2 = {
                binop: 2,
                beforeExpr: true
            };
            var _bin3 = {
                binop: 3,
                beforeExpr: true
            }, _bin4 = {
                binop: 4,
                beforeExpr: true
            };
            var _bin5 = {
                binop: 5,
                beforeExpr: true
            }, _bin6 = {
                binop: 6,
                beforeExpr: true
            };
            var _bin7 = {
                binop: 7,
                beforeExpr: true
            }, _bin8 = {
                binop: 8,
                beforeExpr: true
            };
            var _bin10 = {
                binop: 10,
                beforeExpr: true
            };
            // Provide access to the token types for external users of the
            // tokenizer.
            exports.tokTypes = {
                bracketL: _bracketL,
                bracketR: _bracketR,
                braceL: _braceL,
                braceR: _braceR,
                parenL: _parenL,
                parenR: _parenR,
                comma: _comma,
                semi: _semi,
                colon: _colon,
                dot: _dot,
                question: _question,
                slash: _slash,
                eq: _eq,
                name: _name,
                eof: _eof,
                num: _num,
                regexp: _regexp,
                string: _string
            };
            for (var kw in keywordTypes) exports.tokTypes[kw] = keywordTypes[kw];
            // This is a trick taken from Esprima. It turns out that, on
            // non-Chrome browsers, to check whether a string is in a set, a
            // predicate containing a big ugly `switch` statement is faster than
            // a regular expression, and on Chrome the two are about on par.
            // This function uses `eval` (non-lexical) to produce such a
            // predicate from a space-separated string of words.
            //
            // It starts by sorting the words by length.
            function makePredicate(words) {
                words = words.split(" ");
                var f = "", cats = [];
                out: for (var i = 0; i < words.length; ++i) {
                    for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
                        cats[j].push(words[i]);
                        continue out;
                    }
                    cats.push([ words[i] ]);
                }
                function compareTo(arr) {
                    if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
                    f += "switch(str){";
                    for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
                    f += "return true}return false;";
                }
                // When there are more than three length categories, an outer
                // switch first dispatches on the lengths, to save on comparisons.
                if (cats.length > 3) {
                    cats.sort(function(a, b) {
                        return b.length - a.length;
                    });
                    f += "switch(str.length){";
                    for (var i = 0; i < cats.length; ++i) {
                        var cat = cats[i];
                        f += "case " + cat[0].length + ":";
                        compareTo(cat);
                    }
                    f += "}";
                } else {
                    compareTo(words);
                }
                return new Function("str", f);
            }
            // The ECMAScript 3 reserved word list.
            var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
            // ECMAScript 5 reserved words.
            var isReservedWord5 = makePredicate("class enum extends super const export import");
            // The additional reserved words in strict mode.
            var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
            // The forbidden variable names in strict mode.
            var isStrictBadIdWord = makePredicate("eval arguments");
            // And the keywords.
            var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");
            // ## Character categories
            // Big ugly regular expressions that match characters in the
            // whitespace, identifier, and identifier-start categories. These
            // are only applied when a character is found to actually have a
            // code point above 128.
            var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/;
            var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
            var nonASCIIidentifierChars = "\u0371-\u0374\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
            var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
            var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
            // Whether a single character denotes a newline.
            var newline = /[\n\r\u2028\u2029]/;
            // Matches a whole line break (where CRLF is considered a single
            // line break). Used to count lines.
            var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;
            // Test whether a given character code starts an identifier.
            function isIdentifierStart(code) {
                if (code < 65) return code === 36;
                if (code < 91) return true;
                if (code < 97) return code === 95;
                if (code < 123) return true;
                return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
            }
            // Test whether a given character is part of an identifier.
            function isIdentifierChar(code) {
                if (code < 48) return code === 36;
                if (code < 58) return true;
                if (code < 65) return false;
                if (code < 91) return true;
                if (code < 97) return code === 95;
                if (code < 123) return true;
                return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
            }
            // ## Tokenizer
            // These are used when `options.locations` is on, for the
            // `tokStartLoc` and `tokEndLoc` properties.
            function line_loc_t() {
                this.line = tokCurLine;
                this.column = tokPos - tokLineStart;
            }
            // Reset the token state. Used at the start of a parse.
            function initTokenState() {
                tokCurLine = 1;
                tokPos = tokLineStart = 0;
                tokRegexpAllowed = true;
                skipSpace();
            }
            // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
            // `tokRegexpAllowed`, and skips the space after the token, so that
            // the next one's `tokStart` will point at the right position.
            function finishToken(type, val) {
                tokEnd = tokPos;
                if (options.locations) tokEndLoc = new line_loc_t();
                tokType = type;
                skipSpace();
                tokVal = val;
                tokRegexpAllowed = type.beforeExpr;
            }
            function skipBlockComment() {
                var startLoc = options.onComment && options.locations && new line_loc_t();
                var start = tokPos, end = input.indexOf("*/", tokPos += 2);
                if (end === -1) raise(tokPos - 2, "Unterminated comment");
                tokPos = end + 2;
                if (options.locations) {
                    lineBreak.lastIndex = start;
                    var match;
                    while ((match = lineBreak.exec(input)) && match.index < tokPos) {
                        ++tokCurLine;
                        tokLineStart = match.index + match[0].length;
                    }
                }
                if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());
            }
            function skipLineComment() {
                var start = tokPos;
                var startLoc = options.onComment && options.locations && new line_loc_t();
                var ch = input.charCodeAt(tokPos += 2);
                while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8329) {
                    ++tokPos;
                    ch = input.charCodeAt(tokPos);
                }
                if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());
            }
            // Called at the start of the parse and after every token. Skips
            // whitespace and comments, and.
            function skipSpace() {
                while (tokPos < inputLen) {
                    var ch = input.charCodeAt(tokPos);
                    if (ch === 32) {
                        // ' '
                        ++tokPos;
                    } else if (ch === 13) {
                        ++tokPos;
                        var next = input.charCodeAt(tokPos);
                        if (next === 10) {
                            ++tokPos;
                        }
                        if (options.locations) {
                            ++tokCurLine;
                            tokLineStart = tokPos;
                        }
                    } else if (ch === 10) {
                        ++tokPos;
                        ++tokCurLine;
                        tokLineStart = tokPos;
                    } else if (ch < 14 && ch > 8) {
                        ++tokPos;
                    } else if (ch === 47) {
                        // '/'
                        var next = input.charCodeAt(tokPos + 1);
                        if (next === 42) {
                            // '*'
                            skipBlockComment();
                        } else if (next === 47) {
                            // '/'
                            skipLineComment();
                        } else break;
                    } else if (ch < 14 && ch > 8 || ch === 32 || ch === 160) {
                        // ' ', '\xa0'
                        ++tokPos;
                    } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                        ++tokPos;
                    } else {
                        break;
                    }
                }
            }
            // ### Token reading
            // This is the function that is called to fetch the next token. It
            // is somewhat obscure, because it works in character codes rather
            // than characters, and because operator parsing has been inlined
            // into it.
            //
            // All in the name of speed.
            //
            // The `forceRegexp` parameter is used in the one case where the
            // `tokRegexpAllowed` trick does not work. See `parseStatement`.
            function readToken_dot() {
                var next = input.charCodeAt(tokPos + 1);
                if (next >= 48 && next <= 57) return readNumber(true);
                ++tokPos;
                return finishToken(_dot);
            }
            function readToken_slash() {
                // '/'
                var next = input.charCodeAt(tokPos + 1);
                if (tokRegexpAllowed) {
                    ++tokPos;
                    return readRegexp();
                }
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(_slash, 1);
            }
            function readToken_mult_modulo() {
                // '%*'
                var next = input.charCodeAt(tokPos + 1);
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(_bin10, 1);
            }
            function readToken_pipe_amp(code) {
                // '|&'
                var next = input.charCodeAt(tokPos + 1);
                if (next === code) return finishOp(code === 124 ? _bin1 : _bin2, 2);
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(code === 124 ? _bin3 : _bin5, 1);
            }
            function readToken_caret() {
                // '^'
                var next = input.charCodeAt(tokPos + 1);
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(_bin4, 1);
            }
            function readToken_plus_min(code) {
                // '+-'
                var next = input.charCodeAt(tokPos + 1);
                if (next === code) return finishOp(_incdec, 2);
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(_plusmin, 1);
            }
            function readToken_lt_gt(code) {
                // '<>'
                var next = input.charCodeAt(tokPos + 1);
                var size = 1;
                if (next === code) {
                    size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
                    if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
                    return finishOp(_bin8, size);
                }
                if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
                return finishOp(_bin7, size);
            }
            function readToken_eq_excl(code) {
                // '=!'
                var next = input.charCodeAt(tokPos + 1);
                if (next === 61) return finishOp(_bin6, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
                return finishOp(code === 61 ? _eq : _prefix, 1);
            }
            function getTokenFromCode(code) {
                switch (code) {
                  // The interpretation of a dot depends on whether it is followed
                    // by a digit.
                    case 46:
                    // '.'
                    return readToken_dot();

                  // Punctuation tokens.
                    case 40:
                    ++tokPos;
                    return finishToken(_parenL);

                  case 41:
                    ++tokPos;
                    return finishToken(_parenR);

                  case 59:
                    ++tokPos;
                    return finishToken(_semi);

                  case 44:
                    ++tokPos;
                    return finishToken(_comma);

                  case 91:
                    ++tokPos;
                    return finishToken(_bracketL);

                  case 93:
                    ++tokPos;
                    return finishToken(_bracketR);

                  case 123:
                    ++tokPos;
                    return finishToken(_braceL);

                  case 125:
                    ++tokPos;
                    return finishToken(_braceR);

                  case 58:
                    ++tokPos;
                    return finishToken(_colon);

                  case 63:
                    ++tokPos;
                    return finishToken(_question);

                  // '0x' is a hexadecimal number.
                    case 48:
                    // '0'
                    var next = input.charCodeAt(tokPos + 1);
                    if (next === 120 || next === 88) return readHexNumber();

                  // Anything else beginning with a digit is an integer, octal
                    // number, or float.
                    case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    // 1-9
                    return readNumber(false);

                  // Quotes produce strings.
                    case 34:
                  case 39:
                    // '"', "'"
                    return readString(code);

                  // Operators are parsed inline in tiny state machines. '=' (61) is
                    // often referred to. `finishOp` simply skips the amount of
                    // characters it is given as second argument, and returns a token
                    // of the type given by its first argument.
                    case 47:
                    // '/'
                    return readToken_slash(code);

                  case 37:
                  case 42:
                    // '%*'
                    return readToken_mult_modulo();

                  case 124:
                  case 38:
                    // '|&'
                    return readToken_pipe_amp(code);

                  case 94:
                    // '^'
                    return readToken_caret();

                  case 43:
                  case 45:
                    // '+-'
                    return readToken_plus_min(code);

                  case 60:
                  case 62:
                    // '<>'
                    return readToken_lt_gt(code);

                  case 61:
                  case 33:
                    // '=!'
                    return readToken_eq_excl(code);

                  case 126:
                    // '~'
                    return finishOp(_prefix, 1);
                }
                return false;
            }
            function readToken(forceRegexp) {
                tokStart = tokPos;
                if (options.locations) tokStartLoc = new line_loc_t();
                if (forceRegexp) return readRegexp();
                if (tokPos >= inputLen) return finishToken(_eof);
                var code = input.charCodeAt(tokPos);
                // Identifier or keyword. '\uXXXX' sequences are allowed in
                // identifiers, so '\' also dispatches to that.
                if (isIdentifierStart(code) || code === 92) return readWord();
                var tok = getTokenFromCode(code);
                if (tok === false) {
                    // If we are here, we either found a non-ASCII identifier
                    // character, or something that's entirely disallowed.
                    var ch = String.fromCharCode(code);
                    if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
                    raise(tokPos, "Unexpected character '" + ch + "'");
                }
                return tok;
            }
            function finishOp(type, size) {
                var str = input.slice(tokPos, tokPos + size);
                tokPos += size;
                finishToken(type, str);
            }
            // Parse a regular expression. Some context-awareness is necessary,
            // since a '/' inside a '[]' set does not end the expression.
            function readRegexp() {
                var content = "", escaped, inClass, start = tokPos;
                for (;;) {
                    if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
                    var ch = input.charAt(tokPos);
                    if (newline.test(ch)) raise(start, "Unterminated regular expression");
                    if (!escaped) {
                        if (ch === "[") inClass = true; else if (ch === "]" && inClass) inClass = false; else if (ch === "/" && !inClass) break;
                        escaped = ch === "\\";
                    } else escaped = false;
                    ++tokPos;
                }
                var content = input.slice(start, tokPos);
                ++tokPos;
                // Need to use `readWord1` because '\uXXXX' sequences are allowed
                // here (don't ask).
                var mods = readWord1();
                if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
                return finishToken(_regexp, new RegExp(content, mods));
            }
            // Read an integer in the given radix. Return null if zero digits
            // were read, the integer value otherwise. When `len` is given, this
            // will return `null` unless the integer has exactly `len` digits.
            function readInt(radix, len) {
                var start = tokPos, total = 0;
                for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                    var code = input.charCodeAt(tokPos), val;
                    if (code >= 97) val = code - 97 + 10; else if (code >= 65) val = code - 65 + 10; else if (code >= 48 && code <= 57) val = code - 48; else val = Infinity;
                    if (val >= radix) break;
                    ++tokPos;
                    total = total * radix + val;
                }
                if (tokPos === start || len != null && tokPos - start !== len) return null;
                return total;
            }
            function readHexNumber() {
                tokPos += 2;
                // 0x
                var val = readInt(16);
                if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
                if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
                return finishToken(_num, val);
            }
            // Read an integer, octal integer, or floating-point number.
            function readNumber(startsWithDot) {
                var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
                if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
                if (input.charCodeAt(tokPos) === 46) {
                    ++tokPos;
                    readInt(10);
                    isFloat = true;
                }
                var next = input.charCodeAt(tokPos);
                if (next === 69 || next === 101) {
                    // 'eE'
                    next = input.charCodeAt(++tokPos);
                    if (next === 43 || next === 45) ++tokPos;
                    // '+-'
                    if (readInt(10) === null) raise(start, "Invalid number");
                    isFloat = true;
                }
                if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
                var str = input.slice(start, tokPos), val;
                if (isFloat) val = parseFloat(str); else if (!octal || str.length === 1) val = parseInt(str, 10); else if (/[89]/.test(str) || strict) raise(start, "Invalid number"); else val = parseInt(str, 8);
                return finishToken(_num, val);
            }
            // Read a string value, interpreting backslash-escapes.
            var rs_str = [];
            function readString(quote) {
                tokPos++;
                rs_str.length = 0;
                for (;;) {
                    if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
                    var ch = input.charCodeAt(tokPos);
                    if (ch === quote) {
                        ++tokPos;
                        return finishToken(_string, String.fromCharCode.apply(null, rs_str));
                    }
                    if (ch === 92) {
                        // '\'
                        ch = input.charCodeAt(++tokPos);
                        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
                        if (octal) octal = octal[0];
                        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, octal.length - 1);
                        if (octal === "0") octal = null;
                        ++tokPos;
                        if (octal) {
                            if (strict) raise(tokPos - 2, "Octal literal in strict mode");
                            rs_str.push(parseInt(octal, 8));
                            tokPos += octal.length - 1;
                        } else {
                            switch (ch) {
                              case 110:
                                rs_str.push(10);
                                break;

                              // 'n' -> '\n'
                                case 114:
                                rs_str.push(13);
                                break;

                              // 'r' -> '\r'
                                case 120:
                                rs_str.push(readHexChar(2));
                                break;

                              // 'x'
                                case 117:
                                rs_str.push(readHexChar(4));
                                break;

                              // 'u'
                                case 85:
                                rs_str.push(readHexChar(8));
                                break;

                              // 'U'
                                case 116:
                                rs_str.push(9);
                                break;

                              // 't' -> '\t'
                                case 98:
                                rs_str.push(8);
                                break;

                              // 'b' -> '\b'
                                case 118:
                                rs_str.push(11);
                                break;

                              // 'v' -> '\u000b'
                                case 102:
                                rs_str.push(12);
                                break;

                              // 'f' -> '\f'
                                case 48:
                                rs_str.push(0);
                                break;

                              // 0 -> '\0'
                                case 13:
                                if (input.charCodeAt(tokPos) === 10) ++tokPos;

                              // '\r\n'
                                case 10:
                                // ' \n'
                                if (options.locations) {
                                    tokLineStart = tokPos;
                                    ++tokCurLine;
                                }
                                break;

                              default:
                                rs_str.push(ch);
                                break;
                            }
                        }
                    } else {
                        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8329) raise(tokStart, "Unterminated string constant");
                        rs_str.push(ch);
                        // '\'
                        ++tokPos;
                    }
                }
            }
            // Used to read character escape sequences ('\x', '\u', '\U').
            function readHexChar(len) {
                var n = readInt(16, len);
                if (n === null) raise(tokStart, "Bad character escape sequence");
                return n;
            }
            // Used to signal to callers of `readWord1` whether the word
            // contained any escape sequences. This is needed because words with
            // escape sequences must not be interpreted as keywords.
            var containsEsc;
            // Read an identifier, and return it as a string. Sets `containsEsc`
            // to whether the word contained a '\u' escape.
            //
            // Only builds up the word character-by-character when it actually
            // containeds an escape, as a micro-optimization.
            function readWord1() {
                containsEsc = false;
                var word, first = true, start = tokPos;
                for (;;) {
                    var ch = input.charCodeAt(tokPos);
                    if (isIdentifierChar(ch)) {
                        if (containsEsc) word += input.charAt(tokPos);
                        ++tokPos;
                    } else if (ch === 92) {
                        // "\"
                        if (!containsEsc) word = input.slice(start, tokPos);
                        containsEsc = true;
                        if (input.charCodeAt(++tokPos) != 117) // "u"
                        raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
                        ++tokPos;
                        var esc = readHexChar(4);
                        var escStr = String.fromCharCode(esc);
                        if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
                        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, "Invalid Unicode escape");
                        word += escStr;
                    } else {
                        break;
                    }
                    first = false;
                }
                return containsEsc ? word : input.slice(start, tokPos);
            }
            // Read an identifier or keyword token. Will check for reserved
            // words when necessary.
            function readWord() {
                var word = readWord1();
                var type = _name;
                if (!containsEsc) {
                    if (isKeyword(word)) type = keywordTypes[word]; else if (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) || strict && isStrictReservedWord(word)) raise(tokStart, "The keyword '" + word + "' is reserved");
                }
                return finishToken(type, word);
            }
            // ## Parser
            // A recursive descent parser operates by defining functions for all
            // syntactic elements, and recursively calling those, each function
            // advancing the input stream and returning an AST node. Precedence
            // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
            // instead of `(!x)[1]` is handled by the fact that the parser
            // function that parses unary prefix operators is called first, and
            // in turn calls the function that parses `[]` subscripts  that
            // way, it'll receive the node for `x[1]` already parsed, and wraps
            // *that* in the unary operator node.
            //
            // Acorn uses an [operator precedence parser][opp] to handle binary
            // operator precedence, because it is much more compact than using
            // the technique outlined above, which uses different, nesting
            // functions to specify precedence, for all of the ten binary
            // precedence levels that JavaScript defines.
            //
            // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
            // ### Parser utilities
            // Continue to the next token.
            function next() {
                lastStart = tokStart;
                lastEnd = tokEnd;
                lastEndLoc = tokEndLoc;
                readToken();
            }
            // Enter strict mode. Re-reads the next token to please pedantic
            // tests ("use strict"; 010; -- should fail).
            function setStrict(strct) {
                strict = strct;
                tokPos = lastEnd;
                skipSpace();
                readToken();
            }
            // Start an AST node, attaching a start offset.
            function node_t() {
                this.type = null;
                this.start = tokStart;
                this.end = null;
            }
            function node_loc_t() {
                this.start = tokStartLoc;
                this.end = null;
                if (sourceFile !== null) this.source = sourceFile;
            }
            function startNode() {
                var node = new node_t();
                if (options.locations) node.loc = new node_loc_t();
                if (options.ranges) node.range = [ tokStart, 0 ];
                return node;
            }
            // Start a node whose start offset information should be based on
            // the start of another node. For example, a binary operator node is
            // only started after its left-hand side has already been parsed.
            function startNodeFrom(other) {
                var node = new node_t();
                node.start = other.start;
                if (options.locations) {
                    node.loc = new node_loc_t();
                    node.loc.start = other.loc.start;
                }
                if (options.ranges) node.range = [ other.range[0], 0 ];
                return node;
            }
            // Finish an AST node, adding `type` and `end` properties.
            function finishNode(node, type) {
                node.type = type;
                node.end = lastEnd;
                if (options.locations) node.loc.end = lastEndLoc;
                if (options.ranges) node.range[1] = lastEnd;
                return node;
            }
            // Test whether a statement node is the string literal `"use strict"`.
            function isUseStrict(stmt) {
                return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
            }
            // Predicate that tests whether the next token is of the given
            // type, and if yes, consumes it as a side effect.
            function eat(type) {
                if (tokType === type) {
                    next();
                    return true;
                }
            }
            // Test whether a semicolon can be inserted at the current position.
            function canInsertSemicolon() {
                return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
            }
            // Consume a semicolon, or, failing that, see if we are allowed to
            // pretend that there is a semicolon at this position.
            function semicolon() {
                if (!eat(_semi) && !canInsertSemicolon()) unexpected();
            }
            // Expect a token of a given type. If found, consume it, otherwise,
            // raise an unexpected token error.
            function expect(type) {
                if (tokType === type) next(); else unexpected();
            }
            // Raise an unexpected token error.
            function unexpected() {
                raise(tokStart, "Unexpected token");
            }
            // Verify that a node is an lval  something that can be assigned
            // to.
            function checkLVal(expr) {
                if (expr.type !== "Identifier" && expr.type !== "MemberExpression") raise(expr.start, "Assigning to rvalue");
                if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name)) raise(expr.start, "Assigning to " + expr.name + " in strict mode");
            }
            // ### Statement parsing
            // Parse a program. Initializes the parser, reads any number of
            // statements, and wraps them in a Program node.  Optionally takes a
            // `program` argument.  If present, the statements will be appended
            // to its body instead of creating a new node.
            function parseTopLevel(program) {
                lastStart = lastEnd = tokPos;
                if (options.locations) lastEndLoc = new line_loc_t();
                inFunction = strict = null;
                labels = [];
                readToken();
                var node = program || startNode(), first = true;
                if (!program) node.body = [];
                while (tokType !== _eof) {
                    var stmt = parseStatement();
                    node.body.push(stmt);
                    if (first && isUseStrict(stmt)) setStrict(true);
                    first = false;
                }
                return finishNode(node, "Program");
            }
            var loopLabel = {
                kind: "loop"
            }, switchLabel = {
                kind: "switch"
            };
            // Parse a single statement.
            //
            // If expecting a statement and finding a slash operator, parse a
            // regular expression literal. This is to handle cases like
            // `if (foo) /blah/.exec(foo);`, where looking at the previous token
            // does not help.
            function parseStatement() {
                if (tokType === _slash) readToken(true);
                var starttype = tokType, node = startNode();
                // Most types of statements are recognized by the keyword they
                // start with. Many are trivial to parse, some require a bit of
                // complexity.
                switch (starttype) {
                  case _break:
                  case _continue:
                    next();
                    var isBreak = starttype === _break;
                    if (eat(_semi) || canInsertSemicolon()) node.label = null; else if (tokType !== _name) unexpected(); else {
                        node.label = parseIdent();
                        semicolon();
                    }
                    // Verify that there is an actual destination to break or
                    // continue to.
                    for (var i = 0; i < labels.length; ++i) {
                        var lab = labels[i];
                        if (node.label == null || lab.name === node.label.name) {
                            if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                            if (node.label && isBreak) break;
                        }
                    }
                    if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
                    return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

                  case _debugger:
                    next();
                    semicolon();
                    return finishNode(node, "DebuggerStatement");

                  case _do:
                    next();
                    labels.push(loopLabel);
                    node.body = parseStatement();
                    labels.pop();
                    expect(_while);
                    node.test = parseParenExpression();
                    semicolon();
                    return finishNode(node, "DoWhileStatement");

                  // Disambiguating between a `for` and a `for`/`in` loop is
                    // non-trivial. Basically, we have to parse the init `var`
                    // statement or expression, disallowing the `in` operator (see
                    // the second parameter to `parseExpression`), and then check
                    // whether the next token is `in`. When there is no init part
                    // (semicolon immediately after the opening parenthesis), it is
                    // a regular `for` loop.
                    case _for:
                    next();
                    labels.push(loopLabel);
                    expect(_parenL);
                    if (tokType === _semi) return parseFor(node, null);
                    if (tokType === _var) {
                        var init = startNode();
                        next();
                        parseVar(init, true);
                        if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);
                        return parseFor(node, init);
                    }
                    var init = parseExpression(false, true);
                    if (eat(_in)) {
                        checkLVal(init);
                        return parseForIn(node, init);
                    }
                    return parseFor(node, init);

                  case _function:
                    next();
                    return parseFunction(node, true);

                  case _if:
                    next();
                    node.test = parseParenExpression();
                    node.consequent = parseStatement();
                    node.alternate = eat(_else) ? parseStatement() : null;
                    return finishNode(node, "IfStatement");

                  case _return:
                    if (!inFunction) raise(tokStart, "'return' outside of function");
                    next();
                    // In `return` (and `break`/`continue`), the keywords with
                    // optional arguments, we eagerly look for a semicolon or the
                    // possibility to insert one.
                    if (eat(_semi) || canInsertSemicolon()) node.argument = null; else {
                        node.argument = parseExpression();
                        semicolon();
                    }
                    return finishNode(node, "ReturnStatement");

                  case _switch:
                    next();
                    node.discriminant = parseParenExpression();
                    node.cases = [];
                    expect(_braceL);
                    labels.push(switchLabel);
                    // Statements under must be grouped (by label) in SwitchCase
                    // nodes. `cur` is used to keep the node that we are currently
                    // adding statements to.
                    for (var cur, sawDefault; tokType != _braceR; ) {
                        if (tokType === _case || tokType === _default) {
                            var isCase = tokType === _case;
                            if (cur) finishNode(cur, "SwitchCase");
                            node.cases.push(cur = startNode());
                            cur.consequent = [];
                            next();
                            if (isCase) cur.test = parseExpression(); else {
                                if (sawDefault) raise(lastStart, "Multiple default clauses");
                                sawDefault = true;
                                cur.test = null;
                            }
                            expect(_colon);
                        } else {
                            if (!cur) unexpected();
                            cur.consequent.push(parseStatement());
                        }
                    }
                    if (cur) finishNode(cur, "SwitchCase");
                    next();
                    // Closing brace
                    labels.pop();
                    return finishNode(node, "SwitchStatement");

                  case _throw:
                    next();
                    if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, "Illegal newline after throw");
                    node.argument = parseExpression();
                    semicolon();
                    return finishNode(node, "ThrowStatement");

                  case _try:
                    next();
                    node.block = parseBlock();
                    node.handlers = [];
                    while (tokType === _catch) {
                        var clause = startNode();
                        next();
                        expect(_parenL);
                        clause.param = parseIdent();
                        if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
                        expect(_parenR);
                        clause.guard = null;
                        clause.body = parseBlock();
                        node.handlers.push(finishNode(clause, "CatchClause"));
                    }
                    node.finalizer = eat(_finally) ? parseBlock() : null;
                    if (!node.handlers.length && !node.finalizer) raise(node.start, "Missing catch or finally clause");
                    return finishNode(node, "TryStatement");

                  case _var:
                    next();
                    node = parseVar(node);
                    semicolon();
                    return node;

                  case _while:
                    next();
                    node.test = parseParenExpression();
                    labels.push(loopLabel);
                    node.body = parseStatement();
                    labels.pop();
                    return finishNode(node, "WhileStatement");

                  case _with:
                    if (strict) raise(tokStart, "'with' in strict mode");
                    next();
                    node.object = parseParenExpression();
                    node.body = parseStatement();
                    return finishNode(node, "WithStatement");

                  case _braceL:
                    return parseBlock();

                  case _semi:
                    next();
                    return finishNode(node, "EmptyStatement");

                  // If the statement does not start with a statement keyword or a
                    // brace, it's an ExpressionStatement or LabeledStatement. We
                    // simply start parsing an expression, and afterwards, if the
                    // next token is a colon and the expression was a simple
                    // Identifier node, we switch to interpreting it as a label.
                    default:
                    var maybeName = tokVal, expr = parseExpression();
                    if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
                        for (var i = 0; i < labels.length; ++i) if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
                        var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
                        labels.push({
                            name: maybeName,
                            kind: kind
                        });
                        node.body = parseStatement();
                        labels.pop();
                        node.label = expr;
                        return finishNode(node, "LabeledStatement");
                    } else {
                        node.expression = expr;
                        semicolon();
                        return finishNode(node, "ExpressionStatement");
                    }
                }
            }
            // Used for constructs like `switch` and `if` that insist on
            // parentheses around their expression.
            function parseParenExpression() {
                expect(_parenL);
                var val = parseExpression();
                expect(_parenR);
                return val;
            }
            // Parse a semicolon-enclosed block of statements, handling `"use
            // strict"` declarations when `allowStrict` is true (used for
            // function bodies).
            function parseBlock(allowStrict) {
                var node = startNode(), first = true, strict = false, oldStrict;
                node.body = [];
                expect(_braceL);
                while (!eat(_braceR)) {
                    var stmt = parseStatement();
                    node.body.push(stmt);
                    if (first && isUseStrict(stmt)) {
                        oldStrict = strict;
                        setStrict(strict = true);
                    }
                    first = false;
                }
                if (strict && !oldStrict) setStrict(false);
                return finishNode(node, "BlockStatement");
            }
            // Parse a regular `for` loop. The disambiguation code in
            // `parseStatement` will already have parsed the init statement or
            // expression.
            function parseFor(node, init) {
                node.init = init;
                expect(_semi);
                node.test = tokType === _semi ? null : parseExpression();
                expect(_semi);
                node.update = tokType === _parenR ? null : parseExpression();
                expect(_parenR);
                node.body = parseStatement();
                labels.pop();
                return finishNode(node, "ForStatement");
            }
            // Parse a `for`/`in` loop.
            function parseForIn(node, init) {
                node.left = init;
                node.right = parseExpression();
                expect(_parenR);
                node.body = parseStatement();
                labels.pop();
                return finishNode(node, "ForInStatement");
            }
            // Parse a list of variable declarations.
            function parseVar(node, noIn) {
                node.declarations = [];
                node.kind = "var";
                for (;;) {
                    var decl = startNode();
                    decl.id = parseIdent();
                    if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
                    decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
                    node.declarations.push(finishNode(decl, "VariableDeclarator"));
                    if (!eat(_comma)) break;
                }
                return finishNode(node, "VariableDeclaration");
            }
            // ### Expression parsing
            // These nest, from the most general expression type at the top to
            // 'atomic', nondivisible expression types at the bottom. Most of
            // the functions will simply let the function(s) below them parse,
            // and, *if* the syntactic construct they handle is present, wrap
            // the AST node that the inner parser gave them in another node.
            // Parse a full expression. The arguments are used to forbid comma
            // sequences (in argument lists, array literals, or object literals)
            // or the `in` operator (in for loops initalization expressions).
            function parseExpression(noComma, noIn) {
                var expr = parseMaybeAssign(noIn);
                if (!noComma && tokType === _comma) {
                    var node = startNodeFrom(expr);
                    node.expressions = [ expr ];
                    while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
                    return finishNode(node, "SequenceExpression");
                }
                return expr;
            }
            // Parse an assignment expression. This includes applications of
            // operators like `+=`.
            function parseMaybeAssign(noIn) {
                var left = parseMaybeConditional(noIn);
                if (tokType.isAssign) {
                    var node = startNodeFrom(left);
                    node.operator = tokVal;
                    node.left = left;
                    next();
                    node.right = parseMaybeAssign(noIn);
                    checkLVal(left);
                    return finishNode(node, "AssignmentExpression");
                }
                return left;
            }
            // Parse a ternary conditional (`?:`) operator.
            function parseMaybeConditional(noIn) {
                var expr = parseExprOps(noIn);
                if (eat(_question)) {
                    var node = startNodeFrom(expr);
                    node.test = expr;
                    node.consequent = parseExpression(true);
                    expect(_colon);
                    node.alternate = parseExpression(true, noIn);
                    return finishNode(node, "ConditionalExpression");
                }
                return expr;
            }
            // Start the precedence parser.
            function parseExprOps(noIn) {
                return parseExprOp(parseMaybeUnary(noIn), -1, noIn);
            }
            // Parse binary operators with the operator precedence parsing
            // algorithm. `left` is the left-hand side of the operator.
            // `minPrec` provides context that allows the function to stop and
            // defer further parser to one of its callers when it encounters an
            // operator that has a lower precedence than the set it is parsing.
            function parseExprOp(left, minPrec, noIn) {
                var prec = tokType.binop;
                if (prec != null && (!noIn || tokType !== _in)) {
                    if (prec > minPrec) {
                        var node = startNodeFrom(left);
                        node.left = left;
                        node.operator = tokVal;
                        next();
                        node.right = parseExprOp(parseMaybeUnary(noIn), prec, noIn);
                        var node = finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
                        return parseExprOp(node, minPrec, noIn);
                    }
                }
                return left;
            }
            // Parse unary operators, both prefix and postfix.
            function parseMaybeUnary(noIn) {
                if (tokType.prefix) {
                    var node = startNode(), update = tokType.isUpdate;
                    node.operator = tokVal;
                    node.prefix = true;
                    next();
                    node.argument = parseMaybeUnary(noIn);
                    if (update) checkLVal(node.argument); else if (strict && node.operator === "delete" && node.argument.type === "Identifier") raise(node.start, "Deleting local variable in strict mode");
                    return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
                }
                var expr = parseExprSubscripts();
                while (tokType.postfix && !canInsertSemicolon()) {
                    var node = startNodeFrom(expr);
                    node.operator = tokVal;
                    node.prefix = false;
                    node.argument = expr;
                    checkLVal(expr);
                    next();
                    expr = finishNode(node, "UpdateExpression");
                }
                return expr;
            }
            // Parse call, dot, and `[]`-subscript expressions.
            function parseExprSubscripts() {
                return parseSubscripts(parseExprAtom());
            }
            function parseSubscripts(base, noCalls) {
                if (eat(_dot)) {
                    var node = startNodeFrom(base);
                    node.object = base;
                    node.property = parseIdent(true);
                    node.computed = false;
                    return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
                } else if (eat(_bracketL)) {
                    var node = startNodeFrom(base);
                    node.object = base;
                    node.property = parseExpression();
                    node.computed = true;
                    expect(_bracketR);
                    return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
                } else if (!noCalls && eat(_parenL)) {
                    var node = startNodeFrom(base);
                    node.callee = base;
                    node.arguments = parseExprList(_parenR, false);
                    return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
                } else return base;
            }
            // Parse an atomic expression  either a single token that is an
            // expression, an expression started by a keyword like `function` or
            // `new`, or an expression wrapped in punctuation like `()`, `[]`,
            // or `{}`.
            function parseExprAtom() {
                switch (tokType) {
                  case _this:
                    var node = startNode();
                    next();
                    return finishNode(node, "ThisExpression");

                  case _name:
                    return parseIdent();

                  case _num:
                  case _string:
                  case _regexp:
                    var node = startNode();
                    node.value = tokVal;
                    node.raw = input.slice(tokStart, tokEnd);
                    next();
                    return finishNode(node, "Literal");

                  case _null:
                  case _true:
                  case _false:
                    var node = startNode();
                    node.value = tokType.atomValue;
                    node.raw = tokType.keyword;
                    next();
                    return finishNode(node, "Literal");

                  case _parenL:
                    var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
                    next();
                    var val = parseExpression();
                    val.start = tokStart1;
                    val.end = tokEnd;
                    if (options.locations) {
                        val.loc.start = tokStartLoc1;
                        val.loc.end = tokEndLoc;
                    }
                    if (options.ranges) val.range = [ tokStart1, tokEnd ];
                    expect(_parenR);
                    return val;

                  case _bracketL:
                    var node = startNode();
                    next();
                    node.elements = parseExprList(_bracketR, true, true);
                    return finishNode(node, "ArrayExpression");

                  case _braceL:
                    return parseObj();

                  case _function:
                    var node = startNode();
                    next();
                    return parseFunction(node, false);

                  case _new:
                    return parseNew();

                  default:
                    unexpected();
                }
            }
            // New's precedence is slightly tricky. It must allow its argument
            // to be a `[]` or dot subscript expression, but not a call  at
            // least, not without wrapping it in parentheses. Thus, it uses the 
            function parseNew() {
                var node = startNode();
                next();
                node.callee = parseSubscripts(parseExprAtom(), true);
                if (eat(_parenL)) node.arguments = parseExprList(_parenR, false); else node.arguments = [];
                return finishNode(node, "NewExpression");
            }
            // Parse an object literal.
            function parseObj() {
                var node = startNode(), first = true, sawGetSet = false;
                node.properties = [];
                next();
                while (!eat(_braceR)) {
                    if (!first) {
                        expect(_comma);
                        if (options.allowTrailingCommas && eat(_braceR)) break;
                    } else first = false;
                    var prop = {
                        key: parsePropertyName()
                    }, isGetSet = false, kind;
                    if (eat(_colon)) {
                        prop.value = parseExpression(true);
                        kind = prop.kind = "init";
                    } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set")) {
                        isGetSet = sawGetSet = true;
                        kind = prop.kind = prop.key.name;
                        prop.key = parsePropertyName();
                        if (tokType !== _parenL) unexpected();
                        prop.value = parseFunction(startNode(), false);
                    } else unexpected();
                    // getters and setters are not allowed to clash  either with
                    // each other or with an init property  and in strict mode,
                    // init properties are also not allowed to be repeated.
                    if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
                        for (var i = 0; i < node.properties.length; ++i) {
                            var other = node.properties[i];
                            if (other.key.name === prop.key.name) {
                                var conflict = kind == other.kind || isGetSet && other.kind === "init" || kind === "init" && (other.kind === "get" || other.kind === "set");
                                if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
                                if (conflict) raise(prop.key.start, "Redefinition of property");
                            }
                        }
                    }
                    node.properties.push(prop);
                }
                return finishNode(node, "ObjectExpression");
            }
            function parsePropertyName() {
                if (tokType === _num || tokType === _string) return parseExprAtom();
                return parseIdent(true);
            }
            // Parse a function declaration or literal (depending on the
            // `isStatement` parameter).
            function parseFunction(node, isStatement) {
                if (tokType === _name) node.id = parseIdent(); else if (isStatement) unexpected(); else node.id = null;
                node.params = [];
                var first = true;
                expect(_parenL);
                while (!eat(_parenR)) {
                    if (!first) expect(_comma); else first = false;
                    node.params.push(parseIdent());
                }
                // Start a new scope with regard to labels and the `inFunction`
                // flag (restore them to their old value afterwards).
                var oldInFunc = inFunction, oldLabels = labels;
                inFunction = true;
                labels = [];
                node.body = parseBlock(true);
                inFunction = oldInFunc;
                labels = oldLabels;
                // If this is a strict mode function, verify that argument names
                // are not repeated, and it does not try to bind the words `eval`
                // or `arguments`.
                if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
                    for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
                        var id = i < 0 ? node.id : node.params[i];
                        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, "Defining '" + id.name + "' in strict mode");
                        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name) raise(id.start, "Argument name clash in strict mode");
                    }
                }
                return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
            }
            // Parses a comma-separated list of expressions, and returns them as
            // an array. `close` is the token type that ends the list, and
            // `allowEmpty` can be turned on to allow subsequent commas with
            // nothing in between them to be parsed as `null` (which is needed
            // for array literals).
            function parseExprList(close, allowTrailingComma, allowEmpty) {
                var elts = [], first = true;
                while (!eat(close)) {
                    if (!first) {
                        expect(_comma);
                        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
                    } else first = false;
                    if (allowEmpty && tokType === _comma) elts.push(null); else elts.push(parseExpression(true));
                }
                return elts;
            }
            // Parse the next token as an identifier. If `liberal` is true (used
            // when parsing properties), it will also convert keywords into
            // identifiers.
            function parseIdent(liberal) {
                var node = startNode();
                node.name = tokType === _name ? tokVal : liberal && !options.forbidReserved && tokType.keyword || unexpected();
                next();
                return finishNode(node, "Identifier");
            }
        })(typeof exports === "undefined" ? self.acorn = {} : exports);
    });
    define("hsp/compiler/jsgenerator/jsvalidator/validator.js", [ "acorn/acorn" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var acorn = require("acorn/acorn");
        /**
 * Validates a JavaScript string
 * @param {String} input the Javascript string
 * @return {Object} JSON structure with 'valid' and 'errors' properties e.g. {valid:false, errors:[{msg:'...',lineInfoTxt:'...',lineInfoHTML:'...',loc:{line:2,column:30}'}]}
 */
        module.exports.validate = function(input) {
            var result = {
                isValid: true
            };
            try {
                acorn.parse(input, {
                    ecmaVersion: 3,
                    strictSemicolons: false,
                    allowTrailingCommas: false,
                    forbidReserved: true
                });
            } catch (ex) {
                result.isValid = false;
                result.errors = [ formatError(ex, input) ];
            }
            return result;
        };
        /**
 * Formats the error as an error structure with line extract information.
 * @param {Object} error the exception.
 * @param {String} input the Javascript string.
 * @return {Object} the structured error.
 */
        function formatError(error, input) {
            var message = error.toString().replace(/\s*\(\d*\:\d*\)\s*$/i, "");
            // remove line number / col number
            var beforeMatch = ("" + input.slice(0, error.pos)).match(/.*$/i);
            var afterMatch = ("" + input.slice(error.pos)).match(/.*/i);
            var before = beforeMatch ? beforeMatch[0] : "";
            var after = afterMatch ? afterMatch[0] : "";
            // Prepare line info for txt display
            var cursorPos = before.length;
            var errChar = after.length ? after.slice(0, 1) : "X";
            var lineStr = before + after;
            var lncursor = [];
            for (var i = 0; i < lineStr.length; i++) {
                lncursor[i] = i === cursorPos ? "^" : "-";
            }
            var lineInfoTxt = lineStr + "\r\n" + lncursor.join("");
            // Prepare line info for HTML display
            var lineInfoHTML = [ '<span class="code">', before, '<span class="error" title="', message, '">', errChar, "</span>", after.slice(1), "</span>" ].join("");
            return {
                description: message,
                lineInfoTxt: lineInfoTxt,
                lineInfoHTML: lineInfoHTML,
                code: lineStr,
                line: error.loc ? error.loc.line : -1,
                column: error.loc ? error.loc.column : -1
            };
        }
    });
    define("hsp/compiler/jsgenerator/index.js", [ "./templateWalker", "./processors", "./jsvalidator/validator" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var TemplateWalker = require("./templateWalker").TemplateWalker;
        var processors = require("./processors");
        var jsv = require("./jsvalidator/validator");
        /**
 * Header added to all generated JS file
 */
        var HEADER_ARR = [ "// ################################################################ ", "//  This file has been generated by the hashspace compiler          ", "//  Direct MODIFICATIONS WILL BE LOST when the file is recompiled!  ", "// ################################################################ ", "", 'var hsp=require("hsp/rt");', "" ];
        var HEADER = module.exports.HEADER = HEADER_ARR.join("\r\n");
        var HEADER_SZ = HEADER_ARR.length;
        /**
 * Generates the JS compiled string and a list of errors.
 * @param {Object} res the result of the previous steps of the compilation.
 * @param {String} template the template file content as a string.
 * @param {String} dirPath the directory path.
 * @param {String} fileName the name of the file being compiled (optional - used for error messages).
 * @param {Boolean} includeSyntaxTree  if true, the result object will contain the syntax tree generated by the compiler.
 * @param {Boolean} bypassJSvalidation  if true, the validation of the generated JS file (including non-template code) is bypassed - default:false.
 * @return {JSON} a JSON structure with the following properties:
 *      errors: {Array} the error list - each error having the following structure:
 *          description: {String} - a message describing the error 
 *          line: {Number} - the error line number
 *          column: {Number} - the error column number 
 *          code: {String} - a code extract showing where the error occurs (optional)
 *      code: {String} the generated JavaScript code
 *      syntaxTree: {JSON} the syntax tree generated by the parser (optional - cf. parameters)
 *      lineMap: {Array} array of the new line indexes: lineMap[3] returns the new line index for line 4 in
 *          the orginal file (lineMap[0] is always 0 as all line count starts at 1 for both input and output values)
 */
        exports.generate = function(res, template, fileName, dirPath, includeSyntaxTree, bypassJSvalidation) {
            res.code = "";
            if (!res.errors || !res.errors.length) {
                // It is sure that res is an array otherwise the parser would have thrown an exception
                var templateWalker = new TemplateWalker(fileName, dirPath);
                var out = templateWalker.walk(res.syntaxTree, processors);
                if (includeSyntaxTree === true) {
                    res.codeFragments = templateWalker.templates;
                }
                res.code = HEADER + out.join("\r\n");
                res.errors = templateWalker.errors;
            } else {
                // Generate a JS script to show the errors when the generated file is loaded
                res.code = HEADER;
            }
            if (!res.errors) {
                res.errors = [];
            } else if (res.errors.length > 0) {
                // remove all code so that script can still be loaded
                res.code = HEADER;
            }
            if (res.errors.length === 0 && bypassJSvalidation !== true) {
                var lineMap = _generateLineMap(res, template);
                res.lineMap = lineMap;
                var validationResult = _validate(res.code, lineMap);
                // call the JS validator
                // we don't checke for JS errors when there are template errors as the code generated by the template may be
                // wrong
                if (!validationResult.isValid) {
                    // remove all code so that script can still be loaded
                    res.code = HEADER;
                    Array.prototype.push.apply(res.errors, validationResult.errors);
                }
            }
            res.code += _getErrorScript(res.errors, fileName);
            if (includeSyntaxTree !== true) {
                res.syntaxTree = null;
            }
            return res;
        };
        /**
 * Validates a javascript string using the jsvalidator module, and generates an error report if not valid.
 * @param {String} code the javascript string.
 * @param {Object} lineMap the line mapping between the source template and the compiled one
 * @return {Object} a result map
 */
        function _validate(code, lineMap) {
            var validationResult = jsv.validate(code);
            var result = {
                isValid: validationResult.isValid
            };
            if (!validationResult.isValid) {
                // translate error line numbers
                var error, lineNumber;
                for (var i = 0; i < validationResult.errors.length; i++) {
                    error = validationResult.errors[i];
                    lineNumber = error.line;
                    error.line = -1;
                    // to avoid sending a wrong line in case of pb
                    for (var j = 0; j < lineMap.length; j++) {
                        if (lineMap[j] === lineNumber) {
                            error.line = j;
                            // original line nbr
                            break;
                        }
                    }
                }
                result.errors = validationResult.errors;
            }
            return result;
        }
        /**
 * Generate an error script to include in the template compiled script in order to show errors in the browser when the script is loaded
 * @param {Array} errors the errror list
 * @param {String} fileName the name of the file being compiled
 * @return {String} the javascript snippet to be included
 */
        function _getErrorScript(errors, fileName) {
            var result = "";
            if (errors && errors.length) {
                result = [ '\r\nrequire("hsp/rt").logErrors("', fileName, '",', JSON.stringify(errors, null), ");\r\n" ].join("");
            }
            return result;
        }
        /**
 * Generate the line map of a compilatin result
 * @param {JSON} res the result object of a compilation - cf. compile function
 * @param {String} file the template file (before compilation)
 */
        function _generateLineMap(res, file) {
            if (res.errors && res.errors.length) {
                return;
            }
            var syntaxTree = res.syntaxTree, templates = [];
            // identify the templates in the syntax tree
            for (var i = 0; i < syntaxTree.length; i++) {
                if (syntaxTree[i].type === "template") {
                    templates.push(syntaxTree[i]);
                }
            }
            var nbrOfLinesInCompiledTemplate = 5;
            var lineMap = [], pos = HEADER_SZ, template;
            var pos1 = -1;
            // position of the next template start
            var pos2 = -1;
            // position of the next template end
            var tplIdx = -1;
            // position of the current template
            for (var i = 0; i < file.split(/\n/g).length + 1; i++) {
                if (i === 0 || i === pos2) {
                    // end of current template: let's determine next pos1 and pos2
                    tplIdx = i === 0 ? 0 : tplIdx + 1;
                    if (tplIdx < templates.length) {
                        // there is another template
                        template = templates[tplIdx];
                        pos1 = template.startLine;
                        pos2 = template.endLine;
                        if (pos2 < pos1) {
                            // this case should never arrive..
                            pos2 = pos1;
                        }
                    } else {
                        // last template has been found
                        tplIdx = pos1 = pos2 = -1;
                    }
                    if (i === 0) {
                        lineMap[0] = 0;
                    }
                    i++;
                }
                if (i === pos1) {
                    for (var j = pos1; j < pos2 + 1; j++) {
                        // all lines are set to the template start
                        lineMap[i] = pos;
                        i++;
                    }
                    pos += nbrOfLinesInCompiledTemplate;
                    i -= 2;
                } else {
                    lineMap[i] = pos;
                    pos++;
                }
            }
            return lineMap;
        }
    });
    define("hsp/compiler/compiler.js", [ "./parser/index", "./treebuilder/index", "./jsgenerator/index" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var parser = require("./parser/index");
        var treebuilder = require("./treebuilder/index");
        var jsgenerator = require("./jsgenerator/index");
        /**
 * Compiles a template and return a JS compiled string and a list of errors.
 * @param {String} template the template file content as a string.
 * @param {String} dirPath the directory path.
 * @param {String} fileName the name of the file being compiled (optional - used for error messages).
 * @param {Boolean} includeSyntaxTree  if true, the result object will contain the syntax tree generated by the compiler.
 * @param {Boolean} bypassJSvalidation  if true, the validation of the generated JS file (including non-template code) is bypassed - default:false.
 * @return {JSON} a JSON structure with the following properties:
 *      errors: {Array} the error list - each error having the following structure:
 *          description: {String} - a message describing the error 
 *          line: {Number} - the error line number
 *          column: {Number} - the error column number 
 *          code: {String} - a code extract showing where the error occurs (optional)
 *      code: {String} the generated JavaScript code
 *      syntaxTree: {JSON} the syntax tree generated by the parser (optional - cf. parameters)
 *      lineMap: {Array} array of the new line indexes: lineMap[3] returns the new line index for line 4 in
 *          the orginal file (lineMap[0] is always 0 as all line count starts at 1 for both input and output values)
 */
        exports.compile = function(template, path, includeSyntaxTree, bypassJSvalidation) {
            // Parsing might throw an exception
            var res = {};
            var m = path.match(/[^\/]+$/), fileName = m ? m[0] : "unknown", dirPath = "";
            if (fileName.length < path.length) {
                dirPath = path.slice(0, -fileName.length);
            }
            if (!template) {
                res.errors = [ {
                    description: "[Hashspace compiler] template argument is undefined"
                } ];
            } else {
                //Step 1: parser
                var blockList = parser.parse(template);
                //Step2 : treebuilder
                res = treebuilder.build(blockList);
            }
            //Step3 : jsgenerator
            res = jsgenerator.generate(res, template, fileName, dirPath, includeSyntaxTree, bypassJSvalidation);
            return res;
        };
    });
})(noder.define);