(function(define) {
    define("hsp/compiler/parser/hspblocks.peg.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        module.exports = function() {
            /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */
            function peg$subclass(child, parent) {
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
            }
            function SyntaxError(message, expected, found, offset, line, column) {
                this.message = message;
                this.expected = expected;
                this.found = found;
                this.offset = offset;
                this.line = line;
                this.column = column;
                this.name = "SyntaxError";
            }
            peg$subclass(SyntaxError, Error);
            function parse(input) {
                var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = {
                    TemplateFile: peg$parseTemplateFile
                }, peg$startRuleFunction = peg$parseTemplateFile, peg$c0 = [], peg$c1 = function(blocks) {
                    return blocks;
                }, peg$c2 = peg$FAILED, peg$c3 = function(chars, eol) {
                    return chars.join("") + eol;
                }, peg$c4 = function(lines) {
                    return {
                        type: "plaintext",
                        value: lines.join("")
                    };
                }, peg$c5 = {
                    type: "other",
                    description: "HTML comment"
                }, peg$c6 = function(block, eol) {
                    block.type = "toplevelcomment";
                    // to differentiate it from a comment inside a template
                    block.value = block.value + (eol || "");
                    return block;
                }, peg$c7 = {
                    type: "other",
                    description: "script block"
                }, peg$c8 = "<script>", peg$c9 = {
                    type: "literal",
                    value: "<script>",
                    description: '"<script>"'
                }, peg$c10 = null, peg$c11 = "</script>", peg$c12 = {
                    type: "literal",
                    value: "</script>",
                    description: '"</script>"'
                }, peg$c13 = function(eol1, content, eol2) {
                    content.value = (eol1 || "") + content.value + (eol2 || "");
                    return content;
                }, peg$c14 = void 0, peg$c15 = "<", peg$c16 = {
                    type: "literal",
                    value: "<",
                    description: '"<"'
                }, peg$c17 = "template", peg$c18 = {
                    type: "literal",
                    value: "template",
                    description: '"template"'
                }, peg$c19 = "/script", peg$c20 = {
                    type: "literal",
                    value: "/script",
                    description: '"/script"'
                }, peg$c21 = /^[a-zA-Z0-9]/, peg$c22 = {
                    type: "class",
                    value: "[a-zA-Z0-9]",
                    description: "[a-zA-Z0-9]"
                }, peg$c23 = "#", peg$c24 = {
                    type: "literal",
                    value: "#",
                    description: '"#"'
                }, peg$c25 = "require", peg$c26 = {
                    type: "literal",
                    value: "require",
                    description: '"require"'
                }, peg$c27 = /^[^\n\r]/, peg$c28 = {
                    type: "class",
                    value: "[^\\n\\r]",
                    description: "[^\\n\\r]"
                }, peg$c29 = function(chars, eol) {
                    return chars.join("") + eol;
                }, peg$c30 = {
                    type: "other",
                    description: "template block"
                }, peg$c31 = function(start, content, end) {
                    start.content = content;
                    if (end) {
                        start.closed = true;
                        start.endLine = end.line;
                    }
                    return start;
                }, peg$c32 = {
                    type: "other",
                    description: "template statement"
                }, peg$c33 = function(c) {
                    return c.join("");
                }, peg$c34 = ">", peg$c35 = {
                    type: "literal",
                    value: ">",
                    description: '">"'
                }, peg$c36 = function(d1, p, m, name, args, d2) {
                    var mod = "";
                    // modifier (e.g. "export")
                    if (m !== "template") {
                        mod = m;
                    }
                    if (args && args.invalidTplArg) {
                        if (mod) {
                            mod += " ";
                        }
                        return {
                            type: "invalidtemplate",
                            line: line(),
                            column: column(),
                            code: d1 + p + mod + "template " + name + " " + args.invalidTplArg
                        };
                    } else {
                        if (d1 === "<" && d2 !== ">") {
                            // inconsistant delimiters
                            return {
                                type: "invalidtemplate",
                                line: line(),
                                column: column(),
                                code: d1 + p + mod + "template " + name + " " + args.invalidTplArg
                            };
                        }
                        if (args && args.ctl && args.constructor !== Array) {
                            // this template uses a controller
                            return {
                                type: "template",
                                name: name,
                                mod: mod,
                                controller: args.ctl,
                                controllerRef: args.ctlref,
                                line: line(),
                                column: column()
                            };
                        }
                        return {
                            type: "template",
                            name: name,
                            mod: mod,
                            args: args == null ? [] : args,
                            line: line(),
                            column: column()
                        };
                    }
                }, peg$c37 = {
                    type: "other",
                    description: "controller"
                }, peg$c38 = "using", peg$c39 = {
                    type: "literal",
                    value: "using",
                    description: '"using"'
                }, peg$c40 = ":", peg$c41 = {
                    type: "literal",
                    value: ":",
                    description: '":"'
                }, peg$c42 = function(ref, ctl) {
                    return {
                        ctl: ctl,
                        ctlref: ref
                    };
                }, peg$c43 = {
                    type: "other",
                    description: "arguments"
                }, peg$c44 = "(", peg$c45 = {
                    type: "literal",
                    value: "(",
                    description: '"("'
                }, peg$c46 = ",", peg$c47 = {
                    type: "literal",
                    value: ",",
                    description: '","'
                }, peg$c48 = function(arg) {
                    return arg;
                }, peg$c49 = ")", peg$c50 = {
                    type: "literal",
                    value: ")",
                    description: '")"'
                }, peg$c51 = function(first, others) {
                    var args = first ? [ first ] : [];
                    if (others && others.length) args = args.concat(others);
                    return args;
                }, peg$c52 = function(chars) {
                    return {
                        invalidTplArg: chars.join("")
                    };
                }, peg$c53 = {
                    type: "other",
                    description: "template end statement"
                }, peg$c54 = "</template", peg$c55 = {
                    type: "literal",
                    value: "</template",
                    description: '"</template"'
                }, peg$c56 = function() {
                    return {
                        type: "/template",
                        line: line(),
                        column: column()
                    };
                }, peg$c57 = {
                    type: "other",
                    description: "template content"
                }, peg$c58 = function(blocks) {
                    return blocks;
                }, peg$c59 = {
                    type: "other",
                    description: "text"
                }, peg$c60 = function(chars) {
                    return {
                        type: "text",
                        value: chars.join(""),
                        line: line(),
                        column: column()
                    };
                }, peg$c61 = {
                    type: "other",
                    description: "text character"
                }, peg$c62 = "\\{", peg$c63 = {
                    type: "literal",
                    value: "\\{",
                    description: '"\\\\{"'
                }, peg$c64 = function() {
                    return "{";
                }, peg$c65 = "\\}", peg$c66 = {
                    type: "literal",
                    value: "\\}",
                    description: '"\\\\}"'
                }, peg$c67 = function() {
                    return "}";
                }, peg$c68 = "\\n", peg$c69 = {
                    type: "literal",
                    value: "\\n",
                    description: '"\\\\n"'
                }, peg$c70 = function() {
                    return "\n";
                }, peg$c71 = function() {
                    return "";
                }, peg$c72 = function() {
                    return " ";
                }, peg$c73 = "/template", peg$c74 = {
                    type: "literal",
                    value: "/template",
                    description: '"/template"'
                }, peg$c75 = function() {
                    return "#";
                }, peg$c76 = "/", peg$c77 = {
                    type: "literal",
                    value: "/",
                    description: '"/"'
                }, peg$c78 = function() {
                    return "/";
                }, peg$c79 = "\\/", peg$c80 = {
                    type: "literal",
                    value: "\\/",
                    description: '"\\\\/"'
                }, peg$c81 = "\\//", peg$c82 = {
                    type: "literal",
                    value: "\\//",
                    description: '"\\\\//"'
                }, peg$c83 = function() {
                    return "//";
                }, peg$c84 = "\\<", peg$c85 = {
                    type: "literal",
                    value: "\\<",
                    description: '"\\\\<"'
                }, peg$c86 = function() {
                    return "<";
                }, peg$c87 = /^[^{#\/<]/, peg$c88 = {
                    type: "class",
                    value: "[^{#\\/<]",
                    description: "[^{#\\/<]"
                }, peg$c89 = "{", peg$c90 = {
                    type: "literal",
                    value: "{",
                    description: '"{"'
                }, peg$c91 = /^[^{}#]/, peg$c92 = {
                    type: "class",
                    value: "[^{}#]",
                    description: "[^{}#]"
                }, peg$c93 = "}", peg$c94 = {
                    type: "literal",
                    value: "}",
                    description: '"}"'
                }, peg$c95 = function(chars) {
                    return {
                        type: "invalidblock",
                        code: chars.join(""),
                        line: line(),
                        column: column()
                    };
                }, peg$c96 = {
                    type: "other",
                    description: "if statement"
                }, peg$c97 = "if ", peg$c98 = {
                    type: "literal",
                    value: "if ",
                    description: '"if "'
                }, peg$c99 = function(expr) {
                    return {
                        type: "if",
                        condition: expr,
                        line: line(),
                        column: column()
                    };
                }, peg$c100 = function(expr) {
                    return expr;
                }, peg$c101 = {
                    type: "other",
                    description: "elseif statement"
                }, peg$c102 = "else ", peg$c103 = {
                    type: "literal",
                    value: "else ",
                    description: '"else "'
                }, peg$c104 = "if", peg$c105 = {
                    type: "literal",
                    value: "if",
                    description: '"if"'
                }, peg$c106 = function(expr) {
                    return {
                        type: "elseif",
                        condition: expr,
                        line: line(),
                        column: column()
                    };
                }, peg$c107 = "else", peg$c108 = {
                    type: "literal",
                    value: "else",
                    description: '"else"'
                }, peg$c109 = function() {
                    return {
                        type: "else",
                        line: line(),
                        column: column()
                    };
                }, peg$c110 = "/if", peg$c111 = {
                    type: "literal",
                    value: "/if",
                    description: '"/if"'
                }, peg$c112 = function() {
                    return {
                        type: "endif",
                        line: line(),
                        column: column()
                    };
                }, peg$c113 = "//", peg$c114 = {
                    type: "literal",
                    value: "//",
                    description: '"//"'
                }, peg$c115 = /^[^\r\n]/, peg$c116 = {
                    type: "class",
                    value: "[^\\r\\n]",
                    description: "[^\\r\\n]"
                }, peg$c117 = function(chars) {
                    return {
                        type: "comment",
                        value: chars.join("")
                    };
                }, peg$c118 = "<!--", peg$c119 = {
                    type: "literal",
                    value: "<!--",
                    description: '"<!--"'
                }, peg$c120 = "-->", peg$c121 = {
                    type: "literal",
                    value: "-->",
                    description: '"-->"'
                }, peg$c122 = "-", peg$c123 = {
                    type: "literal",
                    value: "-",
                    description: '"-"'
                }, peg$c124 = function() {
                    return "-";
                }, peg$c125 = "->", peg$c126 = {
                    type: "literal",
                    value: "->",
                    description: '"->"'
                }, peg$c127 = "--", peg$c128 = {
                    type: "literal",
                    value: "--",
                    description: '"--"'
                }, peg$c129 = function() {
                    return ">";
                }, peg$c130 = /^[^>\-]/, peg$c131 = {
                    type: "class",
                    value: "[^>\\-]",
                    description: "[^>\\-]"
                }, peg$c132 = "foreach ", peg$c133 = {
                    type: "literal",
                    value: "foreach ",
                    description: '"foreach "'
                }, peg$c134 = function(a) {
                    return a;
                }, peg$c135 = function(args) {
                    return {
                        type: "foreach",
                        item: args.item,
                        key: args.key,
                        colref: args.colref,
                        line: line(),
                        column: column()
                    };
                }, peg$c136 = " ", peg$c137 = {
                    type: "literal",
                    value: " ",
                    description: '" "'
                }, peg$c138 = "in ", peg$c139 = {
                    type: "literal",
                    value: "in ",
                    description: '"in "'
                }, peg$c140 = function(item, col) {
                    return {
                        item: item,
                        key: item + "_key",
                        colref: col
                    };
                }, peg$c141 = function(key, item, col) {
                    return {
                        item: item,
                        key: key,
                        colref: col
                    };
                }, peg$c142 = "/foreach", peg$c143 = {
                    type: "literal",
                    value: "/foreach",
                    description: '"/foreach"'
                }, peg$c144 = function() {
                    return {
                        type: "endforeach",
                        line: line(),
                        column: column()
                    };
                }, peg$c145 = function(name, atts, end) {
                    return {
                        type: "element",
                        name: name,
                        closed: end != null,
                        attributes: atts,
                        line: line(),
                        column: column()
                    };
                }, peg$c146 = function(att) {
                    return att;
                }, peg$c147 = "</", peg$c148 = {
                    type: "literal",
                    value: "</",
                    description: '"</"'
                }, peg$c149 = function(name) {
                    return {
                        type: "endelement",
                        name: name,
                        line: line(),
                        column: column()
                    };
                }, peg$c150 = "<#", peg$c151 = {
                    type: "literal",
                    value: "<#",
                    description: '"<#"'
                }, peg$c152 = function(ref, atts, end) {
                    return {
                        type: "component",
                        ref: ref,
                        closed: end != null,
                        attributes: atts,
                        line: line(),
                        column: column()
                    };
                }, peg$c153 = "</#", peg$c154 = {
                    type: "literal",
                    value: "</#",
                    description: '"</#"'
                }, peg$c155 = function(ref) {
                    return {
                        type: "endcomponent",
                        ref: ref,
                        line: line(),
                        column: column()
                    };
                }, peg$c156 = "<@", peg$c157 = {
                    type: "literal",
                    value: "<@",
                    description: '"<@"'
                }, peg$c158 = function(ref, atts, end) {
                    return {
                        type: "cptattribute",
                        name: ref,
                        closed: end != null,
                        attributes: atts,
                        line: line(),
                        column: column()
                    };
                }, peg$c159 = "</@", peg$c160 = {
                    type: "literal",
                    value: "</@",
                    description: '"</@"'
                }, peg$c161 = function(ref) {
                    return {
                        type: "endcptattribute",
                        name: ref,
                        line: line(),
                        column: column()
                    };
                }, peg$c162 = function(code) {
                    return {
                        type: "invalidelement",
                        code: "<" + code.join(""),
                        line: line(),
                        column: column()
                    };
                }, peg$c163 = /^[a-z]/, peg$c164 = {
                    type: "class",
                    value: "[a-z]",
                    description: "[a-z]"
                }, peg$c165 = /^[0-9]/, peg$c166 = {
                    type: "class",
                    value: "[0-9]",
                    description: "[0-9]"
                }, peg$c167 = function(first, next) {
                    return first + next.join("");
                }, peg$c168 = /^[a-zA-Z#]/, peg$c169 = {
                    type: "class",
                    value: "[a-zA-Z#]",
                    description: "[a-zA-Z#]"
                }, peg$c170 = /^[a-zA-Z]/, peg$c171 = {
                    type: "class",
                    value: "[a-zA-Z]",
                    description: "[a-zA-Z]"
                }, peg$c172 = function(end) {
                    return ":" + end.join("");
                }, peg$c173 = function(first, next, endString) {
                    return first + next.join("") + (endString ? endString : "");
                }, peg$c174 = "=", peg$c175 = {
                    type: "literal",
                    value: "=",
                    description: '"="'
                }, peg$c176 = '"', peg$c177 = {
                    type: "literal",
                    value: '"',
                    description: '"\\""'
                }, peg$c178 = function(value) {
                    return value;
                }, peg$c179 = function(name, v) {
                    return {
                        type: "attribute",
                        name: name,
                        value: v,
                        line: line(),
                        column: column()
                    };
                }, peg$c180 = function(chars) {
                    return {
                        type: "text",
                        value: chars.join("")
                    };
                }, peg$c181 = '\\"', peg$c182 = {
                    type: "literal",
                    value: '\\"',
                    description: '"\\\\\\""'
                }, peg$c183 = function() {
                    return '"';
                }, peg$c184 = function() {
                    return "\\n";
                }, peg$c185 = /^[^{"]/, peg$c186 = {
                    type: "class",
                    value: '[^{"]',
                    description: '[^{"]'
                }, peg$c187 = "log ", peg$c188 = {
                    type: "literal",
                    value: "log ",
                    description: '"log "'
                }, peg$c189 = function(first, next) {
                    var exprs = [ first ];
                    if (next) {
                        for (var i = 0, sz = next.length; sz > i; i++) {
                            exprs.push(next[i][2]);
                        }
                    }
                    return {
                        type: "log",
                        exprs: exprs,
                        line: line(),
                        column: column()
                    };
                }, peg$c190 = "let ", peg$c191 = {
                    type: "literal",
                    value: "let ",
                    description: '"let "'
                }, peg$c192 = function(first, next) {
                    var asn = [ first ];
                    if (next) {
                        for (var i = 0, sz = next.length; sz > i; i++) {
                            asn.push(next[i][2]);
                        }
                    }
                    return {
                        type: "let",
                        assignments: asn,
                        line: line(),
                        column: column()
                    };
                }, peg$c193 = function(c) {
                    return {
                        category: "jsexptext",
                        value: c.join(""),
                        line: line(),
                        column: column()
                    };
                }, peg$c194 = /^[^{}()]/, peg$c195 = {
                    type: "class",
                    value: "[^{}()]",
                    description: "[^{}()]"
                }, peg$c196 = function(exp) {
                    return exp !== null ? exp.value : "";
                }, peg$c197 = /^[{(]/, peg$c198 = {
                    type: "class",
                    value: "[{(]",
                    description: "[{(]"
                }, peg$c199 = function(ubflag, e) {
                    var r = {};
                    r.bound = ubflag == null;
                    r.line = line();
                    r.column = column();
                    r.type = "expression";
                    r.category = "jsexptext";
                    r.value = e.value;
                    return r;
                }, peg$c200 = /^[^}]/, peg$c201 = {
                    type: "class",
                    value: "[^}]",
                    description: "[^}]"
                }, peg$c202 = function(chars) {
                    return {
                        type: "invalidexpression",
                        code: chars.join(""),
                        line: line(),
                        column: column()
                    };
                }, peg$c203 = {
                    type: "other",
                    description: "white space"
                }, peg$c204 = "\r", peg$c205 = {
                    type: "literal",
                    value: "\r",
                    description: '"\\r"'
                }, peg$c206 = "\n", peg$c207 = {
                    type: "literal",
                    value: "\n",
                    description: '"\\n"'
                }, peg$c208 = /^[\t\x0B\f \xA0\uFEFF]/, peg$c209 = {
                    type: "class",
                    value: "[\\t\\x0B\\f \\xA0\\uFEFF]",
                    description: "[\\t\\x0B\\f \\xA0\\uFEFF]"
                }, peg$c210 = {
                    type: "other",
                    description: "end of line"
                }, peg$c211 = "\r\n", peg$c212 = {
                    type: "literal",
                    value: "\r\n",
                    description: '"\\r\\n"'
                }, peg$c213 = "\u2028", peg$c214 = {
                    type: "literal",
                    value: "\u2028",
                    description: '"\\u2028"'
                }, peg$c215 = "\u2029", peg$c216 = {
                    type: "literal",
                    value: "\u2029",
                    description: '"\\u2029"'
                }, peg$c217 = {
                    type: "other",
                    description: "end of statement"
                }, peg$c218 = {
                    type: "other",
                    description: "end of file"
                }, peg$c219 = {
                    type: "any",
                    description: "any character"
                }, peg$c220 = {
                    type: "other",
                    description: "comment"
                }, peg$c221 = "/*", peg$c222 = {
                    type: "literal",
                    value: "/*",
                    description: '"/*"'
                }, peg$c223 = "*/", peg$c224 = {
                    type: "literal",
                    value: "*/",
                    description: '"*/"'
                }, peg$c225 = {
                    type: "other",
                    description: "JS object reference"
                }, peg$c226 = ".", peg$c227 = {
                    type: "literal",
                    value: ".",
                    description: '"."'
                }, peg$c228 = function(pp) {
                    return pp;
                }, peg$c229 = "[", peg$c230 = {
                    type: "literal",
                    value: "[",
                    description: '"["'
                }, peg$c231 = "]", peg$c232 = {
                    type: "literal",
                    value: "]",
                    description: '"]"'
                }, peg$c233 = function(idx) {
                    return parseInt(idx.join(""), 10);
                }, peg$c234 = function(start, tail) {
                    var r = [ start ];
                    if (tail && tail.length) r = r.concat(tail);
                    return {
                        category: "objectref",
                        path: r,
                        code: r.join(".")
                    };
                }, peg$c235 = {
                    type: "other",
                    description: "identifier"
                }, peg$c236 = function(name) {
                    return name;
                }, peg$c237 = function(start, parts) {
                    return start + parts.join("");
                }, peg$c238 = "$", peg$c239 = {
                    type: "literal",
                    value: "$",
                    description: '"$"'
                }, peg$c240 = "_", peg$c241 = {
                    type: "literal",
                    value: "_",
                    description: '"_"'
                }, peg$c242 = {
                    type: "other",
                    description: "variable identifier"
                }, peg$c243 = "break", peg$c244 = {
                    type: "literal",
                    value: "break",
                    description: '"break"'
                }, peg$c245 = "case", peg$c246 = {
                    type: "literal",
                    value: "case",
                    description: '"case"'
                }, peg$c247 = "catch", peg$c248 = {
                    type: "literal",
                    value: "catch",
                    description: '"catch"'
                }, peg$c249 = "class", peg$c250 = {
                    type: "literal",
                    value: "class",
                    description: '"class"'
                }, peg$c251 = "const", peg$c252 = {
                    type: "literal",
                    value: "const",
                    description: '"const"'
                }, peg$c253 = "continue", peg$c254 = {
                    type: "literal",
                    value: "continue",
                    description: '"continue"'
                }, peg$c255 = "debugger", peg$c256 = {
                    type: "literal",
                    value: "debugger",
                    description: '"debugger"'
                }, peg$c257 = "default", peg$c258 = {
                    type: "literal",
                    value: "default",
                    description: '"default"'
                }, peg$c259 = "delete", peg$c260 = {
                    type: "literal",
                    value: "delete",
                    description: '"delete"'
                }, peg$c261 = "do", peg$c262 = {
                    type: "literal",
                    value: "do",
                    description: '"do"'
                }, peg$c263 = "enum", peg$c264 = {
                    type: "literal",
                    value: "enum",
                    description: '"enum"'
                }, peg$c265 = "export", peg$c266 = {
                    type: "literal",
                    value: "export",
                    description: '"export"'
                }, peg$c267 = "extends", peg$c268 = {
                    type: "literal",
                    value: "extends",
                    description: '"extends"'
                }, peg$c269 = "false", peg$c270 = {
                    type: "literal",
                    value: "false",
                    description: '"false"'
                }, peg$c271 = "finally", peg$c272 = {
                    type: "literal",
                    value: "finally",
                    description: '"finally"'
                }, peg$c273 = "for", peg$c274 = {
                    type: "literal",
                    value: "for",
                    description: '"for"'
                }, peg$c275 = "function", peg$c276 = {
                    type: "literal",
                    value: "function",
                    description: '"function"'
                }, peg$c277 = "get", peg$c278 = {
                    type: "literal",
                    value: "get",
                    description: '"get"'
                }, peg$c279 = "import", peg$c280 = {
                    type: "literal",
                    value: "import",
                    description: '"import"'
                }, peg$c281 = "instanceof", peg$c282 = {
                    type: "literal",
                    value: "instanceof",
                    description: '"instanceof"'
                }, peg$c283 = "in", peg$c284 = {
                    type: "literal",
                    value: "in",
                    description: '"in"'
                }, peg$c285 = "new", peg$c286 = {
                    type: "literal",
                    value: "new",
                    description: '"new"'
                }, peg$c287 = "null", peg$c288 = {
                    type: "literal",
                    value: "null",
                    description: '"null"'
                }, peg$c289 = "return", peg$c290 = {
                    type: "literal",
                    value: "return",
                    description: '"return"'
                }, peg$c291 = "set", peg$c292 = {
                    type: "literal",
                    value: "set",
                    description: '"set"'
                }, peg$c293 = "super", peg$c294 = {
                    type: "literal",
                    value: "super",
                    description: '"super"'
                }, peg$c295 = "switch", peg$c296 = {
                    type: "literal",
                    value: "switch",
                    description: '"switch"'
                }, peg$c297 = "this", peg$c298 = {
                    type: "literal",
                    value: "this",
                    description: '"this"'
                }, peg$c299 = "throw", peg$c300 = {
                    type: "literal",
                    value: "throw",
                    description: '"throw"'
                }, peg$c301 = "true", peg$c302 = {
                    type: "literal",
                    value: "true",
                    description: '"true"'
                }, peg$c303 = "try", peg$c304 = {
                    type: "literal",
                    value: "try",
                    description: '"try"'
                }, peg$c305 = "typeof", peg$c306 = {
                    type: "literal",
                    value: "typeof",
                    description: '"typeof"'
                }, peg$c307 = "var", peg$c308 = {
                    type: "literal",
                    value: "var",
                    description: '"var"'
                }, peg$c309 = "void", peg$c310 = {
                    type: "literal",
                    value: "void",
                    description: '"void"'
                }, peg$c311 = "while", peg$c312 = {
                    type: "literal",
                    value: "while",
                    description: '"while"'
                }, peg$c313 = "with", peg$c314 = {
                    type: "literal",
                    value: "with",
                    description: '"with"'
                }, peg$c315 = function() {
                    return {
                        type: "nullliteral",
                        value: null
                    };
                }, peg$c316 = function() {
                    return {
                        type: "booleanliteral",
                        value: true
                    };
                }, peg$c317 = function() {
                    return {
                        type: "booleanliteral",
                        value: false
                    };
                }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = {
                    line: 1,
                    column: 1,
                    seenCR: false
                }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
                if ("startRule" in options) {
                    if (!(options.startRule in peg$startRuleFunctions)) {
                        throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
                    }
                    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
                }
                function text() {
                    return input.substring(peg$reportedPos, peg$currPos);
                }
                function offset() {
                    return peg$reportedPos;
                }
                function line() {
                    return peg$computePosDetails(peg$reportedPos).line;
                }
                function column() {
                    return peg$computePosDetails(peg$reportedPos).column;
                }
                function expected(description) {
                    throw peg$buildException(null, [ {
                        type: "other",
                        description: description
                    } ], peg$reportedPos);
                }
                function error(message) {
                    throw peg$buildException(message, null, peg$reportedPos);
                }
                function peg$computePosDetails(pos) {
                    function advance(details, startPos, endPos) {
                        var p, ch;
                        for (p = startPos; p < endPos; p++) {
                            ch = input.charAt(p);
                            if (ch === "\n") {
                                if (!details.seenCR) {
                                    details.line++;
                                }
                                details.column = 1;
                                details.seenCR = false;
                            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                                details.line++;
                                details.column = 1;
                                details.seenCR = true;
                            } else {
                                details.column++;
                                details.seenCR = false;
                            }
                        }
                    }
                    if (peg$cachedPos !== pos) {
                        if (peg$cachedPos > pos) {
                            peg$cachedPos = 0;
                            peg$cachedPosDetails = {
                                line: 1,
                                column: 1,
                                seenCR: false
                            };
                        }
                        advance(peg$cachedPosDetails, peg$cachedPos, pos);
                        peg$cachedPos = pos;
                    }
                    return peg$cachedPosDetails;
                }
                function peg$fail(expected) {
                    if (peg$currPos < peg$maxFailPos) {
                        return;
                    }
                    if (peg$currPos > peg$maxFailPos) {
                        peg$maxFailPos = peg$currPos;
                        peg$maxFailExpected = [];
                    }
                    peg$maxFailExpected.push(expected);
                }
                function peg$buildException(message, expected, pos) {
                    function cleanupExpected(expected) {
                        var i = 1;
                        expected.sort(function(a, b) {
                            if (a.description < b.description) {
                                return -1;
                            } else if (a.description > b.description) {
                                return 1;
                            } else {
                                return 0;
                            }
                        });
                        while (i < expected.length) {
                            if (expected[i - 1] === expected[i]) {
                                expected.splice(i, 1);
                            } else {
                                i++;
                            }
                        }
                    }
                    function buildMessage(expected, found) {
                        function stringEscape(s) {
                            function hex(ch) {
                                return ch.charCodeAt(0).toString(16).toUpperCase();
                            }
                            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                                return "\\x0" + hex(ch);
                            }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                                return "\\x" + hex(ch);
                            }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                                return "\\u0" + hex(ch);
                            }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                                return "\\u" + hex(ch);
                            });
                        }
                        var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
                        for (i = 0; i < expected.length; i++) {
                            expectedDescs[i] = expected[i].description;
                        }
                        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
                        foundDesc = found ? '"' + stringEscape(found) + '"' : "end of input";
                        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
                    }
                    var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
                    if (expected !== null) {
                        cleanupExpected(expected);
                    }
                    return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
                }
                function peg$parseTemplateFile() {
                    var s0, s1, s2;
                    var key = peg$currPos * 116 + 0, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parseTemplateBlock();
                    if (s2 === peg$FAILED) {
                        s2 = peg$parseScriptBlock();
                        if (s2 === peg$FAILED) {
                            s2 = peg$parseTopLevelCommentBlock();
                            if (s2 === peg$FAILED) {
                                s2 = peg$parseTopLevelWhitespace();
                            }
                        }
                    }
                    while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        s2 = peg$parseTemplateBlock();
                        if (s2 === peg$FAILED) {
                            s2 = peg$parseScriptBlock();
                            if (s2 === peg$FAILED) {
                                s2 = peg$parseTopLevelCommentBlock();
                                if (s2 === peg$FAILED) {
                                    s2 = peg$parseTopLevelWhitespace();
                                }
                            }
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c1(s1);
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTopLevelWhitespace() {
                    var s0, s1, s2, s3, s4;
                    var key = peg$currPos * 116 + 1, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$currPos;
                    s3 = [];
                    s4 = peg$parseWhiteSpace();
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        s4 = peg$parseWhiteSpace();
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseEOL();
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s2;
                            s3 = peg$c3(s3, s4);
                            s2 = s3;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                    } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                    }
                    if (s2 !== peg$FAILED) {
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$currPos;
                            s3 = [];
                            s4 = peg$parseWhiteSpace();
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                s4 = peg$parseWhiteSpace();
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseEOL();
                                if (s4 !== peg$FAILED) {
                                    peg$reportedPos = s2;
                                    s3 = peg$c3(s3, s4);
                                    s2 = s3;
                                } else {
                                    peg$currPos = s2;
                                    s2 = peg$c2;
                                }
                            } else {
                                peg$currPos = s2;
                                s2 = peg$c2;
                            }
                        }
                    } else {
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c4(s1);
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTopLevelCommentBlock() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 2, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parseHTMLCommentBlock();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseEOL();
                            if (s3 === peg$FAILED) {
                                s3 = peg$parseEOF();
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c6(s1, s3);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c5);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseScriptBlock() {
                    var s0, s1, s2, s3, s4, s5, s6, s7;
                    var key = peg$currPos * 116 + 3, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 8) === peg$c8) {
                            s2 = peg$c8;
                            peg$currPos += 8;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c9);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseEOL();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c10;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseTextBlock();
                                if (s4 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 9) === peg$c11) {
                                        s5 = peg$c11;
                                        peg$currPos += 9;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c12);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parseEOL();
                                            if (s7 === peg$FAILED) {
                                                s7 = peg$parseEOF();
                                            }
                                            if (s7 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c13(s3, s4, s7);
                                                s0 = s1;
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c7);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTextBlock() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
                    var key = peg$currPos * 116 + 4, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$currPos;
                    s3 = peg$currPos;
                    peg$silentFails++;
                    s4 = peg$currPos;
                    s5 = peg$parse_();
                    if (s5 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 60) {
                            s6 = peg$c15;
                            peg$currPos++;
                        } else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c16);
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c17) {
                                s7 = peg$c17;
                                peg$currPos += 8;
                            } else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c18);
                                }
                            }
                            if (s7 === peg$FAILED) {
                                if (input.substr(peg$currPos, 7) === peg$c19) {
                                    s7 = peg$c19;
                                    peg$currPos += 7;
                                } else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c20);
                                    }
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s5 = [ s5, s6, s7 ];
                                s4 = s5;
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c2;
                            }
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c2;
                        }
                    } else {
                        peg$currPos = s4;
                        s4 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s4 === peg$FAILED) {
                        s3 = peg$c14;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$c2;
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$currPos;
                        peg$silentFails++;
                        s5 = peg$currPos;
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 60) {
                                s7 = peg$c15;
                                peg$currPos++;
                            } else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c16);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parse_();
                                if (s8 !== peg$FAILED) {
                                    s9 = [];
                                    if (peg$c21.test(input.charAt(peg$currPos))) {
                                        s10 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s10 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c22);
                                        }
                                    }
                                    if (s10 !== peg$FAILED) {
                                        while (s10 !== peg$FAILED) {
                                            s9.push(s10);
                                            if (peg$c21.test(input.charAt(peg$currPos))) {
                                                s10 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s10 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c22);
                                                }
                                            }
                                        }
                                    } else {
                                        s9 = peg$c2;
                                    }
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parse_();
                                        if (s10 !== peg$FAILED) {
                                            if (input.substr(peg$currPos, 8) === peg$c17) {
                                                s11 = peg$c17;
                                                peg$currPos += 8;
                                            } else {
                                                s11 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c18);
                                                }
                                            }
                                            if (s11 !== peg$FAILED) {
                                                s6 = [ s6, s7, s8, s9, s10, s11 ];
                                                s5 = s6;
                                            } else {
                                                peg$currPos = s5;
                                                s5 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s5;
                                            s5 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s5;
                                        s5 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s5;
                                    s5 = peg$c2;
                                }
                            } else {
                                peg$currPos = s5;
                                s5 = peg$c2;
                            }
                        } else {
                            peg$currPos = s5;
                            s5 = peg$c2;
                        }
                        peg$silentFails--;
                        if (s5 === peg$FAILED) {
                            s4 = peg$c14;
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c2;
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$currPos;
                            peg$silentFails++;
                            s6 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 35) {
                                s7 = peg$c23;
                                peg$currPos++;
                            } else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c24);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parse_();
                                if (s8 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 7) === peg$c25) {
                                        s9 = peg$c25;
                                        peg$currPos += 7;
                                    } else {
                                        s9 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c26);
                                        }
                                    }
                                    if (s9 !== peg$FAILED) {
                                        s7 = [ s7, s8, s9 ];
                                        s6 = s7;
                                    } else {
                                        peg$currPos = s6;
                                        s6 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s6;
                                    s6 = peg$c2;
                                }
                            } else {
                                peg$currPos = s6;
                                s6 = peg$c2;
                            }
                            peg$silentFails--;
                            if (s6 === peg$FAILED) {
                                s5 = peg$c14;
                            } else {
                                peg$currPos = s5;
                                s5 = peg$c2;
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = [];
                                if (peg$c27.test(input.charAt(peg$currPos))) {
                                    s7 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c28);
                                    }
                                }
                                while (s7 !== peg$FAILED) {
                                    s6.push(s7);
                                    if (peg$c27.test(input.charAt(peg$currPos))) {
                                        s7 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c28);
                                        }
                                    }
                                }
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parseEOL();
                                    if (s7 !== peg$FAILED) {
                                        peg$reportedPos = s2;
                                        s3 = peg$c29(s6, s7);
                                        s2 = s3;
                                    } else {
                                        peg$currPos = s2;
                                        s2 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s2;
                                    s2 = peg$c2;
                                }
                            } else {
                                peg$currPos = s2;
                                s2 = peg$c2;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                    } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                    }
                    if (s2 !== peg$FAILED) {
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$currPos;
                            s3 = peg$currPos;
                            peg$silentFails++;
                            s4 = peg$currPos;
                            s5 = peg$parse_();
                            if (s5 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 60) {
                                    s6 = peg$c15;
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c16);
                                    }
                                }
                                if (s6 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 8) === peg$c17) {
                                        s7 = peg$c17;
                                        peg$currPos += 8;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c18);
                                        }
                                    }
                                    if (s7 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 7) === peg$c19) {
                                            s7 = peg$c19;
                                            peg$currPos += 7;
                                        } else {
                                            s7 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c20);
                                            }
                                        }
                                    }
                                    if (s7 !== peg$FAILED) {
                                        s5 = [ s5, s6, s7 ];
                                        s4 = s5;
                                    } else {
                                        peg$currPos = s4;
                                        s4 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s4;
                                    s4 = peg$c2;
                                }
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c2;
                            }
                            peg$silentFails--;
                            if (s4 === peg$FAILED) {
                                s3 = peg$c14;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$currPos;
                                s6 = peg$parse_();
                                if (s6 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 60) {
                                        s7 = peg$c15;
                                        peg$currPos++;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c16);
                                        }
                                    }
                                    if (s7 !== peg$FAILED) {
                                        s8 = peg$parse_();
                                        if (s8 !== peg$FAILED) {
                                            s9 = [];
                                            if (peg$c21.test(input.charAt(peg$currPos))) {
                                                s10 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s10 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c22);
                                                }
                                            }
                                            if (s10 !== peg$FAILED) {
                                                while (s10 !== peg$FAILED) {
                                                    s9.push(s10);
                                                    if (peg$c21.test(input.charAt(peg$currPos))) {
                                                        s10 = input.charAt(peg$currPos);
                                                        peg$currPos++;
                                                    } else {
                                                        s10 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c22);
                                                        }
                                                    }
                                                }
                                            } else {
                                                s9 = peg$c2;
                                            }
                                            if (s9 !== peg$FAILED) {
                                                s10 = peg$parse_();
                                                if (s10 !== peg$FAILED) {
                                                    if (input.substr(peg$currPos, 8) === peg$c17) {
                                                        s11 = peg$c17;
                                                        peg$currPos += 8;
                                                    } else {
                                                        s11 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c18);
                                                        }
                                                    }
                                                    if (s11 !== peg$FAILED) {
                                                        s6 = [ s6, s7, s8, s9, s10, s11 ];
                                                        s5 = s6;
                                                    } else {
                                                        peg$currPos = s5;
                                                        s5 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s5;
                                                    s5 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s5;
                                                s5 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s5;
                                            s5 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s5;
                                        s5 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s5;
                                    s5 = peg$c2;
                                }
                                peg$silentFails--;
                                if (s5 === peg$FAILED) {
                                    s4 = peg$c14;
                                } else {
                                    peg$currPos = s4;
                                    s4 = peg$c2;
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$currPos;
                                    peg$silentFails++;
                                    s6 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 35) {
                                        s7 = peg$c23;
                                        peg$currPos++;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c24);
                                        }
                                    }
                                    if (s7 !== peg$FAILED) {
                                        s8 = peg$parse_();
                                        if (s8 !== peg$FAILED) {
                                            if (input.substr(peg$currPos, 7) === peg$c25) {
                                                s9 = peg$c25;
                                                peg$currPos += 7;
                                            } else {
                                                s9 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c26);
                                                }
                                            }
                                            if (s9 !== peg$FAILED) {
                                                s7 = [ s7, s8, s9 ];
                                                s6 = s7;
                                            } else {
                                                peg$currPos = s6;
                                                s6 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s6;
                                            s6 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s6;
                                        s6 = peg$c2;
                                    }
                                    peg$silentFails--;
                                    if (s6 === peg$FAILED) {
                                        s5 = peg$c14;
                                    } else {
                                        peg$currPos = s5;
                                        s5 = peg$c2;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = [];
                                        if (peg$c27.test(input.charAt(peg$currPos))) {
                                            s7 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s7 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c28);
                                            }
                                        }
                                        while (s7 !== peg$FAILED) {
                                            s6.push(s7);
                                            if (peg$c27.test(input.charAt(peg$currPos))) {
                                                s7 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s7 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c28);
                                                }
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parseEOL();
                                            if (s7 !== peg$FAILED) {
                                                peg$reportedPos = s2;
                                                s3 = peg$c29(s6, s7);
                                                s2 = s3;
                                            } else {
                                                peg$currPos = s2;
                                                s2 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s2;
                                            s2 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s2;
                                        s2 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s2;
                                    s2 = peg$c2;
                                }
                            } else {
                                peg$currPos = s2;
                                s2 = peg$c2;
                            }
                        }
                    } else {
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c4(s1);
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTemplateBlock() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 5, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parseTemplateStart();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseTemplateContent();
                        if (s2 === peg$FAILED) {
                            s2 = peg$c10;
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseTemplateEnd();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c10;
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c31(s1, s2, s3);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c30);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTemplateStart() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
                    var key = peg$currPos * 116 + 6, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 60) {
                            s2 = peg$c15;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c16);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 8) === peg$c17) {
                                    s4 = peg$c17;
                                    peg$currPos += 8;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c18);
                                    }
                                }
                                if (s4 === peg$FAILED) {
                                    s4 = peg$currPos;
                                    s5 = [];
                                    if (peg$c21.test(input.charAt(peg$currPos))) {
                                        s6 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s6 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c22);
                                        }
                                    }
                                    if (s6 !== peg$FAILED) {
                                        while (s6 !== peg$FAILED) {
                                            s5.push(s6);
                                            if (peg$c21.test(input.charAt(peg$currPos))) {
                                                s6 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s6 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c22);
                                                }
                                            }
                                        }
                                    } else {
                                        s5 = peg$c2;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            if (input.substr(peg$currPos, 8) === peg$c17) {
                                                s7 = peg$c17;
                                                peg$currPos += 8;
                                            } else {
                                                s7 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c18);
                                                }
                                            }
                                            if (s7 !== peg$FAILED) {
                                                peg$reportedPos = s4;
                                                s5 = peg$c33(s5);
                                                s4 = s5;
                                            } else {
                                                peg$currPos = s4;
                                                s4 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s4;
                                            s4 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s4;
                                        s4 = peg$c2;
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = [];
                                    s6 = peg$parseS();
                                    if (s6 !== peg$FAILED) {
                                        while (s6 !== peg$FAILED) {
                                            s5.push(s6);
                                            s6 = peg$parseS();
                                        }
                                    } else {
                                        s5 = peg$c2;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parseIdentifier();
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parseTemplateController();
                                            if (s7 === peg$FAILED) {
                                                s7 = peg$parseArgumentsDefinition();
                                                if (s7 === peg$FAILED) {
                                                    s7 = peg$parseInvalidTplArgs();
                                                }
                                            }
                                            if (s7 === peg$FAILED) {
                                                s7 = peg$c10;
                                            }
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parse_();
                                                if (s8 !== peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 62) {
                                                        s9 = peg$c34;
                                                        peg$currPos++;
                                                    } else {
                                                        s9 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c35);
                                                        }
                                                    }
                                                    if (s9 === peg$FAILED) {
                                                        s9 = peg$c10;
                                                    }
                                                    if (s9 !== peg$FAILED) {
                                                        s10 = peg$parseEOL();
                                                        if (s10 !== peg$FAILED) {
                                                            peg$reportedPos = s0;
                                                            s1 = peg$c36(s2, s3, s4, s6, s7, s9);
                                                            s0 = s1;
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$c2;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c32);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTemplateController() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8;
                    var key = peg$currPos * 116 + 7, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parseS();
                    if (s2 !== peg$FAILED) {
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$parseS();
                        }
                    } else {
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c38) {
                            s2 = peg$c38;
                            peg$currPos += 5;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c39);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = [];
                            s4 = peg$parseS();
                            if (s4 !== peg$FAILED) {
                                while (s4 !== peg$FAILED) {
                                    s3.push(s4);
                                    s4 = peg$parseS();
                                }
                            } else {
                                s3 = peg$c2;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseIdentifier();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parse_();
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 58) {
                                            s6 = peg$c40;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c41);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parse_();
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parseJSObjectRef();
                                                if (s8 !== peg$FAILED) {
                                                    peg$reportedPos = s0;
                                                    s1 = peg$c42(s4, s8);
                                                    s0 = s1;
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c37);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseArgumentsDefinition() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
                    var key = peg$currPos * 116 + 8, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 40) {
                            s2 = peg$c44;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c45);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseVarIdentifier();
                                if (s4 === peg$FAILED) {
                                    s4 = peg$c10;
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = [];
                                    s6 = peg$currPos;
                                    s7 = peg$parse_();
                                    if (s7 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                            s8 = peg$c46;
                                            peg$currPos++;
                                        } else {
                                            s8 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c47);
                                            }
                                        }
                                        if (s8 !== peg$FAILED) {
                                            s9 = peg$parse_();
                                            if (s9 !== peg$FAILED) {
                                                s10 = peg$parseVarIdentifier();
                                                if (s10 !== peg$FAILED) {
                                                    peg$reportedPos = s6;
                                                    s7 = peg$c48(s10);
                                                    s6 = s7;
                                                } else {
                                                    peg$currPos = s6;
                                                    s6 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s6;
                                                s6 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s6;
                                            s6 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s6;
                                        s6 = peg$c2;
                                    }
                                    while (s6 !== peg$FAILED) {
                                        s5.push(s6);
                                        s6 = peg$currPos;
                                        s7 = peg$parse_();
                                        if (s7 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 44) {
                                                s8 = peg$c46;
                                                peg$currPos++;
                                            } else {
                                                s8 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c47);
                                                }
                                            }
                                            if (s8 !== peg$FAILED) {
                                                s9 = peg$parse_();
                                                if (s9 !== peg$FAILED) {
                                                    s10 = peg$parseVarIdentifier();
                                                    if (s10 !== peg$FAILED) {
                                                        peg$reportedPos = s6;
                                                        s7 = peg$c48(s10);
                                                        s6 = s7;
                                                    } else {
                                                        peg$currPos = s6;
                                                        s6 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s6;
                                                    s6 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s6;
                                                s6 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s6;
                                            s6 = peg$c2;
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 41) {
                                                s7 = peg$c49;
                                                peg$currPos++;
                                            } else {
                                                s7 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c50);
                                                }
                                            }
                                            if (s7 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c51(s4, s5);
                                                s0 = s1;
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c43);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseInvalidTplArgs() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 9, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        if (input.charCodeAt(peg$currPos) === 62) {
                            s3 = peg$c34;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c35);
                            }
                        }
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = [];
                            if (peg$c27.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c28);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                while (s4 !== peg$FAILED) {
                                    s3.push(s4);
                                    if (peg$c27.test(input.charAt(peg$currPos))) {
                                        s4 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s4 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c28);
                                        }
                                    }
                                }
                            } else {
                                s3 = peg$c2;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$parseEOL();
                                peg$silentFails--;
                                if (s5 !== peg$FAILED) {
                                    peg$currPos = s4;
                                    s4 = peg$c14;
                                } else {
                                    s4 = peg$c2;
                                }
                                if (s4 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c52(s3);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTemplateEnd() {
                    var s0, s1, s2, s3, s4, s5, s6;
                    var key = peg$currPos * 116 + 10, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 10) === peg$c54) {
                            s2 = peg$c54;
                            peg$currPos += 10;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c55);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 62) {
                                    s4 = peg$c34;
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c35);
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parse_();
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parseEOL();
                                        if (s6 === peg$FAILED) {
                                            s6 = peg$parseEOF();
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c56();
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c53);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTemplateContent() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 11, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parseTplTextBlock();
                        if (s3 === peg$FAILED) {
                            s3 = peg$parseCommentBlock();
                            if (s3 === peg$FAILED) {
                                s3 = peg$parseHTMLCommentBlock();
                                if (s3 === peg$FAILED) {
                                    s3 = peg$parseIfBlock();
                                    if (s3 === peg$FAILED) {
                                        s3 = peg$parseElseIfBlock();
                                        if (s3 === peg$FAILED) {
                                            s3 = peg$parseElseBlock();
                                            if (s3 === peg$FAILED) {
                                                s3 = peg$parseEndIfBlock();
                                                if (s3 === peg$FAILED) {
                                                    s3 = peg$parseForeachBlock();
                                                    if (s3 === peg$FAILED) {
                                                        s3 = peg$parseEndForeachBlock();
                                                        if (s3 === peg$FAILED) {
                                                            s3 = peg$parseHTMLElement();
                                                            if (s3 === peg$FAILED) {
                                                                s3 = peg$parseEndHTMLElement();
                                                                if (s3 === peg$FAILED) {
                                                                    s3 = peg$parseHspComponent();
                                                                    if (s3 === peg$FAILED) {
                                                                        s3 = peg$parseEndHspComponent();
                                                                        if (s3 === peg$FAILED) {
                                                                            s3 = peg$parseHspCptAttribute();
                                                                            if (s3 === peg$FAILED) {
                                                                                s3 = peg$parseEndHspCptAttribute();
                                                                                if (s3 === peg$FAILED) {
                                                                                    s3 = peg$parseLetBlock();
                                                                                    if (s3 === peg$FAILED) {
                                                                                        s3 = peg$parseLogBlock();
                                                                                        if (s3 === peg$FAILED) {
                                                                                            s3 = peg$parseExpressionTextBlock();
                                                                                            if (s3 === peg$FAILED) {
                                                                                                s3 = peg$parseInvalidHTMLElement();
                                                                                                if (s3 === peg$FAILED) {
                                                                                                    s3 = peg$parseInvalidBlock();
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parseTplTextBlock();
                            if (s3 === peg$FAILED) {
                                s3 = peg$parseCommentBlock();
                                if (s3 === peg$FAILED) {
                                    s3 = peg$parseHTMLCommentBlock();
                                    if (s3 === peg$FAILED) {
                                        s3 = peg$parseIfBlock();
                                        if (s3 === peg$FAILED) {
                                            s3 = peg$parseElseIfBlock();
                                            if (s3 === peg$FAILED) {
                                                s3 = peg$parseElseBlock();
                                                if (s3 === peg$FAILED) {
                                                    s3 = peg$parseEndIfBlock();
                                                    if (s3 === peg$FAILED) {
                                                        s3 = peg$parseForeachBlock();
                                                        if (s3 === peg$FAILED) {
                                                            s3 = peg$parseEndForeachBlock();
                                                            if (s3 === peg$FAILED) {
                                                                s3 = peg$parseHTMLElement();
                                                                if (s3 === peg$FAILED) {
                                                                    s3 = peg$parseEndHTMLElement();
                                                                    if (s3 === peg$FAILED) {
                                                                        s3 = peg$parseHspComponent();
                                                                        if (s3 === peg$FAILED) {
                                                                            s3 = peg$parseEndHspComponent();
                                                                            if (s3 === peg$FAILED) {
                                                                                s3 = peg$parseHspCptAttribute();
                                                                                if (s3 === peg$FAILED) {
                                                                                    s3 = peg$parseEndHspCptAttribute();
                                                                                    if (s3 === peg$FAILED) {
                                                                                        s3 = peg$parseLetBlock();
                                                                                        if (s3 === peg$FAILED) {
                                                                                            s3 = peg$parseLogBlock();
                                                                                            if (s3 === peg$FAILED) {
                                                                                                s3 = peg$parseExpressionTextBlock();
                                                                                                if (s3 === peg$FAILED) {
                                                                                                    s3 = peg$parseInvalidHTMLElement();
                                                                                                    if (s3 === peg$FAILED) {
                                                                                                        s3 = peg$parseInvalidBlock();
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c58(s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c57);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTplTextBlock() {
                    var s0, s1, s2;
                    var key = peg$currPos * 116 + 12, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parseTplTextChar();
                    if (s2 !== peg$FAILED) {
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$parseTplTextChar();
                        }
                    } else {
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c60(s1);
                    }
                    s0 = s1;
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c59);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTplTextChar() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 13, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c62) {
                        s1 = peg$c62;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c63);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c64();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c65) {
                            s1 = peg$c65;
                            peg$currPos += 2;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c66);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c67();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 2) === peg$c68) {
                                s1 = peg$c68;
                                peg$currPos += 2;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c69);
                                }
                            }
                            if (s1 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c70();
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parseEOL();
                                if (s1 !== peg$FAILED) {
                                    s2 = peg$currPos;
                                    peg$silentFails++;
                                    s3 = peg$parseTemplateEnd();
                                    peg$silentFails--;
                                    if (s3 !== peg$FAILED) {
                                        peg$currPos = s2;
                                        s2 = peg$c14;
                                    } else {
                                        s2 = peg$c2;
                                    }
                                    if (s2 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c71();
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parseEOL();
                                    if (s1 !== peg$FAILED) {
                                        s2 = peg$parse_();
                                        if (s2 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c72();
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.charCodeAt(peg$currPos) === 35) {
                                            s1 = peg$c23;
                                            peg$currPos++;
                                        } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c24);
                                            }
                                        }
                                        if (s1 !== peg$FAILED) {
                                            s2 = peg$currPos;
                                            peg$silentFails++;
                                            s3 = peg$currPos;
                                            s4 = peg$parse_();
                                            if (s4 !== peg$FAILED) {
                                                if (input.substr(peg$currPos, 9) === peg$c73) {
                                                    s5 = peg$c73;
                                                    peg$currPos += 9;
                                                } else {
                                                    s5 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c74);
                                                    }
                                                }
                                                if (s5 !== peg$FAILED) {
                                                    s4 = [ s4, s5 ];
                                                    s3 = s4;
                                                } else {
                                                    peg$currPos = s3;
                                                    s3 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s3;
                                                s3 = peg$c2;
                                            }
                                            peg$silentFails--;
                                            if (s3 === peg$FAILED) {
                                                s2 = peg$c14;
                                            } else {
                                                peg$currPos = s2;
                                                s2 = peg$c2;
                                            }
                                            if (s2 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c75();
                                                s0 = s1;
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            if (input.charCodeAt(peg$currPos) === 47) {
                                                s1 = peg$c76;
                                                peg$currPos++;
                                            } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c77);
                                                }
                                            }
                                            if (s1 !== peg$FAILED) {
                                                s2 = peg$currPos;
                                                peg$silentFails++;
                                                if (input.charCodeAt(peg$currPos) === 47) {
                                                    s3 = peg$c76;
                                                    peg$currPos++;
                                                } else {
                                                    s3 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c77);
                                                    }
                                                }
                                                peg$silentFails--;
                                                if (s3 === peg$FAILED) {
                                                    s2 = peg$c14;
                                                } else {
                                                    peg$currPos = s2;
                                                    s2 = peg$c2;
                                                }
                                                if (s2 !== peg$FAILED) {
                                                    peg$reportedPos = s0;
                                                    s1 = peg$c78();
                                                    s0 = s1;
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                            if (s0 === peg$FAILED) {
                                                s0 = peg$currPos;
                                                if (input.substr(peg$currPos, 2) === peg$c79) {
                                                    s1 = peg$c79;
                                                    peg$currPos += 2;
                                                } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c80);
                                                    }
                                                }
                                                if (s1 !== peg$FAILED) {
                                                    peg$reportedPos = s0;
                                                    s1 = peg$c78();
                                                }
                                                s0 = s1;
                                                if (s0 === peg$FAILED) {
                                                    s0 = peg$currPos;
                                                    if (input.substr(peg$currPos, 3) === peg$c81) {
                                                        s1 = peg$c81;
                                                        peg$currPos += 3;
                                                    } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c82);
                                                        }
                                                    }
                                                    if (s1 !== peg$FAILED) {
                                                        peg$reportedPos = s0;
                                                        s1 = peg$c83();
                                                    }
                                                    s0 = s1;
                                                    if (s0 === peg$FAILED) {
                                                        s0 = peg$currPos;
                                                        if (input.substr(peg$currPos, 2) === peg$c84) {
                                                            s1 = peg$c84;
                                                            peg$currPos += 2;
                                                        } else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                                peg$fail(peg$c85);
                                                            }
                                                        }
                                                        if (s1 !== peg$FAILED) {
                                                            peg$reportedPos = s0;
                                                            s1 = peg$c86();
                                                        }
                                                        s0 = s1;
                                                        if (s0 === peg$FAILED) {
                                                            if (peg$c87.test(input.charAt(peg$currPos))) {
                                                                s0 = input.charAt(peg$currPos);
                                                                peg$currPos++;
                                                            } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c88);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c61);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseInvalidBlock() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 14, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        if (peg$c91.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c92);
                            }
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            if (peg$c91.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c92);
                                }
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                                s3 = peg$c93;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c94);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c95(s2);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseIfBlock() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8;
                    var key = peg$currPos * 116 + 15, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 3) === peg$c97) {
                                s3 = peg$c97;
                                peg$currPos += 3;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c98);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseIfCondWithBrackets();
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$parseCoreExpText();
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 125) {
                                                s7 = peg$c93;
                                                peg$currPos++;
                                            } else {
                                                s7 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c94);
                                                }
                                            }
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parseEOS();
                                                if (s8 === peg$FAILED) {
                                                    s8 = peg$c10;
                                                }
                                                if (s8 !== peg$FAILED) {
                                                    peg$reportedPos = s0;
                                                    s1 = peg$c99(s5);
                                                    s0 = s1;
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c96);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseIfCondWithBrackets() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 16, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 40) {
                        s1 = peg$c44;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c45);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseCoreExpText();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s3 = peg$c49;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c50);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c100(s2);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseElseIfBlock() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
                    var key = peg$currPos * 116 + 17, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c102) {
                                s3 = peg$c102;
                                peg$currPos += 5;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c103);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c104) {
                                        s5 = peg$c104;
                                        peg$currPos += 2;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c105);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parseIfCondWithBrackets();
                                            if (s7 === peg$FAILED) {
                                                s7 = peg$parseCoreExpText();
                                            }
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parse_();
                                                if (s8 !== peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 125) {
                                                        s9 = peg$c93;
                                                        peg$currPos++;
                                                    } else {
                                                        s9 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c94);
                                                        }
                                                    }
                                                    if (s9 !== peg$FAILED) {
                                                        s10 = peg$parseEOS();
                                                        if (s10 === peg$FAILED) {
                                                            s10 = peg$c10;
                                                        }
                                                        if (s10 !== peg$FAILED) {
                                                            peg$reportedPos = s0;
                                                            s1 = peg$c106(s7);
                                                            s0 = s1;
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$c2;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c101);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseElseBlock() {
                    var s0, s1, s2, s3, s4, s5, s6;
                    var key = peg$currPos * 116 + 18, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c107) {
                                s3 = peg$c107;
                                peg$currPos += 4;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c108);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 125) {
                                        s5 = peg$c93;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c94);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parseEOS();
                                        if (s6 === peg$FAILED) {
                                            s6 = peg$c10;
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c109();
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEndIfBlock() {
                    var s0, s1, s2, s3, s4, s5, s6;
                    var key = peg$currPos * 116 + 19, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 3) === peg$c110) {
                                s3 = peg$c110;
                                peg$currPos += 3;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c111);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 125) {
                                        s5 = peg$c93;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c94);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parseEOS();
                                        if (s6 === peg$FAILED) {
                                            s6 = peg$c10;
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c112();
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseCommentBlock() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 20, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c113) {
                            s2 = peg$c113;
                            peg$currPos += 2;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c114);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = [];
                            if (peg$c115.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c116);
                                }
                            }
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                if (peg$c115.test(input.charAt(peg$currPos))) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c116);
                                    }
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$currPos;
                                peg$silentFails++;
                                s5 = peg$parseEOL();
                                peg$silentFails--;
                                if (s5 !== peg$FAILED) {
                                    peg$currPos = s4;
                                    s4 = peg$c14;
                                } else {
                                    s4 = peg$c2;
                                }
                                if (s4 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c117(s3);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLCommentBlock() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 21, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c118) {
                        s1 = peg$c118;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c119);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parseHTMLCommentChar();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parseHTMLCommentChar();
                        }
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 3) === peg$c120) {
                                s3 = peg$c120;
                                peg$currPos += 3;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c121);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c117(s2);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLCommentChar() {
                    var s0, s1, s2, s3, s4;
                    var key = peg$currPos * 116 + 22, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    peg$silentFails++;
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s2 = peg$c122;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c123);
                        }
                    }
                    peg$silentFails--;
                    if (s2 === peg$FAILED) {
                        s1 = peg$c14;
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                            s2 = peg$c122;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c123);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$currPos;
                            peg$silentFails++;
                            if (input.charCodeAt(peg$currPos) === 62) {
                                s4 = peg$c34;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c35);
                                }
                            }
                            peg$silentFails--;
                            if (s4 === peg$FAILED) {
                                s3 = peg$c14;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c124();
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 45) {
                            s1 = peg$c122;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c123);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$currPos;
                            peg$silentFails++;
                            if (input.substr(peg$currPos, 2) === peg$c125) {
                                s3 = peg$c125;
                                peg$currPos += 2;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c126);
                                }
                            }
                            peg$silentFails--;
                            if (s3 === peg$FAILED) {
                                s2 = peg$c14;
                            } else {
                                peg$currPos = s2;
                                s2 = peg$c2;
                            }
                            if (s2 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c124();
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$currPos;
                            peg$silentFails++;
                            if (input.substr(peg$currPos, 2) === peg$c127) {
                                s2 = peg$c127;
                                peg$currPos += 2;
                            } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c128);
                                }
                            }
                            peg$silentFails--;
                            if (s2 === peg$FAILED) {
                                s1 = peg$c14;
                            } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                            }
                            if (s1 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 62) {
                                    s2 = peg$c34;
                                    peg$currPos++;
                                } else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c35);
                                    }
                                }
                                if (s2 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c129();
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                            if (s0 === peg$FAILED) {
                                if (peg$c130.test(input.charAt(peg$currPos))) {
                                    s0 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c131);
                                    }
                                }
                            }
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseForeachBlock() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
                    var key = peg$currPos * 116 + 23, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c132) {
                                s3 = peg$c132;
                                peg$currPos += 8;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c133);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseForeachArgs();
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$currPos;
                                        if (input.charCodeAt(peg$currPos) === 40) {
                                            s6 = peg$c44;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c45);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parse_();
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parseForeachArgs();
                                                if (s8 !== peg$FAILED) {
                                                    s9 = peg$parse_();
                                                    if (s9 !== peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 41) {
                                                            s10 = peg$c49;
                                                            peg$currPos++;
                                                        } else {
                                                            s10 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                                peg$fail(peg$c50);
                                                            }
                                                        }
                                                        if (s10 !== peg$FAILED) {
                                                            peg$reportedPos = s5;
                                                            s6 = peg$c134(s8);
                                                            s5 = s6;
                                                        } else {
                                                            peg$currPos = s5;
                                                            s5 = peg$c2;
                                                        }
                                                    } else {
                                                        peg$currPos = s5;
                                                        s5 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s5;
                                                    s5 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s5;
                                                s5 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s5;
                                            s5 = peg$c2;
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 125) {
                                                s7 = peg$c93;
                                                peg$currPos++;
                                            } else {
                                                s7 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c94);
                                                }
                                            }
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parseEOS();
                                                if (s8 === peg$FAILED) {
                                                    s8 = peg$c10;
                                                }
                                                if (s8 !== peg$FAILED) {
                                                    peg$reportedPos = s0;
                                                    s1 = peg$c135(s5);
                                                    s0 = s1;
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseForeachArgs() {
                    var s0;
                    var key = peg$currPos * 116 + 24, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$parseForeachArgs1();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseForeachArgs2();
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseForeachArgs1() {
                    var s0, s1, s2, s3, s4, s5, s6;
                    var key = peg$currPos * 116 + 25, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$parseVarIdentifier();
                    if (s1 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 32) {
                            s2 = peg$c136;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c137);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 3) === peg$c138) {
                                    s4 = peg$c138;
                                    peg$currPos += 3;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c139);
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parse_();
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parseCoreExpText();
                                        if (s6 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c140(s1, s6);
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseForeachArgs2() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
                    var key = peg$currPos * 116 + 26, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$parseVarIdentifier();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s3 = peg$c46;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c47);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseVarIdentifier();
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 32) {
                                            s6 = peg$c136;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c137);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parse_();
                                            if (s7 !== peg$FAILED) {
                                                if (input.substr(peg$currPos, 3) === peg$c138) {
                                                    s8 = peg$c138;
                                                    peg$currPos += 3;
                                                } else {
                                                    s8 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c139);
                                                    }
                                                }
                                                if (s8 !== peg$FAILED) {
                                                    s9 = peg$parse_();
                                                    if (s9 !== peg$FAILED) {
                                                        s10 = peg$parseCoreExpText();
                                                        if (s10 !== peg$FAILED) {
                                                            peg$reportedPos = s0;
                                                            s1 = peg$c141(s1, s5, s10);
                                                            s0 = s1;
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$c2;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEndForeachBlock() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 27, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c142) {
                                s3 = peg$c142;
                                peg$currPos += 8;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c143);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 125) {
                                        s5 = peg$c93;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c94);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c144();
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLElement() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8;
                    var key = peg$currPos * 116 + 28, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 60) {
                        s1 = peg$c15;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c16);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$currPos;
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c17) {
                                s5 = peg$c17;
                                peg$currPos += 8;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c18);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s4 = [ s4, s5 ];
                                s3 = s4;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c2;
                        }
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseHTMLName();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseHTMLElementAttributes();
                                if (s4 === peg$FAILED) {
                                    s4 = peg$c10;
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseS();
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c10;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 47) {
                                            s6 = peg$c76;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c77);
                                            }
                                        }
                                        if (s6 === peg$FAILED) {
                                            s6 = peg$c10;
                                        }
                                        if (s6 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 62) {
                                                s7 = peg$c34;
                                                peg$currPos++;
                                            } else {
                                                s7 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c35);
                                                }
                                            }
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parseEOS();
                                                if (s8 === peg$FAILED) {
                                                    s8 = peg$c10;
                                                }
                                                if (s8 !== peg$FAILED) {
                                                    peg$reportedPos = s0;
                                                    s1 = peg$c145(s3, s4, s6);
                                                    s0 = s1;
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLElementAttributes() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 29, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = [];
                    s1 = peg$currPos;
                    s2 = peg$parseS();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseHTMLAttribute();
                        if (s3 !== peg$FAILED) {
                            peg$reportedPos = s1;
                            s2 = peg$c146(s3);
                            s1 = s2;
                        } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                        }
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    while (s1 !== peg$FAILED) {
                        s0.push(s1);
                        s1 = peg$currPos;
                        s2 = peg$parseS();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseHTMLAttribute();
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s1;
                                s2 = peg$c146(s3);
                                s1 = s2;
                            } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                            }
                        } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEndHTMLElement() {
                    var s0, s1, s2, s3, s4, s5, s6;
                    var key = peg$currPos * 116 + 30, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c147) {
                        s1 = peg$c147;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c148);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$currPos;
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c17) {
                                s5 = peg$c17;
                                peg$currPos += 8;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c18);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s4 = [ s4, s5 ];
                                s3 = s4;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c2;
                        }
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseHTMLName();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseS();
                                if (s4 === peg$FAILED) {
                                    s4 = peg$c10;
                                }
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 62) {
                                        s5 = peg$c34;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c35);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parseEOS();
                                        if (s6 === peg$FAILED) {
                                            s6 = peg$c10;
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c149(s3);
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHspComponent() {
                    var s0, s1, s2, s3, s4, s5, s6, s7;
                    var key = peg$currPos * 116 + 31, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c150) {
                        s1 = peg$c150;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c151);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseJSObjectRef();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseHTMLElementAttributes();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c10;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseS();
                                if (s4 === peg$FAILED) {
                                    s4 = peg$c10;
                                }
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 47) {
                                        s5 = peg$c76;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c77);
                                        }
                                    }
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c10;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 62) {
                                            s6 = peg$c34;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c35);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parseEOS();
                                            if (s7 === peg$FAILED) {
                                                s7 = peg$c10;
                                            }
                                            if (s7 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c152(s2, s3, s5);
                                                s0 = s1;
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEndHspComponent() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 32, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c153) {
                        s1 = peg$c153;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c154);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseJSObjectRef();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseS();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c10;
                            }
                            if (s3 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 62) {
                                    s4 = peg$c34;
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c35);
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseEOS();
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c10;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c155(s2);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHspCptAttribute() {
                    var s0, s1, s2, s3, s4, s5, s6, s7;
                    var key = peg$currPos * 116 + 33, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c156) {
                        s1 = peg$c156;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c157);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseVarIdentifier();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseHTMLElementAttributes();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c10;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseS();
                                if (s4 === peg$FAILED) {
                                    s4 = peg$c10;
                                }
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 47) {
                                        s5 = peg$c76;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c77);
                                        }
                                    }
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c10;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 62) {
                                            s6 = peg$c34;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c35);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parseEOS();
                                            if (s7 === peg$FAILED) {
                                                s7 = peg$c10;
                                            }
                                            if (s7 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c158(s2, s3, s5);
                                                s0 = s1;
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEndHspCptAttribute() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 34, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c159) {
                        s1 = peg$c159;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c160);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseVarIdentifier();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseS();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c10;
                            }
                            if (s3 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 62) {
                                    s4 = peg$c34;
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c35);
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseEOS();
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c10;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c161(s2);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseInvalidHTMLElement() {
                    var s0, s1, s2, s3, s4, s5, s6, s7;
                    var key = peg$currPos * 116 + 35, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 60) {
                        s1 = peg$c15;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c16);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$currPos;
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 9) === peg$c73) {
                                s5 = peg$c73;
                                peg$currPos += 9;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c74);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parse_();
                                if (s6 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 62) {
                                        s7 = peg$c34;
                                        peg$currPos++;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c35);
                                        }
                                    }
                                    if (s7 !== peg$FAILED) {
                                        s4 = [ s4, s5, s6, s7 ];
                                        s3 = s4;
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c2;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c2;
                        }
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = [];
                            if (peg$c115.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c116);
                                }
                            }
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                if (peg$c115.test(input.charAt(peg$currPos))) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c116);
                                    }
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseEOL();
                                if (s4 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c162(s3);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLName() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 36, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (peg$c163.test(input.charAt(peg$currPos))) {
                        s1 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c164);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        if (peg$c163.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c164);
                            }
                        }
                        if (s3 === peg$FAILED) {
                            if (peg$c165.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c166);
                                }
                            }
                            if (s3 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 45) {
                                    s3 = peg$c122;
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c123);
                                    }
                                }
                            }
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            if (peg$c163.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c164);
                                }
                            }
                            if (s3 === peg$FAILED) {
                                if (peg$c165.test(input.charAt(peg$currPos))) {
                                    s3 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c166);
                                    }
                                }
                                if (s3 === peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 45) {
                                        s3 = peg$c122;
                                        peg$currPos++;
                                    } else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c123);
                                        }
                                    }
                                }
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c167(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLAttName() {
                    var s0, s1, s2, s3, s4, s5, s6;
                    var key = peg$currPos * 116 + 37, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (peg$c168.test(input.charAt(peg$currPos))) {
                        s1 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c169);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        if (peg$c170.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c171);
                            }
                        }
                        if (s3 === peg$FAILED) {
                            if (peg$c165.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c166);
                                }
                            }
                            if (s3 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 45) {
                                    s3 = peg$c122;
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c123);
                                    }
                                }
                            }
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            if (peg$c170.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c171);
                                }
                            }
                            if (s3 === peg$FAILED) {
                                if (peg$c165.test(input.charAt(peg$currPos))) {
                                    s3 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c166);
                                    }
                                }
                                if (s3 === peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 45) {
                                        s3 = peg$c122;
                                        peg$currPos++;
                                    } else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c123);
                                        }
                                    }
                                }
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 58) {
                                s4 = peg$c40;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c41);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = [];
                                if (peg$c170.test(input.charAt(peg$currPos))) {
                                    s6 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c171);
                                    }
                                }
                                if (s6 === peg$FAILED) {
                                    if (peg$c165.test(input.charAt(peg$currPos))) {
                                        s6 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s6 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c166);
                                        }
                                    }
                                    if (s6 === peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 45) {
                                            s6 = peg$c122;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c123);
                                            }
                                        }
                                    }
                                }
                                if (s6 !== peg$FAILED) {
                                    while (s6 !== peg$FAILED) {
                                        s5.push(s6);
                                        if (peg$c170.test(input.charAt(peg$currPos))) {
                                            s6 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c171);
                                            }
                                        }
                                        if (s6 === peg$FAILED) {
                                            if (peg$c165.test(input.charAt(peg$currPos))) {
                                                s6 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s6 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c166);
                                                }
                                            }
                                            if (s6 === peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 45) {
                                                    s6 = peg$c122;
                                                    peg$currPos++;
                                                } else {
                                                    s6 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c123);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    s5 = peg$c2;
                                }
                                if (s5 !== peg$FAILED) {
                                    peg$reportedPos = s3;
                                    s4 = peg$c172(s5);
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c2;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                            if (s3 === peg$FAILED) {
                                s3 = peg$c10;
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c173(s1, s2, s3);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLAttribute() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8;
                    var key = peg$currPos * 116 + 38, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$parseHTMLAttName();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        s3 = peg$parse_();
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 61) {
                                s4 = peg$c174;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c175);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parse_();
                                if (s5 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 34) {
                                        s6 = peg$c176;
                                        peg$currPos++;
                                    } else {
                                        s6 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c177);
                                        }
                                    }
                                    if (s6 !== peg$FAILED) {
                                        s7 = peg$parseHTMLAttributeValue();
                                        if (s7 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 34) {
                                                s8 = peg$c176;
                                                peg$currPos++;
                                            } else {
                                                s8 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c177);
                                                }
                                            }
                                            if (s8 !== peg$FAILED) {
                                                peg$reportedPos = s2;
                                                s3 = peg$c178(s7);
                                                s2 = s3;
                                            } else {
                                                peg$currPos = s2;
                                                s2 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s2;
                                            s2 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s2;
                                        s2 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s2;
                                    s2 = peg$c2;
                                }
                            } else {
                                peg$currPos = s2;
                                s2 = peg$c2;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 === peg$FAILED) {
                            s2 = peg$c10;
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c179(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLAttributeValue() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 39, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = [];
                    s1 = peg$parseHTMLAttributeText();
                    if (s1 === peg$FAILED) {
                        s1 = peg$parseExpressionTextBlock();
                    }
                    while (s1 !== peg$FAILED) {
                        s0.push(s1);
                        s1 = peg$parseHTMLAttributeText();
                        if (s1 === peg$FAILED) {
                            s1 = peg$parseExpressionTextBlock();
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLAttributeText() {
                    var s0, s1, s2;
                    var key = peg$currPos * 116 + 40, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parseHTMLAttributeChar();
                    if (s2 !== peg$FAILED) {
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$parseHTMLAttributeChar();
                        }
                    } else {
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c180(s1);
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseHTMLAttributeChar() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 41, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c62) {
                        s1 = peg$c62;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c63);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c64();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c181) {
                            s1 = peg$c181;
                            peg$currPos += 2;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c182);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c183();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parseEOL();
                            if (s1 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c184();
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                                if (peg$c185.test(input.charAt(peg$currPos))) {
                                    s0 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c186);
                                    }
                                }
                            }
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseLogBlock() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
                    var key = peg$currPos * 116 + 42, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c187) {
                                s3 = peg$c187;
                                peg$currPos += 4;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c188);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseCoreExpText();
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            s7 = [];
                                            s8 = peg$currPos;
                                            if (input.charCodeAt(peg$currPos) === 44) {
                                                s9 = peg$c46;
                                                peg$currPos++;
                                            } else {
                                                s9 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c47);
                                                }
                                            }
                                            if (s9 !== peg$FAILED) {
                                                s10 = peg$parse_();
                                                if (s10 !== peg$FAILED) {
                                                    s11 = peg$parseCoreExpText();
                                                    if (s11 !== peg$FAILED) {
                                                        s9 = [ s9, s10, s11 ];
                                                        s8 = s9;
                                                    } else {
                                                        peg$currPos = s8;
                                                        s8 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s8;
                                                    s8 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s8;
                                                s8 = peg$c2;
                                            }
                                            while (s8 !== peg$FAILED) {
                                                s7.push(s8);
                                                s8 = peg$currPos;
                                                if (input.charCodeAt(peg$currPos) === 44) {
                                                    s9 = peg$c46;
                                                    peg$currPos++;
                                                } else {
                                                    s9 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c47);
                                                    }
                                                }
                                                if (s9 !== peg$FAILED) {
                                                    s10 = peg$parse_();
                                                    if (s10 !== peg$FAILED) {
                                                        s11 = peg$parseCoreExpText();
                                                        if (s11 !== peg$FAILED) {
                                                            s9 = [ s9, s10, s11 ];
                                                            s8 = s9;
                                                        } else {
                                                            peg$currPos = s8;
                                                            s8 = peg$c2;
                                                        }
                                                    } else {
                                                        peg$currPos = s8;
                                                        s8 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s8;
                                                    s8 = peg$c2;
                                                }
                                            }
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parse_();
                                                if (s8 !== peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 125) {
                                                        s9 = peg$c93;
                                                        peg$currPos++;
                                                    } else {
                                                        s9 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c94);
                                                        }
                                                    }
                                                    if (s9 !== peg$FAILED) {
                                                        s10 = peg$parseEOS();
                                                        if (s10 === peg$FAILED) {
                                                            s10 = peg$c10;
                                                        }
                                                        if (s10 !== peg$FAILED) {
                                                            peg$reportedPos = s0;
                                                            s1 = peg$c189(s5, s7);
                                                            s0 = s1;
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$c2;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseLetBlock() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
                    var key = peg$currPos * 116 + 43, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c190) {
                                s3 = peg$c190;
                                peg$currPos += 4;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c191);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseCoreExpText();
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse__();
                                        if (s6 !== peg$FAILED) {
                                            s7 = [];
                                            s8 = peg$currPos;
                                            if (input.charCodeAt(peg$currPos) === 44) {
                                                s9 = peg$c46;
                                                peg$currPos++;
                                            } else {
                                                s9 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c47);
                                                }
                                            }
                                            if (s9 !== peg$FAILED) {
                                                s10 = peg$parse__();
                                                if (s10 !== peg$FAILED) {
                                                    s11 = peg$parseCoreExpText();
                                                    if (s11 !== peg$FAILED) {
                                                        s9 = [ s9, s10, s11 ];
                                                        s8 = s9;
                                                    } else {
                                                        peg$currPos = s8;
                                                        s8 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s8;
                                                    s8 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s8;
                                                s8 = peg$c2;
                                            }
                                            while (s8 !== peg$FAILED) {
                                                s7.push(s8);
                                                s8 = peg$currPos;
                                                if (input.charCodeAt(peg$currPos) === 44) {
                                                    s9 = peg$c46;
                                                    peg$currPos++;
                                                } else {
                                                    s9 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c47);
                                                    }
                                                }
                                                if (s9 !== peg$FAILED) {
                                                    s10 = peg$parse__();
                                                    if (s10 !== peg$FAILED) {
                                                        s11 = peg$parseCoreExpText();
                                                        if (s11 !== peg$FAILED) {
                                                            s9 = [ s9, s10, s11 ];
                                                            s8 = s9;
                                                        } else {
                                                            peg$currPos = s8;
                                                            s8 = peg$c2;
                                                        }
                                                    } else {
                                                        peg$currPos = s8;
                                                        s8 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s8;
                                                    s8 = peg$c2;
                                                }
                                            }
                                            if (s7 !== peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 125) {
                                                    s8 = peg$c93;
                                                    peg$currPos++;
                                                } else {
                                                    s8 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c94);
                                                    }
                                                }
                                                if (s8 !== peg$FAILED) {
                                                    s9 = peg$parseEOS();
                                                    if (s9 === peg$FAILED) {
                                                        s9 = peg$c10;
                                                    }
                                                    if (s9 !== peg$FAILED) {
                                                        peg$reportedPos = s0;
                                                        s1 = peg$c192(s5, s7);
                                                        s0 = s1;
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c2;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c2;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c2;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseCoreExpText() {
                    var s0, s1, s2;
                    var key = peg$currPos * 116 + 44, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parseCoreExpTextNoBrackets();
                    if (s2 === peg$FAILED) {
                        s2 = peg$parseCoreExpTextInCurly();
                        if (s2 === peg$FAILED) {
                            s2 = peg$parseCoreExpTextInBrackets();
                            if (s2 === peg$FAILED) {
                                s2 = peg$parseInvalidCoreExpText();
                            }
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$parseCoreExpTextNoBrackets();
                            if (s2 === peg$FAILED) {
                                s2 = peg$parseCoreExpTextInCurly();
                                if (s2 === peg$FAILED) {
                                    s2 = peg$parseCoreExpTextInBrackets();
                                    if (s2 === peg$FAILED) {
                                        s2 = peg$parseInvalidCoreExpText();
                                    }
                                }
                            }
                        }
                    } else {
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c193(s1);
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseCoreExpTextNoBrackets() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 45, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    peg$silentFails++;
                    if (input.substr(peg$currPos, 9) === peg$c73) {
                        s2 = peg$c73;
                        peg$currPos += 9;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c74);
                        }
                    }
                    peg$silentFails--;
                    if (s2 === peg$FAILED) {
                        s1 = peg$c14;
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        if (peg$c194.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c195);
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            while (s3 !== peg$FAILED) {
                                s2.push(s3);
                                if (peg$c194.test(input.charAt(peg$currPos))) {
                                    s3 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c195);
                                    }
                                }
                            }
                        } else {
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c33(s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseCoreExpTextInCurly() {
                    var s0, s1, s2, s3, s4;
                    var key = peg$currPos * 116 + 46, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s2 = peg$c89;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseCoreExpText();
                        if (s4 === peg$FAILED) {
                            s4 = peg$c10;
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s3;
                            s4 = peg$c196(s4);
                        }
                        s3 = s4;
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                                s4 = peg$c93;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c94);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s2 = [ s2, s3, s4 ];
                                s1 = s2;
                            } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                            }
                        } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                        }
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c33(s1);
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseCoreExpTextInBrackets() {
                    var s0, s1, s2, s3, s4;
                    var key = peg$currPos * 116 + 47, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 40) {
                        s2 = peg$c44;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c45);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseCoreExpText();
                        if (s4 === peg$FAILED) {
                            s4 = peg$c10;
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s3;
                            s4 = peg$c196(s4);
                        }
                        s3 = s4;
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s4 = peg$c49;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c50);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s2 = [ s2, s3, s4 ];
                                s1 = s2;
                            } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                            }
                        } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                        }
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c33(s1);
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseInvalidCoreExpText() {
                    var s0, s1, s2, s3, s4;
                    var key = peg$currPos * 116 + 48, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    if (peg$c197.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c198);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseCoreExpText();
                        if (s4 === peg$FAILED) {
                            s4 = peg$c10;
                        }
                        if (s4 !== peg$FAILED) {
                            peg$reportedPos = s3;
                            s4 = peg$c196(s4);
                        }
                        s3 = s4;
                        if (s3 !== peg$FAILED) {
                            s2 = [ s2, s3 ];
                            s1 = s2;
                        } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                        }
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c33(s1);
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseExpressionTextBlock() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 49, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s1 = peg$c89;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 58) {
                            s2 = peg$c40;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c41);
                            }
                        }
                        if (s2 === peg$FAILED) {
                            s2 = peg$c10;
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parse__();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseCoreExpText();
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 125) {
                                        s5 = peg$c93;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c94);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c199(s2, s4);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c2;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseInvalidExpressionValue() {
                    var s0, s1, s2, s3, s4;
                    var key = peg$currPos * 116 + 50, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    peg$silentFails++;
                    s2 = peg$currPos;
                    if (input.substr(peg$currPos, 9) === peg$c73) {
                        s3 = peg$c73;
                        peg$currPos += 9;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c74);
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            s3 = [ s3, s4 ];
                            s2 = s3;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                    } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s2 === peg$FAILED) {
                        s1 = peg$c14;
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        if (peg$c200.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c201);
                            }
                        }
                        if (s3 !== peg$FAILED) {
                            while (s3 !== peg$FAILED) {
                                s2.push(s3);
                                if (peg$c200.test(input.charAt(peg$currPos))) {
                                    s3 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c201);
                                    }
                                }
                            }
                        } else {
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c202(s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseS() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 51, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = [];
                    s1 = peg$parseWhiteSpace();
                    if (s1 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 13) {
                            s1 = peg$c204;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c205);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 10) {
                                s1 = peg$c206;
                                peg$currPos++;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c207);
                                }
                            }
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        while (s1 !== peg$FAILED) {
                            s0.push(s1);
                            s1 = peg$parseWhiteSpace();
                            if (s1 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 13) {
                                    s1 = peg$c204;
                                    peg$currPos++;
                                } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c205);
                                    }
                                }
                                if (s1 === peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 10) {
                                        s1 = peg$c206;
                                        peg$currPos++;
                                    } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c207);
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c203);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parse_() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 52, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = [];
                    s1 = peg$parseWhiteSpace();
                    while (s1 !== peg$FAILED) {
                        s0.push(s1);
                        s1 = peg$parseWhiteSpace();
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseWhiteSpace() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 53, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    if (peg$c208.test(input.charAt(peg$currPos))) {
                        s0 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c209);
                        }
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c203);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEOL() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 54, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    if (input.charCodeAt(peg$currPos) === 10) {
                        s0 = peg$c206;
                        peg$currPos++;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c207);
                        }
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c211) {
                            s0 = peg$c211;
                            peg$currPos += 2;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c212);
                            }
                        }
                        if (s0 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 13) {
                                s0 = peg$c204;
                                peg$currPos++;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c205);
                                }
                            }
                            if (s0 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 8232) {
                                    s0 = peg$c213;
                                    peg$currPos++;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c214);
                                    }
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 8233) {
                                        s0 = peg$c215;
                                        peg$currPos++;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c216);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c210);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEOS() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 55, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseEOL();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                                s1 = [ s1, s2, s3 ];
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c217);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEOF() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 56, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    peg$silentFails++;
                    if (input.length > peg$currPos) {
                        s1 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c219);
                        }
                    }
                    peg$silentFails--;
                    if (s1 === peg$FAILED) {
                        s0 = peg$c14;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c218);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parse__() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 57, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = [];
                    s1 = peg$parseWhiteSpace();
                    if (s1 === peg$FAILED) {
                        s1 = peg$parseEOL();
                        if (s1 === peg$FAILED) {
                            s1 = peg$parseComment();
                        }
                    }
                    while (s1 !== peg$FAILED) {
                        s0.push(s1);
                        s1 = peg$parseWhiteSpace();
                        if (s1 === peg$FAILED) {
                            s1 = peg$parseEOL();
                            if (s1 === peg$FAILED) {
                                s1 = peg$parseComment();
                            }
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseComment() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 58, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$parseMultiLineComment();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseSingleLineComment();
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c220);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseMultiLineComment() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 59, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c221) {
                        s1 = peg$c221;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c222);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        peg$silentFails++;
                        if (input.substr(peg$currPos, 2) === peg$c223) {
                            s5 = peg$c223;
                            peg$currPos += 2;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c224);
                            }
                        }
                        peg$silentFails--;
                        if (s5 === peg$FAILED) {
                            s4 = peg$c14;
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c2;
                        }
                        if (s4 !== peg$FAILED) {
                            if (input.length > peg$currPos) {
                                s5 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c219);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s4 = [ s4, s5 ];
                                s3 = s4;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c2;
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$currPos;
                            peg$silentFails++;
                            if (input.substr(peg$currPos, 2) === peg$c223) {
                                s5 = peg$c223;
                                peg$currPos += 2;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c224);
                                }
                            }
                            peg$silentFails--;
                            if (s5 === peg$FAILED) {
                                s4 = peg$c14;
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c2;
                            }
                            if (s4 !== peg$FAILED) {
                                if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c219);
                                    }
                                }
                                if (s5 !== peg$FAILED) {
                                    s4 = [ s4, s5 ];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c2;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c223) {
                                s3 = peg$c223;
                                peg$currPos += 2;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c224);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s1 = [ s1, s2, s3 ];
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c2;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseSingleLineComment() {
                    var s0, s1, s2, s3, s4, s5;
                    var key = peg$currPos * 116 + 60, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c113) {
                        s1 = peg$c113;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c114);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        peg$silentFails++;
                        s5 = peg$parseEOL();
                        peg$silentFails--;
                        if (s5 === peg$FAILED) {
                            s4 = peg$c14;
                        } else {
                            peg$currPos = s4;
                            s4 = peg$c2;
                        }
                        if (s4 !== peg$FAILED) {
                            if (input.length > peg$currPos) {
                                s5 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c219);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                s4 = [ s4, s5 ];
                                s3 = s4;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c2;
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$currPos;
                            peg$silentFails++;
                            s5 = peg$parseEOL();
                            peg$silentFails--;
                            if (s5 === peg$FAILED) {
                                s4 = peg$c14;
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c2;
                            }
                            if (s4 !== peg$FAILED) {
                                if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c219);
                                    }
                                }
                                if (s5 !== peg$FAILED) {
                                    s4 = [ s4, s5 ];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c2;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseJSObjectRef() {
                    var s0, s1, s2, s3, s4, s5, s6;
                    var key = peg$currPos * 116 + 61, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parseVarIdentifier();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 46) {
                            s4 = peg$c226;
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c227);
                            }
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parseIdentifier();
                            if (s5 !== peg$FAILED) {
                                peg$reportedPos = s3;
                                s4 = peg$c228(s5);
                                s3 = s4;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c2;
                        }
                        if (s3 === peg$FAILED) {
                            s3 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 91) {
                                s4 = peg$c229;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c230);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = [];
                                if (peg$c165.test(input.charAt(peg$currPos))) {
                                    s6 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c166);
                                    }
                                }
                                if (s6 !== peg$FAILED) {
                                    while (s6 !== peg$FAILED) {
                                        s5.push(s6);
                                        if (peg$c165.test(input.charAt(peg$currPos))) {
                                            s6 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c166);
                                            }
                                        }
                                    }
                                } else {
                                    s5 = peg$c2;
                                }
                                if (s5 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 93) {
                                        s6 = peg$c231;
                                        peg$currPos++;
                                    } else {
                                        s6 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c232);
                                        }
                                    }
                                    if (s6 !== peg$FAILED) {
                                        peg$reportedPos = s3;
                                        s4 = peg$c233(s5);
                                        s3 = s4;
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c2;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 46) {
                                s4 = peg$c226;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c227);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parseIdentifier();
                                if (s5 !== peg$FAILED) {
                                    peg$reportedPos = s3;
                                    s4 = peg$c228(s5);
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c2;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c2;
                            }
                            if (s3 === peg$FAILED) {
                                s3 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 91) {
                                    s4 = peg$c229;
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c230);
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = [];
                                    if (peg$c165.test(input.charAt(peg$currPos))) {
                                        s6 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s6 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c166);
                                        }
                                    }
                                    if (s6 !== peg$FAILED) {
                                        while (s6 !== peg$FAILED) {
                                            s5.push(s6);
                                            if (peg$c165.test(input.charAt(peg$currPos))) {
                                                s6 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s6 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c166);
                                                }
                                            }
                                        }
                                    } else {
                                        s5 = peg$c2;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 93) {
                                            s6 = peg$c231;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c232);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$reportedPos = s3;
                                            s4 = peg$c233(s5);
                                            s3 = s4;
                                        } else {
                                            peg$currPos = s3;
                                            s3 = peg$c2;
                                        }
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$c2;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c2;
                                }
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c234(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c225);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseSourceCharacter() {
                    var s0;
                    var key = peg$currPos * 116 + 62, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    if (input.length > peg$currPos) {
                        s0 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c219);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseIdentifier() {
                    var s0, s1, s2;
                    var key = peg$currPos * 116 + 63, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    peg$silentFails++;
                    s2 = peg$parseReservedWord();
                    peg$silentFails--;
                    if (s2 === peg$FAILED) {
                        s1 = peg$c14;
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseIdentifierName();
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c236(s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c235);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseIdentifierName() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 64, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parseIdentifierStart();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parseIdentifierPart();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parseIdentifierPart();
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c237(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c235);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseIdentifierStart() {
                    var s0;
                    var key = peg$currPos * 116 + 65, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$parseLetter();
                    if (s0 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 36) {
                            s0 = peg$c238;
                            peg$currPos++;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c239);
                            }
                        }
                        if (s0 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 95) {
                                s0 = peg$c240;
                                peg$currPos++;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c241);
                                }
                            }
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseVarIdentifier() {
                    var s0, s1, s2;
                    var key = peg$currPos * 116 + 66, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    peg$silentFails++;
                    s2 = peg$parseReservedWord();
                    peg$silentFails--;
                    if (s2 === peg$FAILED) {
                        s1 = peg$c14;
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseVarIdentifierName();
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c236(s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c242);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseVarIdentifierName() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 67, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    peg$silentFails++;
                    s0 = peg$currPos;
                    s1 = peg$parseVarIdentifierStart();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parseIdentifierPart();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parseIdentifierPart();
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c237(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c235);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseVarIdentifierStart() {
                    var s0;
                    var key = peg$currPos * 116 + 68, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$parseLetter();
                    if (s0 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 36) {
                            s0 = peg$c238;
                            peg$currPos++;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c239);
                            }
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseIdentifierPart() {
                    var s0;
                    var key = peg$currPos * 116 + 69, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$parseIdentifierStart();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseDigit();
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseLetter() {
                    var s0;
                    var key = peg$currPos * 116 + 70, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    if (peg$c170.test(input.charAt(peg$currPos))) {
                        s0 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c171);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseDigit() {
                    var s0;
                    var key = peg$currPos * 116 + 71, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    if (peg$c165.test(input.charAt(peg$currPos))) {
                        s0 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c166);
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseBreakToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 72, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c243) {
                        s1 = peg$c243;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c244);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseCaseToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 73, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c245) {
                        s1 = peg$c245;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c246);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseCatchToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 74, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c247) {
                        s1 = peg$c247;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c248);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseClassToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 75, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c249) {
                        s1 = peg$c249;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c250);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseConstToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 76, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c251) {
                        s1 = peg$c251;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c252);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseContinueToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 77, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 8) === peg$c253) {
                        s1 = peg$c253;
                        peg$currPos += 8;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c254);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseDebuggerToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 78, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 8) === peg$c255) {
                        s1 = peg$c255;
                        peg$currPos += 8;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c256);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseDefaultToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 79, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 7) === peg$c257) {
                        s1 = peg$c257;
                        peg$currPos += 7;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c258);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseDeleteToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 80, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c259) {
                        s1 = peg$c259;
                        peg$currPos += 6;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c260);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseDoToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 81, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c261) {
                        s1 = peg$c261;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c262);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseElseToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 82, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c107) {
                        s1 = peg$c107;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c108);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseEnumToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 83, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c263) {
                        s1 = peg$c263;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c264);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseExportToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 84, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c265) {
                        s1 = peg$c265;
                        peg$currPos += 6;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c266);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseExtendsToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 85, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 7) === peg$c267) {
                        s1 = peg$c267;
                        peg$currPos += 7;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c268);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseFalseToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 86, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c269) {
                        s1 = peg$c269;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c270);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseFinallyToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 87, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 7) === peg$c271) {
                        s1 = peg$c271;
                        peg$currPos += 7;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c272);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseForToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 88, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c273) {
                        s1 = peg$c273;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c274);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseFunctionToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 89, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 8) === peg$c275) {
                        s1 = peg$c275;
                        peg$currPos += 8;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c276);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseGetToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 90, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c277) {
                        s1 = peg$c277;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c278);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseIfToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 91, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c104) {
                        s1 = peg$c104;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c105);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseImportToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 92, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c279) {
                        s1 = peg$c279;
                        peg$currPos += 6;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c280);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseInstanceofToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 93, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 10) === peg$c281) {
                        s1 = peg$c281;
                        peg$currPos += 10;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c282);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseInToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 94, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c283) {
                        s1 = peg$c283;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c284);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseNewToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 95, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c285) {
                        s1 = peg$c285;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c286);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseNullToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 96, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c287) {
                        s1 = peg$c287;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c288);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseReturnToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 97, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c289) {
                        s1 = peg$c289;
                        peg$currPos += 6;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c290);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseSetToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 98, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c291) {
                        s1 = peg$c291;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c292);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseSuperToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 99, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c293) {
                        s1 = peg$c293;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c294);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseSwitchToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 100, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c295) {
                        s1 = peg$c295;
                        peg$currPos += 6;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c296);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseThisToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 101, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c297) {
                        s1 = peg$c297;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c298);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseThrowToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 102, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c299) {
                        s1 = peg$c299;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c300);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTrueToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 103, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c301) {
                        s1 = peg$c301;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c302);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTryToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 104, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c303) {
                        s1 = peg$c303;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c304);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseTypeofToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 105, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c305) {
                        s1 = peg$c305;
                        peg$currPos += 6;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c306);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseVarToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 106, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c307) {
                        s1 = peg$c307;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c308);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseVoidToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 107, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c309) {
                        s1 = peg$c309;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c310);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseWhileToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 108, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c311) {
                        s1 = peg$c311;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c312);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseWithToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 109, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4) === peg$c313) {
                        s1 = peg$c313;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c314);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseReservedWord() {
                    var s0;
                    var key = peg$currPos * 116 + 110, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$parseKeyword();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseFutureReservedWord();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseNullLiteral();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseBooleanLiteral();
                            }
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseKeyword() {
                    var s0;
                    var key = peg$currPos * 116 + 111, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$parseBreakToken();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseCaseToken();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseCatchToken();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseContinueToken();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseDebuggerToken();
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$parseDefaultToken();
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$parseDeleteToken();
                                            if (s0 === peg$FAILED) {
                                                s0 = peg$parseDoToken();
                                                if (s0 === peg$FAILED) {
                                                    s0 = peg$parseElseToken();
                                                    if (s0 === peg$FAILED) {
                                                        s0 = peg$parseFinallyToken();
                                                        if (s0 === peg$FAILED) {
                                                            s0 = peg$parseForToken();
                                                            if (s0 === peg$FAILED) {
                                                                s0 = peg$parseFunctionToken();
                                                                if (s0 === peg$FAILED) {
                                                                    s0 = peg$parseIfToken();
                                                                    if (s0 === peg$FAILED) {
                                                                        s0 = peg$parseInstanceofToken();
                                                                        if (s0 === peg$FAILED) {
                                                                            s0 = peg$parseInToken();
                                                                            if (s0 === peg$FAILED) {
                                                                                s0 = peg$parseNewToken();
                                                                                if (s0 === peg$FAILED) {
                                                                                    s0 = peg$parseReturnToken();
                                                                                    if (s0 === peg$FAILED) {
                                                                                        s0 = peg$parseSwitchToken();
                                                                                        if (s0 === peg$FAILED) {
                                                                                            s0 = peg$parseThisToken();
                                                                                            if (s0 === peg$FAILED) {
                                                                                                s0 = peg$parseThrowToken();
                                                                                                if (s0 === peg$FAILED) {
                                                                                                    s0 = peg$parseTryToken();
                                                                                                    if (s0 === peg$FAILED) {
                                                                                                        s0 = peg$parseTypeofToken();
                                                                                                        if (s0 === peg$FAILED) {
                                                                                                            s0 = peg$parseVarToken();
                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                s0 = peg$parseVoidToken();
                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                    s0 = peg$parseWhileToken();
                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                        s0 = peg$parseWithToken();
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseFutureReservedWord() {
                    var s0;
                    var key = peg$currPos * 116 + 112, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$parseClassToken();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseConstToken();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseEnumToken();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseExportToken();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseExtendsToken();
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$parseImportToken();
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$parseSuperToken();
                                        }
                                    }
                                }
                            }
                        }
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseNewToken() {
                    var s0, s1, s2, s3;
                    var key = peg$currPos * 116 + 95, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c285) {
                        s1 = peg$c285;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c286);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        s3 = peg$parseIdentifierPart();
                        peg$silentFails--;
                        if (s3 === peg$FAILED) {
                            s2 = peg$c14;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [ s1, s2 ];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseNullLiteral() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 114, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$parseNullToken();
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c315();
                    }
                    s0 = s1;
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                function peg$parseBooleanLiteral() {
                    var s0, s1;
                    var key = peg$currPos * 116 + 115, cached = peg$cache[key];
                    if (cached) {
                        peg$currPos = cached.nextPos;
                        return cached.result;
                    }
                    s0 = peg$currPos;
                    s1 = peg$parseTrueToken();
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c316();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parseFalseToken();
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c317();
                        }
                        s0 = s1;
                    }
                    peg$cache[key] = {
                        nextPos: peg$currPos,
                        result: s0
                    };
                    return s0;
                }
                peg$result = peg$startRuleFunction();
                if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                    return peg$result;
                } else {
                    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                        peg$fail({
                            type: "end",
                            description: "end of input"
                        });
                    }
                    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
                }
            }
            return {
                SyntaxError: SyntaxError,
                parse: parse
            };
        }();
    });
    define("hsp/compiler/parser/index.js", [ "./hspblocks.peg.js" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var blockParser = require("./hspblocks.peg.js");
        /**
 * Return the list of instruction blocks that compose a template file.
 * At this stage the template AST is not complete, it is built in the next step of the compilation process, i.e. the treebuilder.
 * Note: this function is exposed for unit test purposes and should not be used directly
 * @param {String} template the template to parse
 * @return {Object} the parse result
 */
        exports.parse = function(template) {
            // add a last line feed a the end of the template as the parser parses the plaintext
            // sequences only when ending with a new line sequence (workaround to solve pegjs issue)
            return blockParser.parse(template + "\r\n");
        };
    });
    define("hsp/compiler/treebuilder/htmlEntities.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var NAMED_HTML_ENTITIES = {
            quot: 34,
            amp: 38,
            apos: 39,
            lt: 60,
            gt: 62,
            nbsp: 160,
            iexcl: 161,
            cent: 162,
            pound: 163,
            curren: 164,
            yen: 165,
            brvbar: 166,
            sect: 167,
            uml: 168,
            copy: 169,
            ordf: 170,
            laquo: 171,
            not: 172,
            shy: 173,
            reg: 174,
            macr: 175,
            deg: 176,
            plusmn: 177,
            sup2: 178,
            sup3: 179,
            acute: 180,
            micro: 181,
            para: 182,
            middot: 183,
            cedil: 184,
            sup1: 185,
            ordm: 186,
            raquo: 187,
            frac14: 188,
            frac12: 189,
            frac34: 190,
            iquest: 191,
            Agrave: 192,
            Aacute: 193,
            Acirc: 194,
            Atilde: 195,
            Auml: 196,
            Aring: 197,
            AElig: 198,
            Ccedil: 199,
            Egrave: 200,
            Eacute: 201,
            Ecirc: 202,
            Euml: 203,
            Igrave: 204,
            Iacute: 205,
            Icirc: 206,
            Iuml: 207,
            ETH: 208,
            Ntilde: 209,
            Ograve: 210,
            Oacute: 211,
            Ocirc: 212,
            Otilde: 213,
            Ouml: 214,
            times: 215,
            Oslash: 216,
            Ugrave: 217,
            Uacute: 218,
            Ucirc: 219,
            Uuml: 220,
            Yacute: 221,
            THORN: 222,
            szlig: 223,
            agrave: 224,
            aacute: 225,
            acirc: 226,
            atilde: 227,
            auml: 228,
            aring: 229,
            aelig: 230,
            ccedil: 231,
            egrave: 232,
            eacute: 233,
            ecirc: 234,
            euml: 235,
            igrave: 236,
            iacute: 237,
            icirc: 238,
            iuml: 239,
            eth: 240,
            ntilde: 241,
            ograve: 242,
            oacute: 243,
            ocirc: 244,
            otilde: 245,
            ouml: 246,
            divide: 247,
            oslash: 248,
            ugrave: 249,
            uacute: 250,
            ucirc: 251,
            uuml: 252,
            yacute: 253,
            thorn: 254,
            yuml: 255,
            OElig: 338,
            oelig: 339,
            Scaron: 352,
            scaron: 353,
            Yuml: 376,
            fnof: 402,
            circ: 710,
            tilde: 732,
            Alpha: 913,
            Beta: 914,
            Gamma: 915,
            Delta: 916,
            Epsilon: 917,
            Zeta: 918,
            Eta: 919,
            Theta: 920,
            Iota: 921,
            Kappa: 922,
            Lambda: 923,
            Mu: 924,
            Nu: 925,
            Xi: 926,
            Omicron: 927,
            Pi: 928,
            Rho: 929,
            Sigma: 931,
            Tau: 932,
            psilon: 933,
            Phi: 934,
            Chi: 935,
            Psi: 936,
            Omega: 937,
            alpha: 945,
            beta: 946,
            gamma: 947,
            delta: 948,
            epsilon: 949,
            zeta: 950,
            eta: 951,
            theta: 952,
            iota: 953,
            kappa: 954,
            lambda: 955,
            mu: 956,
            nu: 957,
            xi: 958,
            omicron: 959,
            pi: 960,
            rho: 961,
            sigmaf: 962,
            sigma: 963,
            tau: 964,
            upsilon: 965,
            phi: 966,
            chi: 967,
            psi: 968,
            omega: 969,
            thetasym: 977,
            upsih: 978,
            piv: 982,
            ensp: 8194,
            emsp: 8195,
            thinsp: 8201,
            zwnj: 8204,
            zwj: 8205,
            lrm: 8206,
            rlm: 8207,
            ndash: 8211,
            mdash: 8212,
            lsquo: 8216,
            rsquo: 8217,
            sbquo: 8218,
            ldquo: 8220,
            rdquo: 8221,
            bdquo: 8222,
            dagger: 8224,
            Dagger: 8225,
            bull: 8226,
            hellip: 8230,
            permil: 8240,
            prime: 8242,
            Prime: 8243,
            lsaquo: 8249,
            rsaquo: 8250,
            oline: 8254,
            frasl: 8260,
            euro: 8364,
            image: 8465,
            weierp: 8472,
            real: 8476,
            trade: 8482,
            alefsym: 8501,
            larr: 8592,
            uarr: 8593,
            rarr: 8594,
            darr: 8595,
            harr: 8596,
            crarr: 8629,
            lArr: 8656,
            uArr: 8657,
            rArr: 8658,
            dArr: 8659,
            hArr: 8660,
            forall: 8704,
            part: 8706,
            exist: 8707,
            empty: 8709,
            nabla: 8711,
            isin: 8712,
            notin: 8713,
            ni: 8715,
            prod: 8719,
            sum: 8721,
            minus: 8722,
            lowast: 8727,
            radic: 8730,
            prop: 8733,
            infin: 8734,
            ang: 8736,
            and: 8743,
            or: 8744,
            cap: 8745,
            cup: 8746,
            "int": 8747,
            there4: 8756,
            sim: 8764,
            cong: 8773,
            asymp: 8776,
            ne: 8800,
            equiv: 8801,
            le: 8804,
            ge: 8805,
            sub: 8834,
            sup: 8835,
            nsub: 8836,
            sube: 8838,
            supe: 8839,
            oplus: 8853,
            otimes: 8855,
            perp: 8869,
            sdot: 8901,
            vellip: 8942,
            lceil: 8968,
            rceil: 8969,
            lfloor: 8970,
            rfloor: 8971,
            lang: 9001,
            rang: 9002,
            loz: 9674,
            spades: 9824,
            clubs: 9827,
            hearts: 9829,
            diams: 9830
        };
        /**
 * A utility function that accepts a string and converts all the HTML character references
 * (both named and numeric) into their unicode representation.
 * @param {String} inputText text in which HTML entities should be replaced.
 * @return {String} The converted string.
 */
        exports.htmlEntitiesToUtf8 = function(inputText) {
            //http://www.w3.org/TR/html5/syntax.html#character-references
            var entitiesPattern = /&(#([xX])?)?([A-Za-z0-9]+);/g;
            return inputText ? inputText.replace(entitiesPattern, function(match, isNumeric, isHex, entityName) {
                var replacementCode;
                if (isNumeric) {
                    replacementCode = parseInt(entityName, isHex ? 16 : 10);
                } else {
                    //named entities
                    if (NAMED_HTML_ENTITIES.hasOwnProperty(entityName)) {
                        replacementCode = NAMED_HTML_ENTITIES[entityName];
                    } else {
                        throw new Error('"' + match + '" is not a valid HTML entity.');
                    }
                }
                return String.fromCharCode(replacementCode);
            }) : inputText;
        };
    });
    define("hsp/compiler/treebuilder/syntaxTree.js", [ "../../klass", "./htmlEntities", "../../expressions/parser" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var klass = require("../../klass");
        var htmlEntitiesToUtf8 = require("./htmlEntities").htmlEntitiesToUtf8;
        var exParser = require("../../expressions/parser");
        //http://www.w3.org/TR/html-markup/syntax.html#syntax-elements
        var VOID_HTML_ELEMENTS = {
            area: true,
            base: true,
            br: true,
            col: true,
            command: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
        };
        /**
 * Checks if an element is a void one.
 * @param {String} the element name.
 * @return {Boolean} true if the element is a void one.
 */
        function isVoidElement(elName) {
            var result = false;
            if (elName && elName.toLowerCase) {
                result = VOID_HTML_ELEMENTS.hasOwnProperty(elName.toLowerCase());
            }
            return result;
        }
        /**
 * Node of the Syntax tree
 */
        var Node = klass({
            $constructor: function(type, parent) {
                this.type = type;
                this.parent = parent;
            }
        });
        /**
 * A map of the reserved keywords.
 */
        var reservedKeywords = {
            event: true,
            scope: true
        };
        function isEventHandlerAttr(attrName) {
            return attrName.match(/^on/i);
        }
        /**
 * The SyntaxTree class made to build the syntax tree from the block list from the parser. 
 * Entry point: generateTree()
 */
        var SyntaxTree = klass({
            /**
     * Generate the syntax tree from the root block list.
     * @param {Object} blockList the block list.
     */
            generateTree: function(blockList) {
                this.errors = [];
                this.tree = new Node("file", null);
                this.tree.content = [];
                this._advance(blockList, 0, this.tree.content);
                this._postProcessTree();
            },
            /**
     * Adds an error to the current error list.
     * @param {String} description the error description
     * @param {Object} errdesc additional object (block, node, ...) which can contain additional info about the error (line/column number, code).
     */
            _logError: function(description, errdesc) {
                //TODO: errdesc is a bit vague
                var desc = {
                    description: description
                };
                if (errdesc) {
                    if (errdesc.line) {
                        desc.line = errdesc.line;
                        desc.column = errdesc.column;
                    }
                    if (errdesc.code) {
                        desc.code = errdesc.code;
                    }
                }
                this.errors.push(desc);
            },
            /**
     * Validates expression for syntax errors
     * @param {String} exp
     * @return {Object} ast or undefined if expression is not valid
     */
            _validateExpressionBlock: function(block) {
                //parse the expression to detect errors
                //TODO(pk): avoid parsing the same expression several times
                try {
                    return exParser(block.value);
                } catch (e) {
                    this._logError("Invalid expression: '" + block.value + "'", block);
                }
            },
            /**
     * Process a list of blocks and advance the cursor index that scans the collection.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} startIndex the index from which the process has to start.
     * @param {Array} out the output as an array of Node.
     * @param {Function} optEndFn an optional end function that takes a node type as argument.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            _advance: function(blocks, startIndex, out, optEndFn) {
                var block, type;
                if (blocks) {
                    for (var i = startIndex; i < blocks.length; i++) {
                        block = blocks[i];
                        type = block.type;
                        if (optEndFn && optEndFn(type, block.name)) {
                            // we stop here
                            return i;
                        }
                        //by convention, a block of type xyz is managed by a __xyz function in the class 
                        if (this["__" + type]) {
                            i = this["__" + type](i, blocks, out);
                        } else {
                            this._logError("Invalid statement: " + type, block);
                        }
                    }
                    return blocks.length;
                }
            },
            /**
     * Post validation once the tree is properly parsed.
     */
            _postProcessTree: function() {
                var nodes = this.tree.content;
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i].type === "template") {
                        this._processNodeContent(nodes[i].content, nodes[i]);
                    }
                }
            },
            /**
     * Validates the content of a container node.
     * @param {Array} nodeList the content of a container node
     * @param {Node} parent the parent node
     */
            _processNodeContent: function(nodeList, parent) {
                // Ensure that {let} nodes are always at the beginning of a containter element
                var node, contentFound = false;
                // true when a node different from let is found
                for (var i = 0; i < nodeList.length; i++) {
                    node = nodeList[i];
                    //console.log(i+":"+node.type)
                    if (node.type === "comment") {
                        continue;
                    }
                    if (node.type === "text") {
                        // tolerate static white space text
                        if (node.value.match(/^\s*$/)) {
                            continue;
                        }
                    }
                    if (node.type === "let") {
                        if (contentFound) {
                            // error: let must be defined before any piece of content
                            this._logError("Let statements must be defined at the beginning of a block", node);
                        } else {
                            parent.needSubScope = true;
                        }
                    } else {
                        contentFound = true;
                        if (node.content) {
                            this._processNodeContent(node.content, node);
                        }
                        if (node.content1) {
                            this._processNodeContent(node.content1, node);
                        }
                        if (node.content2) {
                            this._processNodeContent(node.content2, node);
                        }
                    }
                }
            },
            /**
     * Manages a template block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __template: function(index, blocks, out) {
                var node = new Node("template"), block = blocks[index];
                node.name = block.name;
                if (block.controller) {
                    node.controller = block.controller;
                    node.controller.ref = block.controllerRef;
                } else {
                    node.args = block.args;
                    // check args
                    for (var i = 0; i < node.args.length; i++) {
                        if (reservedKeywords[node.args[i]]) {
                            this._logError("Reserved keywords cannot be used as template argument: " + node.args[i], block);
                        }
                    }
                }
                node.isExport = block.mod === "export";
                node.startLine = block.line;
                node.endLine = block.endLine;
                node.content = [];
                out.push(node);
                if (block.mod !== "" && block.mod !== "export") {
                    this._logError("Invalid template template modifier: " + block.mod, blocks[index]);
                }
                if (!block.closed) {
                    this._logError("Missing end template statement", block);
                }
                // parse sub-list of blocks
                this._advance(block.content, 0, node.content);
                return index;
            },
            /**
     * Catches invalid template definitions.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __invalidtemplate: function(index, blocks, out) {
                this._logError("Invalid template declaration", blocks[index]);
                return index;
            },
            /**
     * Manages a text block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __plaintext: function(index, blocks, out) {
                var node = new Node("plaintext"), block = blocks[index];
                node.value = block.value;
                out.push(node);
                return index;
            },
            /**
     * Manages a top level HTML-style, possibily multiline, comment block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __toplevelcomment: function(index, blocks, out) {
                // let's just emit whitespace with as many newlines as the original comment had,
                // so that we keep the 1:1 line mapping with the source
                var node = new Node("plaintext"), block = blocks[index];
                node.value = block.value.replace(/[^\r\n]/g, "");
                out.push(node);
                return index;
            },
            /**
     * Manages a log statement.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __log: function(index, blocks, out) {
                var node = new Node("log"), block = blocks[index];
                node.line = block.line;
                node.column = block.column;
                node.exprs = block.exprs;
                out.push(node);
                return index;
            },
            /**
     * Manages a let statement.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __let: function(index, blocks, out) {
                var node = new Node("let"), block = blocks[index];
                node.line = block.line;
                node.column = block.column;
                node.assignments = block.assignments;
                out.push(node);
                return index;
            },
            /**
     * Manages a text block: regroups adjacent text and expression blocks
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __text: function(index, blocks, out) {
                var length = blocks.length, buffer = [];
                //Regroups adjacent text and expression blocks by looking at the next ones
                var nextIndex = index, goAhead = length > nextIndex, block;
                while (goAhead) {
                    block = blocks[nextIndex];
                    if (block.type === "text") {
                        if (block.value !== "") {
                            try {
                                block.value = htmlEntitiesToUtf8(block.value);
                                buffer.push(block);
                            } catch (e) {
                                this._logError(e.message, block);
                            }
                        }
                    } else if (block.type === "expression") {
                        //parse the expression to detect errors
                        if (this._validateExpressionBlock(block)) {
                            buffer.push(block);
                        }
                    } else if (block.type === "comment") {} else {
                        goAhead = false;
                    }
                    if (goAhead) {
                        nextIndex++;
                        goAhead = length > nextIndex;
                    }
                }
                //Manages the adjacent text and expression blocks found
                var node = null;
                if (buffer.length === 1 && buffer[0].type === "text") {
                    // only one text block
                    node = new Node("text");
                    node.value = buffer[0].value;
                } else if (buffer.length > 0) {
                    // if buffer is composed of only text expressions we concatenate them
                    var onlyText = true;
                    for (var i = 0; i < buffer.length; i++) {
                        if (buffer[i].type !== "text") {
                            onlyText = false;
                            break;
                        }
                    }
                    if (onlyText) {
                        var texts = [];
                        for (var i = 0; i < buffer.length; i++) {
                            texts.push(buffer[i].value);
                        }
                        node = new Node("text");
                        node.value = texts.join("");
                    } else {
                        // an expression or several blocks have to be aggregated
                        node = new Node("textblock");
                        node.content = buffer;
                    }
                }
                if (node) {
                    out.push(node);
                }
                // return the last index that was handled
                return nextIndex > index ? nextIndex - 1 : index;
            },
            /**
     * Manages an expression block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __expression: function(index, blocks, out) {
                return this.__text(index, blocks, out);
            },
            /**
     * Manages an if block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __if: function(index, blocks, out) {
                //creates the if node
                var node = new Node("if"), block = blocks[index], lastValidIndex = index;
                node.condition = {
                    category: block.condition.category,
                    value: block.condition.value,
                    line: block.condition.line,
                    column: block.condition.column
                };
                node.condition.bound = true;
                //TODO: what does it mean?
                node.content1 = [];
                out.push(node);
                var endFound = false, out2 = node.content1;
                //process the content of the if block, until one of the if end is found (i.e. endif, else or elseif), if any
                while (!endFound) {
                    //fills node.content1 with the next blocks
                    index = this._advance(blocks, index + 1, out2, this._ifEndTypes);
                    if (index < 0 || !blocks[index]) {
                        this._logError("Missing end if statement", blocks[lastValidIndex]);
                        endFound = true;
                    } else {
                        var type = blocks[index].type;
                        if (type === "endif") {
                            endFound = true;
                        } else if (type === "else") {
                            //loop will restrat, filling node.content2 with the next blocks
                            node.content2 = [];
                            out2 = node.content2;
                            lastValidIndex = index;
                        } else if (type === "elseif") {
                            // consider as a standard else statement
                            node.content2 = [];
                            out2 = node.content2;
                            lastValidIndex = index;
                            endFound = true;
                            // process as if it were an if node
                            index = this.__if(index, blocks, out2);
                        }
                    }
                }
                return index;
            },
            /**
     * Detects if blocks end types.
     * @param {String} type the block type.
     * @retrun {Boolean} true if the block terminates an if.
     */
            _ifEndTypes: function(type) {
                return type === "endif" || type === "else" || type === "elseif";
            },
            /**
     * Manages an endif block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endif: function(index, blocks, out) {
                // only called in case of error, i.e not digested by __if
                var block = blocks[index];
                this._logError("{/if} statement does not match any {if} block", block);
                return index;
            },
            /**
     * Manages an else block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __else: function(index, blocks, out) {
                // only called in case of error, i.e not digested by __if
                var block = blocks[index];
                this._logError("{else} statement found outside any {if} block", block);
                return index;
            },
            /**
     * Manages an elseif block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __elseif: function(index, blocks, out) {
                // only called in case of error, i.e not digested by __if
                var block = blocks[index];
                this._logError("{else if} statement found outside any {if} block", block);
                return index;
            },
            /**
     * Manages a foreach block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __foreach: function(index, blocks, out) {
                //creates the foreach node
                var node = new Node("foreach"), block = blocks[index];
                node.item = block.item;
                node.key = block.key;
                node.collection = block.colref;
                node.content = [];
                out.push(node);
                //fills node.content with the next blocks, until an endforeach is found, if any
                var nextIndex = this._advance(blocks, index + 1, node.content, this._foreachEndTypes);
                if (nextIndex < 0 || !blocks[nextIndex]) {
                    this._logError("Missing end foreach statement", blocks[index]);
                }
                return nextIndex;
            },
            /**
     * Detects foreach end.
     * @param {String} type the block type.
     * @retrun {Boolean} true if the block terminates an foreach.
     */
            _foreachEndTypes: function(type) {
                return type === "endforeach";
            },
            /**
     * Manages an endforeach block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endforeach: function(index, blocks, out) {
                // only called in case of error, i.e not digested by __foreach
                var block = blocks[index];
                this._logError("{/foreach} statement does not match any {foreach} block", block);
                return index;
            },
            /**
     * Manages an element block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __element: function(index, blocks, out) {
                var block = blocks[index];
                if (isVoidElement(block.name)) {
                    block.closed = true;
                }
                return this._elementOrComponent("element", index, blocks, out);
            },
            /**
     * Manages a component block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __component: function(index, blocks, out) {
                return this._elementOrComponent("component", index, blocks, out);
            },
            /**
     * Manages a component attribute block.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __cptattribute: function(index, blocks, out) {
                return this._elementOrComponent("cptattribute", index, blocks, out);
            },
            /**
     * Processing function for elements, components and component attributes
     * @arg blockType {String} "element", "component" or "cptattribute".
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            _elementOrComponent: function(blockType, index, blocks, out) {
                var node = new Node(blockType), block = blocks[index], blockValue, expAst;
                node.name = block.name;
                node.closed = block.closed;
                if (block.ref) {
                    // only for components
                    node.ref = block.ref;
                }
                // Handle attributes
                var attributes = block.attributes, attribute, outAttribute;
                node.attributes = [];
                for (var i = 0; i < attributes.length; i++) {
                    attribute = attributes[i];
                    var length = attribute.value ? attribute.value.length : 0;
                    if (length === 0) {
                        // this case arises when the attribute is empty - so let's create an empty text node
                        if (attribute.value == null) {
                            // attribute has no value - e.g. autocomplete in an input element
                            outAttribute = {
                                name: attribute.name,
                                type: "name",
                                line: attribute.line,
                                column: attribute.column
                            };
                            node.attributes.push(outAttribute);
                            continue;
                        } else {
                            attribute.value.push({
                                type: "text",
                                value: ""
                            });
                        }
                        length = 1;
                    }
                    if (length === 1) {
                        // literal or expression
                        var type = attribute.value[0].type;
                        if (type === "text" || type === "expression") {
                            outAttribute = attribute.value[0];
                            outAttribute.name = attribute.name;
                            if (type === "expression") {
                                expAst = this._validateExpressionBlock(outAttribute);
                                //verify that an event handler is a function call
                                if (expAst && isEventHandlerAttr(attribute.name) && expAst.v !== "(") {
                                    this._logError("Event handler attribute only support function expressions", attribute.value[0]);
                                }
                            }
                        } else {
                            this._logError("Invalid attribute type: " + type, attribute);
                            continue;
                        }
                    } else {
                        // length > 1 so attribute is a text block
                        // if attribute is an event handler, raise an error
                        if (isEventHandlerAttr(attribute.name)) {
                            this._logError("Event handler attributes don't support text and expression mix", attribute);
                        }
                        //check expression attributes for syntax errors
                        for (var j = 0; j < length; j++) {
                            blockValue = attribute.value[j];
                            if (blockValue.type === "expression") {
                                expAst = this._validateExpressionBlock(blockValue);
                                if (expAst && isEventHandlerAttr(attribute.name) && expAst.v !== "(") {
                                    this._logError("Event handler attribute only support function expressions", attribute.value[0]);
                                }
                            }
                        }
                        outAttribute = {
                            name: attribute.name,
                            type: "textblock",
                            content: attribute.value
                        };
                    }
                    node.attributes.push(outAttribute);
                }
                //fills node.content with the next blocks, until an matching end element is found, if any
                node.content = [];
                out.push(node);
                if (!block.closed) {
                    var endFound = false, blockName = block.name;
                    while (!endFound) {
                        index = this._advance(blocks, index + 1, node.content, function(type, name) {
                            return type === "end" + blockType;
                        });
                        if (index < 0 || !blocks[index]) {
                            if (blockType === "component") {
                                blockName = "#" + this._getComponentPathAsString(block.ref);
                            }
                            // we didn't find any endelement or endcomponent
                            this._logError("Missing end " + blockType + " </" + blockName + ">", block);
                            endFound = true;
                        } else {
                            // check if the end name is correct
                            var endBlock = blocks[index];
                            if (endBlock.type === "endelement" || endBlock.type === "endcptattribute") {
                                if (endBlock.name !== blockName) {
                                    this._logError("Missing end " + blockType + " </" + blockName + ">", block);
                                    index -= 1;
                                }
                            } else {
                                // endcomponent
                                var beginPath = this._getComponentPathAsString(block.ref), endPath = this._getComponentPathAsString(endBlock.ref);
                                if (beginPath !== endPath) {
                                    this._logError("Missing end component </#" + beginPath + ">", block);
                                    index -= 1;
                                }
                            }
                            endFound = true;
                        }
                    }
                }
                return index;
            },
            /**
     * Transform a component path into a string - useful for error checking
     * If path is invalid null is returned
     * @param {Object} ref the ref structure returned by the PEG parser for components and endcomponents
     * @retrun {String} the path as a string
     */
            _getComponentPathAsString: function(ref) {
                if (ref.category !== "objectref" || !ref.path || !ref.path.length || !ref.path.join) {
                    return null;
                }
                return ref.path.join(".");
            },
            /**
     * Catches invalid element errors.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __invalidelement: function(index, blocks, out) {
                // only called in case of error
                var block = blocks[index];
                var msg = "Invalid HTML element syntax";
                if (block.code && block.code.match(/^<\/?@/)) {
                    //when it starts with <@ or </@
                    msg = "Invalid component attribute syntax";
                }
                this._logError(msg, block);
                return index;
            },
            /**
     * Ignores comment blocks.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __comment: function(index, blocks, out) {
                return index;
            },
            /**
     * Captures isolated end elements to raise an error.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endelement: function(index, blocks, out) {
                // only called in case of error, i.e not digested by _elementOrComponent
                var block = blocks[index], name = block.name;
                if (isVoidElement(name)) {
                    this._logError("The end element </" + name + "> was rejected as <" + name + "> is a void HTML element and can't have a closing element", block);
                } else {
                    this._logError("End element </" + name + "> does not match any <" + name + "> element", block);
                }
                return index;
            },
            /**
     * Captures isolated end components to raise an error.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endcomponent: function(index, blocks, out) {
                // only called in case of error, i.e not digested by _elementOrComponent
                var block = blocks[index], path = this._getComponentPathAsString(block.ref);
                this._logError("End component </#" + path + "> does not match any <#" + path + "> component", block);
                return index;
            },
            /**
     * Captures isolated end component attributes to raise an error.
     * @param {Array} blocks the full list of blocks.
     * @param {Integer} index the index of the block to manage.
     * @param {Array} out the output as an array of Node.
     * @return {Integer} the index of the block where the function stopped or -1 if all blocks have been handled.
     */
            __endcptattribute: function(index, blocks, out) {
                // only called in case of error, i.e not digested by _elementOrComponent
                var block = blocks[index], name = block.name;
                this._logError("End component attribute </@" + name + "> does not match any <@" + name + "> component attribute", block);
                return index;
            }
        });
        exports.SyntaxTree = SyntaxTree;
    });
    define("hsp/compiler/treebuilder/index.js", [ "./syntaxTree" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var SyntaxTree = require("./syntaxTree").SyntaxTree;
        /**
 * Builds the syntax tree from the block list generated by the parser.
 * @param {Object} blockList the blockList
 * @return {Object} a JSON structure with the following properties:
 *      syntaxTree: {Object} the syntax tree
 *      errors: {Array} the error list
 */
        exports.build = function(blockList) {
            var result = {};
            try {
                var syntaxTree = new SyntaxTree();
                syntaxTree.generateTree(blockList);
                result = {
                    syntaxTree: syntaxTree.tree.content,
                    errors: syntaxTree.errors
                };
            } catch (ex) {
                result = {
                    syntaxTree: null,
                    errors: [ {
                        description: ex.toString(),
                        line: ex.line,
                        column: ex.column
                    } ]
                };
            }
            return result;
        };
    });
    define("hsp/compiler/jsgenerator/treeWalker.js", [ "../../klass" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var klass = require("../../klass");
        var TreeWalker = klass({
            /**
     * Start traversing a parse tree. This method takes the intermediate representation created by the parser and
     * executes, for each of the nodes, a function defined on the processor object.
     * @param {SyntaxTree} tree the syntax tree.
     * @param {Object} processor a set of function to process the tree elements.
     * @return {[type]} [description]
     */
            walk: function(tree, processor) {
                var out = [];
                if (tree) {
                    for (var i = 0; i < tree.length; i += 1) {
                        var type = tree[i].type;
                        if (processor[type]) {
                            out.push(processor[type](tree[i], this));
                        }
                    }
                }
                return out;
            },
            /**
     * Execute a callback on each element of an array. The callback receives the value of the array. This method returns
     * an array with the return value of the callbacks if not null.
     * @param {Array} array the input array.
     * @param {Function} callback the callback.
     * @return {Array} an array made with the result of each callback.
     */
            each: function(array, callback) {
                var result = [];
                for (var i = 0; i < array.length; i += 1) {
                    var value = callback(array[i]);
                    if (value !== null) {
                        result.push(value);
                    }
                }
                return result;
            }
        });
        exports.TreeWalker = TreeWalker;
    });
    define("hsp/compiler/jsgenerator/templateWalker.js", [ "../../klass", "./treeWalker" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var klass = require("../../klass");
        var TreeWalker = require("./treeWalker").TreeWalker;
        /**
 * Walker object used to generate the template script and store some contextual information such as errors or scope..
 */
        var TemplateWalker = klass({
            $extends: TreeWalker,
            /**
     * Constructor.
     * @param {String} fileName the name of the file being compiled.
     * @param {String} dirPath the directory path.
     * @param {String} mode the type of module system the code shold comply with: either "commonJS" or "global"
     * @param {String} globalRef the name of the runtime global reference when the "global" mode is used (default: "hsp")
     */
            $constructor: function(fileName, dirPath, mode, globalRef) {
                this.fileName = fileName;
                this.dirPath = dirPath;
                this.templates = {};
                // used by processors to store intermediate values in order to ease testing
                this.globals = {};
                // global validation code for each template - used for unit testing
                this.errors = [];
                this.resetGlobalRefs();
                this.resetScope();
                this.mode = {};
                if (mode === "global") {
                    this.mode.isGlobal = true;
                } else if (mode === "commonJS" || mode === undefined) {
                    this.mode.isCommonJS = true;
                } else {
                    this.logError("Invalid compilation mode option: " + mode);
                }
                this.globalRef = globalRef ? globalRef : "hsp";
            },
            /**
     * Adds an error to the current error list.
     * @param {String} description the error description
     * @param {Object} errdesc additional object (block, node, ...) which can contain additional info about the error (line/column number, code).
     */
            logError: function(description, errdesc) {
                var desc = {
                    description: description
                };
                if (errdesc) {
                    if (errdesc.line) {
                        desc.line = errdesc.line;
                        desc.column = errdesc.column;
                    }
                    if (errdesc.code) {
                        desc.code = errdesc.code;
                    }
                }
                this.errors.push(desc);
            },
            /**
     * Resets the list of global variables that have been found since the last reset
     */
            resetGlobalRefs: function() {
                this._globals = [];
                this._globalKeys = {};
            },
            /**
     * Adds a global reference (e.g. "foo") to the current _globals list.
     * @param {String} ref the reference key.
     */
            addGlobalRef: function(ref) {
                if (!this._globalKeys[ref]) {
                    this._globals.push(ref);
                    this._globalKeys[ref] = true;
                }
            },
            /**
     * Resets the scope variables that are used to determine if a variable name is in the current scope.
     */
            resetScope: function() {
                this._scopes = [ {} ];
                this._scope = this._scopes[0];
            },
            /**
     * Adds a scope variable.
     * @param {String} varName the variable name.
     */
            addScopeVariable: function(varName) {
                this._scope[varName] = true;
            },
            /**
     * Removes a scope variable.
     * @param {String} varName the variable name.
     */
            rmScopeVariable: function(varName) {
                this._scope[varName] = null;
            },
            /**
     * Checks if a scope variable exists.
     * @param {String} varName the variable name.
     * @return {Boolean} true if it exists.
     */
            isInScope: function(varName) {
                if (varName === "scope") {
                    return true;
                }
                return this._scope[varName] ? true : false;
            },
            /**
     * Pushes a sub scope.
     * @param {Array} varArray an array of variable.
     */
            pushSubScope: function(varArray) {
                var newScope = Object.create(this._scope);
                for (var i = 0; i < varArray.length; i++) {
                    newScope[varArray[i]] = true;
                }
                this._scopes.push(newScope);
                this._scope = this._scopes[this._scopes.length - 1];
            },
            /**
     * Pops a sub scope.
     */
            popSubScope: function() {
                this._scopes.pop();
                this._scope = this._scopes[this._scopes.length - 1];
            }
        });
        exports.TemplateWalker = TemplateWalker;
    });
    define("hsp/expressions/identifiers.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /*
 * Copyright 2014 Amadeus s.a.s.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        module.exports = function getIdentifiers(tree) {
            var partialResult;
            if (tree instanceof Array) {
                partialResult = [];
                if (tree.length > 0) {
                    for (var i = 0; i < tree.length; i++) {
                        partialResult = partialResult.concat(getIdentifiers(tree[i]));
                    }
                }
                return partialResult;
            }
            if (tree.a === "literal") {
                return [];
            } else if (tree.a === "idn") {
                return [ tree.v ];
            } else if (tree.a === "unr") {
                return getIdentifiers(tree.l);
            } else if (tree.a === "bnr") {
                return getIdentifiers(tree.l).concat(getIdentifiers(tree.r));
            } else if (tree.a === "tnr") {
                return getIdentifiers(tree.l).concat(getIdentifiers(tree.r)).concat(getIdentifiers(tree.othr));
            } else {
                throw new Error("unknown entry" + JSON.stringify(tree));
            }
        };
    });
    define("hsp/compiler/jsgenerator/processors.js", [ "../../expressions/parser", "../../expressions/identifiers" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var exParser = require("../../expressions/parser");
        var exIdentifiers = require("../../expressions/identifiers");
        /**
 * Escapes new lines characters in a string.
 * @param {String} text the input string.
 * @return {String} the excaped strin.
 */
        function escapeNewLines(text) {
            return text.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\n/g, "\\n");
        }
        /**
 * Text outside a template, just return what we've got.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["plaintext"] = function(node, walker) {
            return node.value;
        };
        /**
 * Template definition, this is the root of the tree, return a self calling function that recursively applies
 * - walker.walk on its content array
 * - walker.each on its arguments definition, used for simple serialization
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["template"] = function(node, walker) {
            var templateName = node.name;
            var CRLF = "\r\n";
            //Adds template arguments to the scope
            if (node.args) {
                for (var i = 0; i < node.args.length; i++) {
                    walker.addScopeVariable(node.args[i]);
                }
            } else if (node.controller) {
                walker.addScopeVariable(node.controller.ref);
            }
            //Generates the code of the template's content
            var templateCode = [ "[", [ "__s" ].concat(walker.walk(node.content, module.exports)).join(","), "]" ].join("");
            var globals = walker._globals;
            //Generates globals validation statement - e.g. var _c;try {_c=c} catch(e) {};
            var globalsStatement = [], globalsLength = globals.length;
            var scopeStatements = [], scopeStr;
            if (globalsLength) {
                var gnm;
                globalsStatement = [ "  var _" + globals.join(",_") + ";" ];
                for (var i = 0; i < globalsLength; i++) {
                    gnm = globals[i];
                    globalsStatement.push("try {_" + gnm + "=", gnm, "} catch(e) {_" + gnm + "=n.g('", gnm, "')};");
                    scopeStatements.push(gnm + " : typeof " + gnm + " === 'undefined' ? n.g('" + gnm + "') : " + gnm);
                }
            }
            globalsStatement.push(CRLF);
            var globalsStatementString = globalsStatement.join("");
            scopeStr = "  var __s = {" + scopeStatements.join(", ") + "};" + CRLF;
            //Resets template scope and global list
            walker.resetScope();
            walker.resetGlobalRefs();
            walker.templates[templateName] = templateCode;
            var exportString = "";
            if (node.isExport === true) {
                exportString = " =exports." + templateName;
            }
            var hspRef = 'require("hsp/rt")';
            if (walker.mode.isGlobal) {
                hspRef = walker.globalRef;
                // default: "hsp"
                exportString = "";
            }
            if (node.controller) {
                var path = node.controller.path;
                return [ "var ", templateName, exportString, " = ", hspRef, ".template({ctl:[", path[0], ",", walker.each(path, argAsString), '],ref:"', node.controller.ref, '"}, function(n){', CRLF, globalsStatementString, scopeStr, "  return ", templateCode, ";", CRLF, "});", CRLF ].join("");
            } else {
                return [ "var ", templateName, exportString, " = ", hspRef, ".template([", walker.each(node.args, argAsString), "], function(n){", CRLF, globalsStatementString, scopeStr, "  return ", templateCode, ";", CRLF, "});", CRLF ].join("");
            }
        };
        /**
 * Generates a text node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["text"] = function(node, walker) {
            if (node.value === undefined) {
                console.dir(node);
                return 'n.$text(0,[""])';
            }
            return [ 'n.$text(0,["', escapeNewLines(node.value.replace(/"/g, '\\"')), '"])' ].join("");
        };
        /**
 * For a given value double it's definition returning "value",value.
 * This method should only be called on object literals (strings).
 * @param {String} value the initial value.
 * @return {String} the doubled value.
 */
        function argAsString(value) {
            // No need to toString because it's already a string
            return '"' + value + '"';
        }
        /**
 * Generate a textblock node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["textblock"] = function(node, walker) {
            // we should generate sth like
            // n.$text({e1:[1,"person","firstName"],e2:[1,"person","lastName"]},["Hello ",1," ",2,"!"])
            var textBlock = formatTextBlock(node, 1, walker);
            return [ "n.$text(", textBlock.exprArg, ",", textBlock.blockArgs, ")" ].join("");
        };
        /**
 * Generates a log expression.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["log"] = function(node, walker) {
            var expr, index = 1, code = [], indexes = [];
            for (var i = 0; i < node.exprs.length; i++) {
                expr = formatExpression(node.exprs[i], index, walker);
                index = expr.nextIndex;
                indexes.push(expr.exprIdx);
                code.push(expr.code);
            }
            return [ "n.log({", code.join(","), "},'", walker.fileName, "','", walker.dirPath, "',", node.line, ",", node.column, ")" ].join("");
        };
        /**
 * Generates a let expression.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["let"] = function(node, walker) {
            var expr = formatExpression(node.assignments[0], 1, walker);
            var wholeAst = exParser(node.assignments[0].value);
            var assignAst, assignmentsAsts = wholeAst instanceof Array ? wholeAst : [ wholeAst ];
            //check if all the assignments are properly constructed
            for (var i = 0; i < assignmentsAsts.length; i++) {
                assignAst = assignmentsAsts[i];
                if (assignAst.a === "bnr" && assignAst.v === "=") {
                    walker.addScopeVariable(assignAst.l.v);
                } else {
                    walker.logError("Unsupported expression: " + node.assignments[0].value);
                }
            }
            return [ "n.let({", expr.code, "})" ].join("");
        };
        /**
 * Generates an if node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["if"] = function(node, walker) {
            // we should generate sth like
            // n.$if({e1:[1,"person","firstName"]}, 1, [n.$text({e1:[1,"person","firstName"]},["Hello ",1])], [..])
            var expr = formatExpression(node.condition, 1, walker);
            var content1 = ",[]", content2 = "";
            if (node.content1) {
                content1 = ",[" + walker.walk(node.content1, module.exports).join(",") + "]";
            }
            if (node.content2) {
                content2 = ",[" + walker.walk(node.content2, module.exports).join(",") + "]";
            }
            if (expr.code !== "") {
                expr.code = "{" + expr.code + "}";
            }
            return [ "n.$if(", expr.code, ",", expr.exprIdx, content1, content2, ")" ].join("");
        };
        /**
 * Generates a foreach node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["foreach"] = function(node, walker) {
            // we should generate sth like
            // n.$foreach( {e1: [1, 0, "things"]}, "thing", "thing_key", 1, [...])
            var expr = formatExpression(node.collection, 1, walker);
            var content = "[]";
            if (node.content) {
                // add all contextual variables
                walker.pushSubScope([ node.item, node.key, node.item + "_isfirst", node.item + "_islast" ]);
                content = "[" + walker.walk(node.content, module.exports).join(",") + "]";
                walker.popSubScope();
            }
            if (expr.code !== "") {
                expr.code = "{" + expr.code + "}";
            }
            var forType = 0;
            // to support types than 'in'
            return [ "n.$foreach(", expr.code, ',"', node.key, '","', node.item, '",', forType, ",", expr.exprIdx, ",", content, ")" ].join("");
        };
        /*
 * Manages element and component nodes.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        function elementOrComponent(node, walker) {
            // we should generate sth like
            // n.elt("div", {e1:[0,0,"arg"]}, {"title":["",1]}, 0, [...])
            var attributeContent = "0", eventContent = "0", exprCode = "0", attributes = node.attributes, length = attributes.length;
            if (length > 0) {
                var list, attributeName, attributesList = [], eventList = [], exprList = [], attribute, type, exprIndex = 1;
                for (var i = 0; length > i; i++) {
                    attribute = attributes[i];
                    list = attributesList;
                    attributeName = attribute.name;
                    if (attribute.name.match(/^on/i)) {
                        // this is an event handler
                        list = eventList;
                        attributeName = attribute.name.slice(2);
                    }
                    type = attribute.type;
                    if (type === "text") {
                        list.push('"' + attributeName + '":"' + attribute.value + '"');
                    } else if (type === "expression") {
                        var expr = formatExpression(attribute, exprIndex, walker);
                        exprIndex = expr.nextIndex;
                        exprList.push(expr.code);
                        if (list === eventList) {
                            list.push('"' + attributeName + '":' + expr.exprIdx);
                        } else {
                            list.push('"' + attributeName + '":["",' + expr.exprIdx + "]");
                        }
                    } else if (type === "textblock") {
                        var textBlock = formatTextBlock(attribute, exprIndex, walker);
                        exprIndex = textBlock.nextIndex;
                        if (textBlock.exprArg !== "0") {
                            exprList.push(textBlock.exprArg.slice(1, -1));
                        }
                        list.push('"' + attributeName + '":' + textBlock.blockArgs);
                    } else if (type === "name") {
                        list.push('"' + attributeName + '":null');
                    } else {
                        walker.logError("Invalid attribute type: " + type);
                    }
                }
                if (attributesList.length) {
                    attributeContent = "{" + attributesList.join(",") + "}";
                }
                if (eventList.length) {
                    eventContent = "{" + eventList.join(",") + "}";
                }
                exprCode = exprList.length === 0 ? "0" : "{" + exprList.join(",") + "}";
            }
            var content = "";
            if (node.content && node.content.length) {
                content = ",[" + walker.walk(node.content, module.exports).join(",") + "]";
            }
            return [ exprCode, ",", attributeContent, ",", eventContent, content ].join("");
        }
        /**
 * Generates an element node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["element"] = function(node, walker) {
            var generatedNode = elementOrComponent(node, walker);
            var subScope = node.needSubScope === true ? ",1" : "";
            return [ 'n.elt("', node.name, '",', generatedNode, subScope, ")" ].join("");
        };
        /**
 * Generates a component node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["component"] = function(node, walker) {
            var generatedNode = elementOrComponent(node, walker);
            var path = node.ref.path;
            // TODO: a path is a special case of an expression
            // components should be refactored to use expressions
            var globalRoot, root = path[0];
            if (walker.isInScope(root)) {
                globalRoot = "null";
            } else {
                walker.addGlobalRef(root);
                globalRoot = "_" + root;
            }
            return [ "n.cpt([", globalRoot, ',"', path.join('","'), '"],', generatedNode, ")" ].join("");
        };
        /**
 * Generates a cptattribute node.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {TreeWalker} walker the template walker instance.
 * @return {String} a snippet of Javascript code built from the node.
 */
        exports["cptattribute"] = function(node, walker) {
            var generatedNode = elementOrComponent(node, walker);
            return [ 'n.catt("', node.name, '",', generatedNode, ")" ].join("");
        };
        /**
 * Formats an expression according to its category.
 * @param {Object} expression the expression to format.
 * @param {Integer} firstIndex index of the expression.
 * @param {TemplateWalker} walker the template walker instance.
 * @return {Object} the expression string and the next expression index that can be used
 */
        function formatExpression(expression, firstIndex, walker) {
            var category = expression.category, codeStmts, code = "", nextIndex = firstIndex;
            var exprIndex = firstIndex;
            var expAst;
            if (category === "jsexptext") {
                //compile the expression to detect errors and parse-out identifiers
                try {
                    expAst = exParser(expression.value);
                    exIdentifiers(expAst).forEach(function(ident) {
                        walker.addGlobalRef(ident);
                    });
                    codeStmts = [ "e", exprIndex, ':[9,"', ("" + expression.value).replace(/"/g, '\\"').replace(/\\\\"/g, '\\"'), '"' ];
                    if (expression.bound === false) {
                        codeStmts.push(",false");
                    }
                    codeStmts.push("]");
                    code = codeStmts.join("");
                } catch (err) {
                    walker.logError("Invalid expression: '" + expression.value + "'", expression);
                }
                nextIndex++;
            } else {
                walker.logError("Unsupported expression: " + category, expression);
            }
            return {
                code: code,
                ast: expAst,
                exprIdx: exprIndex,
                nextIndex: nextIndex
            };
        }
        /**
 * Format the textblock content for textblock and attribute nodes.
 * @param {Node} node the current Node object as built by the treebuilder.
 * @param {Integer} nextExprIndex the index of the next expression.
 * @param {TreeWalker} walker the template walker instance.
 * @return {Object} a snippet of Javascript code built from the node.
 */
        function formatTextBlock(node, nextExprIndex, walker) {
            var content = node.content, item, exprArray = [], args = [], index = 0;
            // idx is the index in the $text array
            // (=args)
            for (var i = 0; i < content.length; i++) {
                item = content[i];
                if (item.type === "text") {
                    if (index % 2 === 0) {
                        // even index: arg must be a string
                        args[index] = '"' + escapeNewLines(item.value.replace(/"/g, '\\"')) + '"';
                        index++;
                    } else {
                        // odd index: arg must be an expression - so add the text to the previous item
                        if (index > 0) {
                            args[index - 1] = args[index - 1].slice(0, -1) + escapeNewLines(item.value.replace(/"/g, '\\"')) + '"';
                        } else {
                            // we should never get there as index is odd !
                            walker.logError("Invalid textblock structure", node);
                        }
                    }
                } else if (item.type === "expression") {
                    if (index % 2 === 0) {
                        // even index: arg must be a string
                        args[index] = '""';
                        index++;
                    }
                    var expr = formatExpression(item, nextExprIndex, walker);
                    nextExprIndex = expr.nextIndex;
                    if (expr.code) {
                        if (expr.ast instanceof Array) {
                            //it is a multi-statement expression that is not allowed in this context
                            walker.logError("Invalid expression: " + item.value, item);
                            args[index] = 0;
                        } else {
                            exprArray.push(expr.code);
                            args[index] = expr.exprIdx;
                        }
                    } else {
                        args[index] = 0;
                    }
                    index++;
                }
            }
            return {
                exprArg: exprArray.length ? "{" + exprArray.join(",") + "}" : "0",
                nextIndex: nextExprIndex,
                blockArgs: args.length ? "[" + args.join(",") + "]" : "[]"
            };
        }
    });
    define("acorn/acorn.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        // Acorn is a tiny, fast JavaScript parser written in JavaScript.
        //
        // Acorn was written by Marijn Haverbeke and released under an MIT
        // license. The Unicode regexps (for identifiers and whitespace) were
        // taken from [Esprima](http://esprima.org) by Ariya Hidayat.
        //
        // Git repositories for Acorn are available at
        //
        //     http://marijnhaverbeke.nl/git/acorn
        //     https://github.com/marijnh/acorn.git
        //
        // Please use the [github bug tracker][ghbt] to report issues.
        //
        // [ghbt]: https://github.com/marijnh/acorn/issues
        //
        // This file defines the main parser interface. The library also comes
        // with a [error-tolerant parser][dammit] and an
        // [abstract syntax tree walker][walk], defined in other files.
        //
        // [dammit]: acorn_loose.js
        // [walk]: util/walk.js
        (function(exports) {
            "use strict";
            exports.version = "0.1.0";
            // The main exported interface (under `self.acorn` when in the
            // browser) is a `parse` function that takes a code string and
            // returns an abstract syntax tree as specified by [Mozilla parser
            // API][api], with the caveat that the SpiderMonkey-specific syntax
            // (`let`, `yield`, inline XML, etc) is not recognized.
            //
            // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
            var options, input, inputLen, sourceFile;
            exports.parse = function(inpt, opts) {
                input = String(inpt);
                inputLen = input.length;
                setOptions(opts);
                initTokenState();
                return parseTopLevel(options.program);
            };
            // A second optional argument can be given to further configure
            // the parser process. These options are recognized:
            var defaultOptions = exports.defaultOptions = {
                // `ecmaVersion` indicates the ECMAScript version to parse. Must
                // be either 3 or 5. This
                // influences support for strict mode, the set of reserved words, and
                // support for getters and setter.
                ecmaVersion: 5,
                // Turn on `strictSemicolons` to prevent the parser from doing
                // automatic semicolon insertion.
                strictSemicolons: false,
                // When `allowTrailingCommas` is false, the parser will not allow
                // trailing commas in array and object literals.
                allowTrailingCommas: true,
                // By default, reserved words are not enforced. Enable
                // `forbidReserved` to enforce them.
                forbidReserved: false,
                // When `locations` is on, `loc` properties holding objects with
                // `start` and `end` properties in `{line, column}` form (with
                // line being 1-based and column 0-based) will be attached to the
                // nodes.
                locations: false,
                // A function can be passed as `onComment` option, which will
                // cause Acorn to call that function with `(block, text, start,
                // end)` parameters whenever a comment is skipped. `block` is a
                // boolean indicating whether this is a block (`/* */`) comment,
                // `text` is the content of the comment, and `start` and `end` are
                // character offsets that denote the start and end of the comment.
                // When the `locations` option is on, two more parameters are
                // passed, the full `{line, column}` locations of the start and
                // end of the comments.
                onComment: null,
                // Nodes have their start and end characters offsets recorded in
                // `start` and `end` properties (directly on the node, rather than
                // the `loc` object, which holds line/column data. To also add a
                // [semi-standardized][range] `range` property holding a `[start,
                // end]` array with the same numbers, set the `ranges` option to
                // `true`.
                //
                // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
                ranges: false,
                // It is possible to parse multiple files into a single AST by
                // passing the tree produced by parsing the first file as
                // `program` option in subsequent parses. This will add the
                // toplevel forms of the parsed file to the `Program` (top) node
                // of an existing parse tree.
                program: null,
                // When `location` is on, you can pass this to record the source
                // file in every node's `loc` object.
                sourceFile: null
            };
            function setOptions(opts) {
                options = opts || {};
                for (var opt in defaultOptions) if (!options.hasOwnProperty(opt)) options[opt] = defaultOptions[opt];
                sourceFile = options.sourceFile || null;
            }
            // The `getLineInfo` function is mostly useful when the
            // `locations` option is off (for performance reasons) and you
            // want to find the line/column position for a given character
            // offset. `input` should be the code string that the offset refers
            // into.
            var getLineInfo = exports.getLineInfo = function(input, offset) {
                for (var line = 1, cur = 0; ;) {
                    lineBreak.lastIndex = cur;
                    var match = lineBreak.exec(input);
                    if (match && match.index < offset) {
                        ++line;
                        cur = match.index + match[0].length;
                    } else break;
                }
                return {
                    line: line,
                    column: offset - cur
                };
            };
            // Acorn is organized as a tokenizer and a recursive-descent parser.
            // The `tokenize` export provides an interface to the tokenizer.
            // Because the tokenizer is optimized for being efficiently used by
            // the Acorn parser itself, this interface is somewhat crude and not
            // very modular. Performing another parse or call to `tokenize` will
            // reset the internal state, and invalidate existing tokenizers.
            exports.tokenize = function(inpt, opts) {
                input = String(inpt);
                inputLen = input.length;
                setOptions(opts);
                initTokenState();
                var t = {};
                function getToken(forceRegexp) {
                    readToken(forceRegexp);
                    t.start = tokStart;
                    t.end = tokEnd;
                    t.startLoc = tokStartLoc;
                    t.endLoc = tokEndLoc;
                    t.type = tokType;
                    t.value = tokVal;
                    return t;
                }
                getToken.jumpTo = function(pos, reAllowed) {
                    tokPos = pos;
                    if (options.locations) {
                        tokCurLine = tokLineStart = lineBreak.lastIndex = 0;
                        var match;
                        while ((match = lineBreak.exec(input)) && match.index < pos) {
                            ++tokCurLine;
                            tokLineStart = match.index + match[0].length;
                        }
                    }
                    var ch = input.charAt(pos - 1);
                    tokRegexpAllowed = reAllowed;
                    skipSpace();
                };
                return getToken;
            };
            // State is kept in (closure-)global variables. We already saw the
            // `options`, `input`, and `inputLen` variables above.
            // The current position of the tokenizer in the input.
            var tokPos;
            // The start and end offsets of the current token.
            var tokStart, tokEnd;
            // When `options.locations` is true, these hold objects
            // containing the tokens start and end line/column pairs.
            var tokStartLoc, tokEndLoc;
            // The type and value of the current token. Token types are objects,
            // named by variables against which they can be compared, and
            // holding properties that describe them (indicating, for example,
            // the precedence of an infix operator, and the original name of a
            // keyword token). The kind of value that's held in `tokVal` depends
            // on the type of the token. For literals, it is the literal value,
            // for operators, the operator name, and so on.
            var tokType, tokVal;
            // Interal state for the tokenizer. To distinguish between division
            // operators and regular expressions, it remembers whether the last
            // token was one that is allowed to be followed by an expression.
            // (If it is, a slash is probably a regexp, if it isn't it's a
            // division operator. See the `parseStatement` function for a
            // caveat.)
            var tokRegexpAllowed;
            // When `options.locations` is true, these are used to keep
            // track of the current line, and know when a new line has been
            // entered.
            var tokCurLine, tokLineStart;
            // These store the position of the previous token, which is useful
            // when finishing a node and assigning its `end` position.
            var lastStart, lastEnd, lastEndLoc;
            // This is the parser's state. `inFunction` is used to reject
            // `return` statements outside of functions, `labels` to verify that
            // `break` and `continue` have somewhere to jump to, and `strict`
            // indicates whether strict mode is on.
            var inFunction, labels, strict;
            // This function is used to raise exceptions on parse errors. It
            // takes an offset integer (into the current `input`) to indicate
            // the location of the error, attaches the position to the end
            // of the error message, and then raises a `SyntaxError` with that
            // message.
            function raise(pos, message) {
                var loc = getLineInfo(input, pos);
                message += " (" + loc.line + ":" + loc.column + ")";
                var err = new SyntaxError(message);
                err.pos = pos;
                err.loc = loc;
                err.raisedAt = tokPos;
                throw err;
            }
            // ## Token types
            // The assignment of fine-grained, information-carrying type objects
            // allows the tokenizer to store the information it has about a
            // token in a way that is very cheap for the parser to look up.
            // All token type variables start with an underscore, to make them
            // easy to recognize.
            // These are the general types. The `type` property is only used to
            // make them recognizeable when debugging.
            var _num = {
                type: "num"
            }, _regexp = {
                type: "regexp"
            }, _string = {
                type: "string"
            };
            var _name = {
                type: "name"
            }, _eof = {
                type: "eof"
            };
            // Keyword tokens. The `keyword` property (also used in keyword-like
            // operators) indicates that the token originated from an
            // identifier-like word, which is used when parsing property names.
            //
            // The `beforeExpr` property is used to disambiguate between regular
            // expressions and divisions. It is set on all token types that can
            // be followed by an expression (thus, a slash after them would be a
            // regular expression).
            //
            // `isLoop` marks a keyword as starting a loop, which is important
            // to know when parsing a label, in order to allow or disallow
            // continue jumps to that label.
            var _break = {
                keyword: "break"
            }, _case = {
                keyword: "case",
                beforeExpr: true
            }, _catch = {
                keyword: "catch"
            };
            var _continue = {
                keyword: "continue"
            }, _debugger = {
                keyword: "debugger"
            }, _default = {
                keyword: "default"
            };
            var _do = {
                keyword: "do",
                isLoop: true
            }, _else = {
                keyword: "else",
                beforeExpr: true
            };
            var _finally = {
                keyword: "finally"
            }, _for = {
                keyword: "for",
                isLoop: true
            }, _function = {
                keyword: "function"
            };
            var _if = {
                keyword: "if"
            }, _return = {
                keyword: "return",
                beforeExpr: true
            }, _switch = {
                keyword: "switch"
            };
            var _throw = {
                keyword: "throw",
                beforeExpr: true
            }, _try = {
                keyword: "try"
            }, _var = {
                keyword: "var"
            };
            var _while = {
                keyword: "while",
                isLoop: true
            }, _with = {
                keyword: "with"
            }, _new = {
                keyword: "new",
                beforeExpr: true
            };
            var _this = {
                keyword: "this"
            };
            // The keywords that denote values.
            var _null = {
                keyword: "null",
                atomValue: null
            }, _true = {
                keyword: "true",
                atomValue: true
            };
            var _false = {
                keyword: "false",
                atomValue: false
            };
            // Some keywords are treated as regular operators. `in` sometimes
            // (when parsing `for`) needs to be tested against specifically, so
            // we assign a variable name to it for quick comparing.
            var _in = {
                keyword: "in",
                binop: 7,
                beforeExpr: true
            };
            // Map keyword names to token types.
            var keywordTypes = {
                "break": _break,
                "case": _case,
                "catch": _catch,
                "continue": _continue,
                "debugger": _debugger,
                "default": _default,
                "do": _do,
                "else": _else,
                "finally": _finally,
                "for": _for,
                "function": _function,
                "if": _if,
                "return": _return,
                "switch": _switch,
                "throw": _throw,
                "try": _try,
                "var": _var,
                "while": _while,
                "with": _with,
                "null": _null,
                "true": _true,
                "false": _false,
                "new": _new,
                "in": _in,
                "instanceof": {
                    keyword: "instanceof",
                    binop: 7,
                    beforeExpr: true
                },
                "this": _this,
                "typeof": {
                    keyword: "typeof",
                    prefix: true,
                    beforeExpr: true
                },
                "void": {
                    keyword: "void",
                    prefix: true,
                    beforeExpr: true
                },
                "delete": {
                    keyword: "delete",
                    prefix: true,
                    beforeExpr: true
                }
            };
            // Punctuation token types. Again, the `type` property is purely for debugging.
            var _bracketL = {
                type: "[",
                beforeExpr: true
            }, _bracketR = {
                type: "]"
            }, _braceL = {
                type: "{",
                beforeExpr: true
            };
            var _braceR = {
                type: "}"
            }, _parenL = {
                type: "(",
                beforeExpr: true
            }, _parenR = {
                type: ")"
            };
            var _comma = {
                type: ",",
                beforeExpr: true
            }, _semi = {
                type: ";",
                beforeExpr: true
            };
            var _colon = {
                type: ":",
                beforeExpr: true
            }, _dot = {
                type: "."
            }, _question = {
                type: "?",
                beforeExpr: true
            };
            // Operators. These carry several kinds of properties to help the
            // parser use them properly (the presence of these properties is
            // what categorizes them as operators).
            //
            // `binop`, when present, specifies that this operator is a binary
            // operator, and will refer to its precedence.
            //
            // `prefix` and `postfix` mark the operator as a prefix or postfix
            // unary operator. `isUpdate` specifies that the node produced by
            // the operator should be of type UpdateExpression rather than
            // simply UnaryExpression (`++` and `--`).
            //
            // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
            // binary operators with a very low precedence, that should result
            // in AssignmentExpression nodes.
            var _slash = {
                binop: 10,
                beforeExpr: true
            }, _eq = {
                isAssign: true,
                beforeExpr: true
            };
            var _assign = {
                isAssign: true,
                beforeExpr: true
            }, _plusmin = {
                binop: 9,
                prefix: true,
                beforeExpr: true
            };
            var _incdec = {
                postfix: true,
                prefix: true,
                isUpdate: true
            }, _prefix = {
                prefix: true,
                beforeExpr: true
            };
            var _bin1 = {
                binop: 1,
                beforeExpr: true
            }, _bin2 = {
                binop: 2,
                beforeExpr: true
            };
            var _bin3 = {
                binop: 3,
                beforeExpr: true
            }, _bin4 = {
                binop: 4,
                beforeExpr: true
            };
            var _bin5 = {
                binop: 5,
                beforeExpr: true
            }, _bin6 = {
                binop: 6,
                beforeExpr: true
            };
            var _bin7 = {
                binop: 7,
                beforeExpr: true
            }, _bin8 = {
                binop: 8,
                beforeExpr: true
            };
            var _bin10 = {
                binop: 10,
                beforeExpr: true
            };
            // Provide access to the token types for external users of the
            // tokenizer.
            exports.tokTypes = {
                bracketL: _bracketL,
                bracketR: _bracketR,
                braceL: _braceL,
                braceR: _braceR,
                parenL: _parenL,
                parenR: _parenR,
                comma: _comma,
                semi: _semi,
                colon: _colon,
                dot: _dot,
                question: _question,
                slash: _slash,
                eq: _eq,
                name: _name,
                eof: _eof,
                num: _num,
                regexp: _regexp,
                string: _string
            };
            for (var kw in keywordTypes) exports.tokTypes[kw] = keywordTypes[kw];
            // This is a trick taken from Esprima. It turns out that, on
            // non-Chrome browsers, to check whether a string is in a set, a
            // predicate containing a big ugly `switch` statement is faster than
            // a regular expression, and on Chrome the two are about on par.
            // This function uses `eval` (non-lexical) to produce such a
            // predicate from a space-separated string of words.
            //
            // It starts by sorting the words by length.
            function makePredicate(words) {
                words = words.split(" ");
                var f = "", cats = [];
                out: for (var i = 0; i < words.length; ++i) {
                    for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
                        cats[j].push(words[i]);
                        continue out;
                    }
                    cats.push([ words[i] ]);
                }
                function compareTo(arr) {
                    if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
                    f += "switch(str){";
                    for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
                    f += "return true}return false;";
                }
                // When there are more than three length categories, an outer
                // switch first dispatches on the lengths, to save on comparisons.
                if (cats.length > 3) {
                    cats.sort(function(a, b) {
                        return b.length - a.length;
                    });
                    f += "switch(str.length){";
                    for (var i = 0; i < cats.length; ++i) {
                        var cat = cats[i];
                        f += "case " + cat[0].length + ":";
                        compareTo(cat);
                    }
                    f += "}";
                } else {
                    compareTo(words);
                }
                return new Function("str", f);
            }
            // The ECMAScript 3 reserved word list.
            var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
            // ECMAScript 5 reserved words.
            var isReservedWord5 = makePredicate("class enum extends super const export import");
            // The additional reserved words in strict mode.
            var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
            // The forbidden variable names in strict mode.
            var isStrictBadIdWord = makePredicate("eval arguments");
            // And the keywords.
            var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");
            // ## Character categories
            // Big ugly regular expressions that match characters in the
            // whitespace, identifier, and identifier-start categories. These
            // are only applied when a character is found to actually have a
            // code point above 128.
            var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/;
            var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
            var nonASCIIidentifierChars = "\u0371-\u0374\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
            var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
            var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
            // Whether a single character denotes a newline.
            var newline = /[\n\r\u2028\u2029]/;
            // Matches a whole line break (where CRLF is considered a single
            // line break). Used to count lines.
            var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;
            // Test whether a given character code starts an identifier.
            function isIdentifierStart(code) {
                if (code < 65) return code === 36;
                if (code < 91) return true;
                if (code < 97) return code === 95;
                if (code < 123) return true;
                return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
            }
            // Test whether a given character is part of an identifier.
            function isIdentifierChar(code) {
                if (code < 48) return code === 36;
                if (code < 58) return true;
                if (code < 65) return false;
                if (code < 91) return true;
                if (code < 97) return code === 95;
                if (code < 123) return true;
                return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
            }
            // ## Tokenizer
            // These are used when `options.locations` is on, for the
            // `tokStartLoc` and `tokEndLoc` properties.
            function line_loc_t() {
                this.line = tokCurLine;
                this.column = tokPos - tokLineStart;
            }
            // Reset the token state. Used at the start of a parse.
            function initTokenState() {
                tokCurLine = 1;
                tokPos = tokLineStart = 0;
                tokRegexpAllowed = true;
                skipSpace();
            }
            // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
            // `tokRegexpAllowed`, and skips the space after the token, so that
            // the next one's `tokStart` will point at the right position.
            function finishToken(type, val) {
                tokEnd = tokPos;
                if (options.locations) tokEndLoc = new line_loc_t();
                tokType = type;
                skipSpace();
                tokVal = val;
                tokRegexpAllowed = type.beforeExpr;
            }
            function skipBlockComment() {
                var startLoc = options.onComment && options.locations && new line_loc_t();
                var start = tokPos, end = input.indexOf("*/", tokPos += 2);
                if (end === -1) raise(tokPos - 2, "Unterminated comment");
                tokPos = end + 2;
                if (options.locations) {
                    lineBreak.lastIndex = start;
                    var match;
                    while ((match = lineBreak.exec(input)) && match.index < tokPos) {
                        ++tokCurLine;
                        tokLineStart = match.index + match[0].length;
                    }
                }
                if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t());
            }
            function skipLineComment() {
                var start = tokPos;
                var startLoc = options.onComment && options.locations && new line_loc_t();
                var ch = input.charCodeAt(tokPos += 2);
                while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8329) {
                    ++tokPos;
                    ch = input.charCodeAt(tokPos);
                }
                if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t());
            }
            // Called at the start of the parse and after every token. Skips
            // whitespace and comments, and.
            function skipSpace() {
                while (tokPos < inputLen) {
                    var ch = input.charCodeAt(tokPos);
                    if (ch === 32) {
                        // ' '
                        ++tokPos;
                    } else if (ch === 13) {
                        ++tokPos;
                        var next = input.charCodeAt(tokPos);
                        if (next === 10) {
                            ++tokPos;
                        }
                        if (options.locations) {
                            ++tokCurLine;
                            tokLineStart = tokPos;
                        }
                    } else if (ch === 10) {
                        ++tokPos;
                        ++tokCurLine;
                        tokLineStart = tokPos;
                    } else if (ch < 14 && ch > 8) {
                        ++tokPos;
                    } else if (ch === 47) {
                        // '/'
                        var next = input.charCodeAt(tokPos + 1);
                        if (next === 42) {
                            // '*'
                            skipBlockComment();
                        } else if (next === 47) {
                            // '/'
                            skipLineComment();
                        } else break;
                    } else if (ch < 14 && ch > 8 || ch === 32 || ch === 160) {
                        // ' ', '\xa0'
                        ++tokPos;
                    } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                        ++tokPos;
                    } else {
                        break;
                    }
                }
            }
            // ### Token reading
            // This is the function that is called to fetch the next token. It
            // is somewhat obscure, because it works in character codes rather
            // than characters, and because operator parsing has been inlined
            // into it.
            //
            // All in the name of speed.
            //
            // The `forceRegexp` parameter is used in the one case where the
            // `tokRegexpAllowed` trick does not work. See `parseStatement`.
            function readToken_dot() {
                var next = input.charCodeAt(tokPos + 1);
                if (next >= 48 && next <= 57) return readNumber(true);
                ++tokPos;
                return finishToken(_dot);
            }
            function readToken_slash() {
                // '/'
                var next = input.charCodeAt(tokPos + 1);
                if (tokRegexpAllowed) {
                    ++tokPos;
                    return readRegexp();
                }
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(_slash, 1);
            }
            function readToken_mult_modulo() {
                // '%*'
                var next = input.charCodeAt(tokPos + 1);
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(_bin10, 1);
            }
            function readToken_pipe_amp(code) {
                // '|&'
                var next = input.charCodeAt(tokPos + 1);
                if (next === code) return finishOp(code === 124 ? _bin1 : _bin2, 2);
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(code === 124 ? _bin3 : _bin5, 1);
            }
            function readToken_caret() {
                // '^'
                var next = input.charCodeAt(tokPos + 1);
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(_bin4, 1);
            }
            function readToken_plus_min(code) {
                // '+-'
                var next = input.charCodeAt(tokPos + 1);
                if (next === code) return finishOp(_incdec, 2);
                if (next === 61) return finishOp(_assign, 2);
                return finishOp(_plusmin, 1);
            }
            function readToken_lt_gt(code) {
                // '<>'
                var next = input.charCodeAt(tokPos + 1);
                var size = 1;
                if (next === code) {
                    size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
                    if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
                    return finishOp(_bin8, size);
                }
                if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
                return finishOp(_bin7, size);
            }
            function readToken_eq_excl(code) {
                // '=!'
                var next = input.charCodeAt(tokPos + 1);
                if (next === 61) return finishOp(_bin6, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
                return finishOp(code === 61 ? _eq : _prefix, 1);
            }
            function getTokenFromCode(code) {
                switch (code) {
                  // The interpretation of a dot depends on whether it is followed
                    // by a digit.
                    case 46:
                    // '.'
                    return readToken_dot();

                  // Punctuation tokens.
                    case 40:
                    ++tokPos;
                    return finishToken(_parenL);

                  case 41:
                    ++tokPos;
                    return finishToken(_parenR);

                  case 59:
                    ++tokPos;
                    return finishToken(_semi);

                  case 44:
                    ++tokPos;
                    return finishToken(_comma);

                  case 91:
                    ++tokPos;
                    return finishToken(_bracketL);

                  case 93:
                    ++tokPos;
                    return finishToken(_bracketR);

                  case 123:
                    ++tokPos;
                    return finishToken(_braceL);

                  case 125:
                    ++tokPos;
                    return finishToken(_braceR);

                  case 58:
                    ++tokPos;
                    return finishToken(_colon);

                  case 63:
                    ++tokPos;
                    return finishToken(_question);

                  // '0x' is a hexadecimal number.
                    case 48:
                    // '0'
                    var next = input.charCodeAt(tokPos + 1);
                    if (next === 120 || next === 88) return readHexNumber();

                  // Anything else beginning with a digit is an integer, octal
                    // number, or float.
                    case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    // 1-9
                    return readNumber(false);

                  // Quotes produce strings.
                    case 34:
                  case 39:
                    // '"', "'"
                    return readString(code);

                  // Operators are parsed inline in tiny state machines. '=' (61) is
                    // often referred to. `finishOp` simply skips the amount of
                    // characters it is given as second argument, and returns a token
                    // of the type given by its first argument.
                    case 47:
                    // '/'
                    return readToken_slash(code);

                  case 37:
                  case 42:
                    // '%*'
                    return readToken_mult_modulo();

                  case 124:
                  case 38:
                    // '|&'
                    return readToken_pipe_amp(code);

                  case 94:
                    // '^'
                    return readToken_caret();

                  case 43:
                  case 45:
                    // '+-'
                    return readToken_plus_min(code);

                  case 60:
                  case 62:
                    // '<>'
                    return readToken_lt_gt(code);

                  case 61:
                  case 33:
                    // '=!'
                    return readToken_eq_excl(code);

                  case 126:
                    // '~'
                    return finishOp(_prefix, 1);
                }
                return false;
            }
            function readToken(forceRegexp) {
                tokStart = tokPos;
                if (options.locations) tokStartLoc = new line_loc_t();
                if (forceRegexp) return readRegexp();
                if (tokPos >= inputLen) return finishToken(_eof);
                var code = input.charCodeAt(tokPos);
                // Identifier or keyword. '\uXXXX' sequences are allowed in
                // identifiers, so '\' also dispatches to that.
                if (isIdentifierStart(code) || code === 92) return readWord();
                var tok = getTokenFromCode(code);
                if (tok === false) {
                    // If we are here, we either found a non-ASCII identifier
                    // character, or something that's entirely disallowed.
                    var ch = String.fromCharCode(code);
                    if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
                    raise(tokPos, "Unexpected character '" + ch + "'");
                }
                return tok;
            }
            function finishOp(type, size) {
                var str = input.slice(tokPos, tokPos + size);
                tokPos += size;
                finishToken(type, str);
            }
            // Parse a regular expression. Some context-awareness is necessary,
            // since a '/' inside a '[]' set does not end the expression.
            function readRegexp() {
                var content = "", escaped, inClass, start = tokPos;
                for (;;) {
                    if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
                    var ch = input.charAt(tokPos);
                    if (newline.test(ch)) raise(start, "Unterminated regular expression");
                    if (!escaped) {
                        if (ch === "[") inClass = true; else if (ch === "]" && inClass) inClass = false; else if (ch === "/" && !inClass) break;
                        escaped = ch === "\\";
                    } else escaped = false;
                    ++tokPos;
                }
                var content = input.slice(start, tokPos);
                ++tokPos;
                // Need to use `readWord1` because '\uXXXX' sequences are allowed
                // here (don't ask).
                var mods = readWord1();
                if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
                return finishToken(_regexp, new RegExp(content, mods));
            }
            // Read an integer in the given radix. Return null if zero digits
            // were read, the integer value otherwise. When `len` is given, this
            // will return `null` unless the integer has exactly `len` digits.
            function readInt(radix, len) {
                var start = tokPos, total = 0;
                for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                    var code = input.charCodeAt(tokPos), val;
                    if (code >= 97) val = code - 97 + 10; else if (code >= 65) val = code - 65 + 10; else if (code >= 48 && code <= 57) val = code - 48; else val = Infinity;
                    if (val >= radix) break;
                    ++tokPos;
                    total = total * radix + val;
                }
                if (tokPos === start || len != null && tokPos - start !== len) return null;
                return total;
            }
            function readHexNumber() {
                tokPos += 2;
                // 0x
                var val = readInt(16);
                if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
                if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
                return finishToken(_num, val);
            }
            // Read an integer, octal integer, or floating-point number.
            function readNumber(startsWithDot) {
                var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
                if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
                if (input.charCodeAt(tokPos) === 46) {
                    ++tokPos;
                    readInt(10);
                    isFloat = true;
                }
                var next = input.charCodeAt(tokPos);
                if (next === 69 || next === 101) {
                    // 'eE'
                    next = input.charCodeAt(++tokPos);
                    if (next === 43 || next === 45) ++tokPos;
                    // '+-'
                    if (readInt(10) === null) raise(start, "Invalid number");
                    isFloat = true;
                }
                if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
                var str = input.slice(start, tokPos), val;
                if (isFloat) val = parseFloat(str); else if (!octal || str.length === 1) val = parseInt(str, 10); else if (/[89]/.test(str) || strict) raise(start, "Invalid number"); else val = parseInt(str, 8);
                return finishToken(_num, val);
            }
            // Read a string value, interpreting backslash-escapes.
            var rs_str = [];
            function readString(quote) {
                tokPos++;
                rs_str.length = 0;
                for (;;) {
                    if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
                    var ch = input.charCodeAt(tokPos);
                    if (ch === quote) {
                        ++tokPos;
                        return finishToken(_string, String.fromCharCode.apply(null, rs_str));
                    }
                    if (ch === 92) {
                        // '\'
                        ch = input.charCodeAt(++tokPos);
                        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
                        if (octal) octal = octal[0];
                        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, octal.length - 1);
                        if (octal === "0") octal = null;
                        ++tokPos;
                        if (octal) {
                            if (strict) raise(tokPos - 2, "Octal literal in strict mode");
                            rs_str.push(parseInt(octal, 8));
                            tokPos += octal.length - 1;
                        } else {
                            switch (ch) {
                              case 110:
                                rs_str.push(10);
                                break;

                              // 'n' -> '\n'
                                case 114:
                                rs_str.push(13);
                                break;

                              // 'r' -> '\r'
                                case 120:
                                rs_str.push(readHexChar(2));
                                break;

                              // 'x'
                                case 117:
                                rs_str.push(readHexChar(4));
                                break;

                              // 'u'
                                case 85:
                                rs_str.push(readHexChar(8));
                                break;

                              // 'U'
                                case 116:
                                rs_str.push(9);
                                break;

                              // 't' -> '\t'
                                case 98:
                                rs_str.push(8);
                                break;

                              // 'b' -> '\b'
                                case 118:
                                rs_str.push(11);
                                break;

                              // 'v' -> '\u000b'
                                case 102:
                                rs_str.push(12);
                                break;

                              // 'f' -> '\f'
                                case 48:
                                rs_str.push(0);
                                break;

                              // 0 -> '\0'
                                case 13:
                                if (input.charCodeAt(tokPos) === 10) ++tokPos;

                              // '\r\n'
                                case 10:
                                // ' \n'
                                if (options.locations) {
                                    tokLineStart = tokPos;
                                    ++tokCurLine;
                                }
                                break;

                              default:
                                rs_str.push(ch);
                                break;
                            }
                        }
                    } else {
                        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8329) raise(tokStart, "Unterminated string constant");
                        rs_str.push(ch);
                        // '\'
                        ++tokPos;
                    }
                }
            }
            // Used to read character escape sequences ('\x', '\u', '\U').
            function readHexChar(len) {
                var n = readInt(16, len);
                if (n === null) raise(tokStart, "Bad character escape sequence");
                return n;
            }
            // Used to signal to callers of `readWord1` whether the word
            // contained any escape sequences. This is needed because words with
            // escape sequences must not be interpreted as keywords.
            var containsEsc;
            // Read an identifier, and return it as a string. Sets `containsEsc`
            // to whether the word contained a '\u' escape.
            //
            // Only builds up the word character-by-character when it actually
            // containeds an escape, as a micro-optimization.
            function readWord1() {
                containsEsc = false;
                var word, first = true, start = tokPos;
                for (;;) {
                    var ch = input.charCodeAt(tokPos);
                    if (isIdentifierChar(ch)) {
                        if (containsEsc) word += input.charAt(tokPos);
                        ++tokPos;
                    } else if (ch === 92) {
                        // "\"
                        if (!containsEsc) word = input.slice(start, tokPos);
                        containsEsc = true;
                        if (input.charCodeAt(++tokPos) != 117) // "u"
                        raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
                        ++tokPos;
                        var esc = readHexChar(4);
                        var escStr = String.fromCharCode(esc);
                        if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
                        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, "Invalid Unicode escape");
                        word += escStr;
                    } else {
                        break;
                    }
                    first = false;
                }
                return containsEsc ? word : input.slice(start, tokPos);
            }
            // Read an identifier or keyword token. Will check for reserved
            // words when necessary.
            function readWord() {
                var word = readWord1();
                var type = _name;
                if (!containsEsc) {
                    if (isKeyword(word)) type = keywordTypes[word]; else if (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) || strict && isStrictReservedWord(word)) raise(tokStart, "The keyword '" + word + "' is reserved");
                }
                return finishToken(type, word);
            }
            // ## Parser
            // A recursive descent parser operates by defining functions for all
            // syntactic elements, and recursively calling those, each function
            // advancing the input stream and returning an AST node. Precedence
            // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
            // instead of `(!x)[1]` is handled by the fact that the parser
            // function that parses unary prefix operators is called first, and
            // in turn calls the function that parses `[]` subscripts  that
            // way, it'll receive the node for `x[1]` already parsed, and wraps
            // *that* in the unary operator node.
            //
            // Acorn uses an [operator precedence parser][opp] to handle binary
            // operator precedence, because it is much more compact than using
            // the technique outlined above, which uses different, nesting
            // functions to specify precedence, for all of the ten binary
            // precedence levels that JavaScript defines.
            //
            // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
            // ### Parser utilities
            // Continue to the next token.
            function next() {
                lastStart = tokStart;
                lastEnd = tokEnd;
                lastEndLoc = tokEndLoc;
                readToken();
            }
            // Enter strict mode. Re-reads the next token to please pedantic
            // tests ("use strict"; 010; -- should fail).
            function setStrict(strct) {
                strict = strct;
                tokPos = lastEnd;
                skipSpace();
                readToken();
            }
            // Start an AST node, attaching a start offset.
            function node_t() {
                this.type = null;
                this.start = tokStart;
                this.end = null;
            }
            function node_loc_t() {
                this.start = tokStartLoc;
                this.end = null;
                if (sourceFile !== null) this.source = sourceFile;
            }
            function startNode() {
                var node = new node_t();
                if (options.locations) node.loc = new node_loc_t();
                if (options.ranges) node.range = [ tokStart, 0 ];
                return node;
            }
            // Start a node whose start offset information should be based on
            // the start of another node. For example, a binary operator node is
            // only started after its left-hand side has already been parsed.
            function startNodeFrom(other) {
                var node = new node_t();
                node.start = other.start;
                if (options.locations) {
                    node.loc = new node_loc_t();
                    node.loc.start = other.loc.start;
                }
                if (options.ranges) node.range = [ other.range[0], 0 ];
                return node;
            }
            // Finish an AST node, adding `type` and `end` properties.
            function finishNode(node, type) {
                node.type = type;
                node.end = lastEnd;
                if (options.locations) node.loc.end = lastEndLoc;
                if (options.ranges) node.range[1] = lastEnd;
                return node;
            }
            // Test whether a statement node is the string literal `"use strict"`.
            function isUseStrict(stmt) {
                return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
            }
            // Predicate that tests whether the next token is of the given
            // type, and if yes, consumes it as a side effect.
            function eat(type) {
                if (tokType === type) {
                    next();
                    return true;
                }
            }
            // Test whether a semicolon can be inserted at the current position.
            function canInsertSemicolon() {
                return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
            }
            // Consume a semicolon, or, failing that, see if we are allowed to
            // pretend that there is a semicolon at this position.
            function semicolon() {
                if (!eat(_semi) && !canInsertSemicolon()) unexpected();
            }
            // Expect a token of a given type. If found, consume it, otherwise,
            // raise an unexpected token error.
            function expect(type) {
                if (tokType === type) next(); else unexpected();
            }
            // Raise an unexpected token error.
            function unexpected() {
                raise(tokStart, "Unexpected token");
            }
            // Verify that a node is an lval  something that can be assigned
            // to.
            function checkLVal(expr) {
                if (expr.type !== "Identifier" && expr.type !== "MemberExpression") raise(expr.start, "Assigning to rvalue");
                if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name)) raise(expr.start, "Assigning to " + expr.name + " in strict mode");
            }
            // ### Statement parsing
            // Parse a program. Initializes the parser, reads any number of
            // statements, and wraps them in a Program node.  Optionally takes a
            // `program` argument.  If present, the statements will be appended
            // to its body instead of creating a new node.
            function parseTopLevel(program) {
                lastStart = lastEnd = tokPos;
                if (options.locations) lastEndLoc = new line_loc_t();
                inFunction = strict = null;
                labels = [];
                readToken();
                var node = program || startNode(), first = true;
                if (!program) node.body = [];
                while (tokType !== _eof) {
                    var stmt = parseStatement();
                    node.body.push(stmt);
                    if (first && isUseStrict(stmt)) setStrict(true);
                    first = false;
                }
                return finishNode(node, "Program");
            }
            var loopLabel = {
                kind: "loop"
            }, switchLabel = {
                kind: "switch"
            };
            // Parse a single statement.
            //
            // If expecting a statement and finding a slash operator, parse a
            // regular expression literal. This is to handle cases like
            // `if (foo) /blah/.exec(foo);`, where looking at the previous token
            // does not help.
            function parseStatement() {
                if (tokType === _slash) readToken(true);
                var starttype = tokType, node = startNode();
                // Most types of statements are recognized by the keyword they
                // start with. Many are trivial to parse, some require a bit of
                // complexity.
                switch (starttype) {
                  case _break:
                  case _continue:
                    next();
                    var isBreak = starttype === _break;
                    if (eat(_semi) || canInsertSemicolon()) node.label = null; else if (tokType !== _name) unexpected(); else {
                        node.label = parseIdent();
                        semicolon();
                    }
                    // Verify that there is an actual destination to break or
                    // continue to.
                    for (var i = 0; i < labels.length; ++i) {
                        var lab = labels[i];
                        if (node.label == null || lab.name === node.label.name) {
                            if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                            if (node.label && isBreak) break;
                        }
                    }
                    if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
                    return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

                  case _debugger:
                    next();
                    semicolon();
                    return finishNode(node, "DebuggerStatement");

                  case _do:
                    next();
                    labels.push(loopLabel);
                    node.body = parseStatement();
                    labels.pop();
                    expect(_while);
                    node.test = parseParenExpression();
                    semicolon();
                    return finishNode(node, "DoWhileStatement");

                  // Disambiguating between a `for` and a `for`/`in` loop is
                    // non-trivial. Basically, we have to parse the init `var`
                    // statement or expression, disallowing the `in` operator (see
                    // the second parameter to `parseExpression`), and then check
                    // whether the next token is `in`. When there is no init part
                    // (semicolon immediately after the opening parenthesis), it is
                    // a regular `for` loop.
                    case _for:
                    next();
                    labels.push(loopLabel);
                    expect(_parenL);
                    if (tokType === _semi) return parseFor(node, null);
                    if (tokType === _var) {
                        var init = startNode();
                        next();
                        parseVar(init, true);
                        if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);
                        return parseFor(node, init);
                    }
                    var init = parseExpression(false, true);
                    if (eat(_in)) {
                        checkLVal(init);
                        return parseForIn(node, init);
                    }
                    return parseFor(node, init);

                  case _function:
                    next();
                    return parseFunction(node, true);

                  case _if:
                    next();
                    node.test = parseParenExpression();
                    node.consequent = parseStatement();
                    node.alternate = eat(_else) ? parseStatement() : null;
                    return finishNode(node, "IfStatement");

                  case _return:
                    if (!inFunction) raise(tokStart, "'return' outside of function");
                    next();
                    // In `return` (and `break`/`continue`), the keywords with
                    // optional arguments, we eagerly look for a semicolon or the
                    // possibility to insert one.
                    if (eat(_semi) || canInsertSemicolon()) node.argument = null; else {
                        node.argument = parseExpression();
                        semicolon();
                    }
                    return finishNode(node, "ReturnStatement");

                  case _switch:
                    next();
                    node.discriminant = parseParenExpression();
                    node.cases = [];
                    expect(_braceL);
                    labels.push(switchLabel);
                    // Statements under must be grouped (by label) in SwitchCase
                    // nodes. `cur` is used to keep the node that we are currently
                    // adding statements to.
                    for (var cur, sawDefault; tokType != _braceR; ) {
                        if (tokType === _case || tokType === _default) {
                            var isCase = tokType === _case;
                            if (cur) finishNode(cur, "SwitchCase");
                            node.cases.push(cur = startNode());
                            cur.consequent = [];
                            next();
                            if (isCase) cur.test = parseExpression(); else {
                                if (sawDefault) raise(lastStart, "Multiple default clauses");
                                sawDefault = true;
                                cur.test = null;
                            }
                            expect(_colon);
                        } else {
                            if (!cur) unexpected();
                            cur.consequent.push(parseStatement());
                        }
                    }
                    if (cur) finishNode(cur, "SwitchCase");
                    next();
                    // Closing brace
                    labels.pop();
                    return finishNode(node, "SwitchStatement");

                  case _throw:
                    next();
                    if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, "Illegal newline after throw");
                    node.argument = parseExpression();
                    semicolon();
                    return finishNode(node, "ThrowStatement");

                  case _try:
                    next();
                    node.block = parseBlock();
                    node.handlers = [];
                    while (tokType === _catch) {
                        var clause = startNode();
                        next();
                        expect(_parenL);
                        clause.param = parseIdent();
                        if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
                        expect(_parenR);
                        clause.guard = null;
                        clause.body = parseBlock();
                        node.handlers.push(finishNode(clause, "CatchClause"));
                    }
                    node.finalizer = eat(_finally) ? parseBlock() : null;
                    if (!node.handlers.length && !node.finalizer) raise(node.start, "Missing catch or finally clause");
                    return finishNode(node, "TryStatement");

                  case _var:
                    next();
                    node = parseVar(node);
                    semicolon();
                    return node;

                  case _while:
                    next();
                    node.test = parseParenExpression();
                    labels.push(loopLabel);
                    node.body = parseStatement();
                    labels.pop();
                    return finishNode(node, "WhileStatement");

                  case _with:
                    if (strict) raise(tokStart, "'with' in strict mode");
                    next();
                    node.object = parseParenExpression();
                    node.body = parseStatement();
                    return finishNode(node, "WithStatement");

                  case _braceL:
                    return parseBlock();

                  case _semi:
                    next();
                    return finishNode(node, "EmptyStatement");

                  // If the statement does not start with a statement keyword or a
                    // brace, it's an ExpressionStatement or LabeledStatement. We
                    // simply start parsing an expression, and afterwards, if the
                    // next token is a colon and the expression was a simple
                    // Identifier node, we switch to interpreting it as a label.
                    default:
                    var maybeName = tokVal, expr = parseExpression();
                    if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
                        for (var i = 0; i < labels.length; ++i) if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
                        var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
                        labels.push({
                            name: maybeName,
                            kind: kind
                        });
                        node.body = parseStatement();
                        labels.pop();
                        node.label = expr;
                        return finishNode(node, "LabeledStatement");
                    } else {
                        node.expression = expr;
                        semicolon();
                        return finishNode(node, "ExpressionStatement");
                    }
                }
            }
            // Used for constructs like `switch` and `if` that insist on
            // parentheses around their expression.
            function parseParenExpression() {
                expect(_parenL);
                var val = parseExpression();
                expect(_parenR);
                return val;
            }
            // Parse a semicolon-enclosed block of statements, handling `"use
            // strict"` declarations when `allowStrict` is true (used for
            // function bodies).
            function parseBlock(allowStrict) {
                var node = startNode(), first = true, strict = false, oldStrict;
                node.body = [];
                expect(_braceL);
                while (!eat(_braceR)) {
                    var stmt = parseStatement();
                    node.body.push(stmt);
                    if (first && isUseStrict(stmt)) {
                        oldStrict = strict;
                        setStrict(strict = true);
                    }
                    first = false;
                }
                if (strict && !oldStrict) setStrict(false);
                return finishNode(node, "BlockStatement");
            }
            // Parse a regular `for` loop. The disambiguation code in
            // `parseStatement` will already have parsed the init statement or
            // expression.
            function parseFor(node, init) {
                node.init = init;
                expect(_semi);
                node.test = tokType === _semi ? null : parseExpression();
                expect(_semi);
                node.update = tokType === _parenR ? null : parseExpression();
                expect(_parenR);
                node.body = parseStatement();
                labels.pop();
                return finishNode(node, "ForStatement");
            }
            // Parse a `for`/`in` loop.
            function parseForIn(node, init) {
                node.left = init;
                node.right = parseExpression();
                expect(_parenR);
                node.body = parseStatement();
                labels.pop();
                return finishNode(node, "ForInStatement");
            }
            // Parse a list of variable declarations.
            function parseVar(node, noIn) {
                node.declarations = [];
                node.kind = "var";
                for (;;) {
                    var decl = startNode();
                    decl.id = parseIdent();
                    if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
                    decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
                    node.declarations.push(finishNode(decl, "VariableDeclarator"));
                    if (!eat(_comma)) break;
                }
                return finishNode(node, "VariableDeclaration");
            }
            // ### Expression parsing
            // These nest, from the most general expression type at the top to
            // 'atomic', nondivisible expression types at the bottom. Most of
            // the functions will simply let the function(s) below them parse,
            // and, *if* the syntactic construct they handle is present, wrap
            // the AST node that the inner parser gave them in another node.
            // Parse a full expression. The arguments are used to forbid comma
            // sequences (in argument lists, array literals, or object literals)
            // or the `in` operator (in for loops initalization expressions).
            function parseExpression(noComma, noIn) {
                var expr = parseMaybeAssign(noIn);
                if (!noComma && tokType === _comma) {
                    var node = startNodeFrom(expr);
                    node.expressions = [ expr ];
                    while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
                    return finishNode(node, "SequenceExpression");
                }
                return expr;
            }
            // Parse an assignment expression. This includes applications of
            // operators like `+=`.
            function parseMaybeAssign(noIn) {
                var left = parseMaybeConditional(noIn);
                if (tokType.isAssign) {
                    var node = startNodeFrom(left);
                    node.operator = tokVal;
                    node.left = left;
                    next();
                    node.right = parseMaybeAssign(noIn);
                    checkLVal(left);
                    return finishNode(node, "AssignmentExpression");
                }
                return left;
            }
            // Parse a ternary conditional (`?:`) operator.
            function parseMaybeConditional(noIn) {
                var expr = parseExprOps(noIn);
                if (eat(_question)) {
                    var node = startNodeFrom(expr);
                    node.test = expr;
                    node.consequent = parseExpression(true);
                    expect(_colon);
                    node.alternate = parseExpression(true, noIn);
                    return finishNode(node, "ConditionalExpression");
                }
                return expr;
            }
            // Start the precedence parser.
            function parseExprOps(noIn) {
                return parseExprOp(parseMaybeUnary(noIn), -1, noIn);
            }
            // Parse binary operators with the operator precedence parsing
            // algorithm. `left` is the left-hand side of the operator.
            // `minPrec` provides context that allows the function to stop and
            // defer further parser to one of its callers when it encounters an
            // operator that has a lower precedence than the set it is parsing.
            function parseExprOp(left, minPrec, noIn) {
                var prec = tokType.binop;
                if (prec != null && (!noIn || tokType !== _in)) {
                    if (prec > minPrec) {
                        var node = startNodeFrom(left);
                        node.left = left;
                        node.operator = tokVal;
                        next();
                        node.right = parseExprOp(parseMaybeUnary(noIn), prec, noIn);
                        var node = finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
                        return parseExprOp(node, minPrec, noIn);
                    }
                }
                return left;
            }
            // Parse unary operators, both prefix and postfix.
            function parseMaybeUnary(noIn) {
                if (tokType.prefix) {
                    var node = startNode(), update = tokType.isUpdate;
                    node.operator = tokVal;
                    node.prefix = true;
                    next();
                    node.argument = parseMaybeUnary(noIn);
                    if (update) checkLVal(node.argument); else if (strict && node.operator === "delete" && node.argument.type === "Identifier") raise(node.start, "Deleting local variable in strict mode");
                    return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
                }
                var expr = parseExprSubscripts();
                while (tokType.postfix && !canInsertSemicolon()) {
                    var node = startNodeFrom(expr);
                    node.operator = tokVal;
                    node.prefix = false;
                    node.argument = expr;
                    checkLVal(expr);
                    next();
                    expr = finishNode(node, "UpdateExpression");
                }
                return expr;
            }
            // Parse call, dot, and `[]`-subscript expressions.
            function parseExprSubscripts() {
                return parseSubscripts(parseExprAtom());
            }
            function parseSubscripts(base, noCalls) {
                if (eat(_dot)) {
                    var node = startNodeFrom(base);
                    node.object = base;
                    node.property = parseIdent(true);
                    node.computed = false;
                    return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
                } else if (eat(_bracketL)) {
                    var node = startNodeFrom(base);
                    node.object = base;
                    node.property = parseExpression();
                    node.computed = true;
                    expect(_bracketR);
                    return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
                } else if (!noCalls && eat(_parenL)) {
                    var node = startNodeFrom(base);
                    node.callee = base;
                    node.arguments = parseExprList(_parenR, false);
                    return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
                } else return base;
            }
            // Parse an atomic expression  either a single token that is an
            // expression, an expression started by a keyword like `function` or
            // `new`, or an expression wrapped in punctuation like `()`, `[]`,
            // or `{}`.
            function parseExprAtom() {
                switch (tokType) {
                  case _this:
                    var node = startNode();
                    next();
                    return finishNode(node, "ThisExpression");

                  case _name:
                    return parseIdent();

                  case _num:
                  case _string:
                  case _regexp:
                    var node = startNode();
                    node.value = tokVal;
                    node.raw = input.slice(tokStart, tokEnd);
                    next();
                    return finishNode(node, "Literal");

                  case _null:
                  case _true:
                  case _false:
                    var node = startNode();
                    node.value = tokType.atomValue;
                    node.raw = tokType.keyword;
                    next();
                    return finishNode(node, "Literal");

                  case _parenL:
                    var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
                    next();
                    var val = parseExpression();
                    val.start = tokStart1;
                    val.end = tokEnd;
                    if (options.locations) {
                        val.loc.start = tokStartLoc1;
                        val.loc.end = tokEndLoc;
                    }
                    if (options.ranges) val.range = [ tokStart1, tokEnd ];
                    expect(_parenR);
                    return val;

                  case _bracketL:
                    var node = startNode();
                    next();
                    node.elements = parseExprList(_bracketR, true, true);
                    return finishNode(node, "ArrayExpression");

                  case _braceL:
                    return parseObj();

                  case _function:
                    var node = startNode();
                    next();
                    return parseFunction(node, false);

                  case _new:
                    return parseNew();

                  default:
                    unexpected();
                }
            }
            // New's precedence is slightly tricky. It must allow its argument
            // to be a `[]` or dot subscript expression, but not a call  at
            // least, not without wrapping it in parentheses. Thus, it uses the 
            function parseNew() {
                var node = startNode();
                next();
                node.callee = parseSubscripts(parseExprAtom(), true);
                if (eat(_parenL)) node.arguments = parseExprList(_parenR, false); else node.arguments = [];
                return finishNode(node, "NewExpression");
            }
            // Parse an object literal.
            function parseObj() {
                var node = startNode(), first = true, sawGetSet = false;
                node.properties = [];
                next();
                while (!eat(_braceR)) {
                    if (!first) {
                        expect(_comma);
                        if (options.allowTrailingCommas && eat(_braceR)) break;
                    } else first = false;
                    var prop = {
                        key: parsePropertyName()
                    }, isGetSet = false, kind;
                    if (eat(_colon)) {
                        prop.value = parseExpression(true);
                        kind = prop.kind = "init";
                    } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set")) {
                        isGetSet = sawGetSet = true;
                        kind = prop.kind = prop.key.name;
                        prop.key = parsePropertyName();
                        if (tokType !== _parenL) unexpected();
                        prop.value = parseFunction(startNode(), false);
                    } else unexpected();
                    // getters and setters are not allowed to clash  either with
                    // each other or with an init property  and in strict mode,
                    // init properties are also not allowed to be repeated.
                    if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
                        for (var i = 0; i < node.properties.length; ++i) {
                            var other = node.properties[i];
                            if (other.key.name === prop.key.name) {
                                var conflict = kind == other.kind || isGetSet && other.kind === "init" || kind === "init" && (other.kind === "get" || other.kind === "set");
                                if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
                                if (conflict) raise(prop.key.start, "Redefinition of property");
                            }
                        }
                    }
                    node.properties.push(prop);
                }
                return finishNode(node, "ObjectExpression");
            }
            function parsePropertyName() {
                if (tokType === _num || tokType === _string) return parseExprAtom();
                return parseIdent(true);
            }
            // Parse a function declaration or literal (depending on the
            // `isStatement` parameter).
            function parseFunction(node, isStatement) {
                if (tokType === _name) node.id = parseIdent(); else if (isStatement) unexpected(); else node.id = null;
                node.params = [];
                var first = true;
                expect(_parenL);
                while (!eat(_parenR)) {
                    if (!first) expect(_comma); else first = false;
                    node.params.push(parseIdent());
                }
                // Start a new scope with regard to labels and the `inFunction`
                // flag (restore them to their old value afterwards).
                var oldInFunc = inFunction, oldLabels = labels;
                inFunction = true;
                labels = [];
                node.body = parseBlock(true);
                inFunction = oldInFunc;
                labels = oldLabels;
                // If this is a strict mode function, verify that argument names
                // are not repeated, and it does not try to bind the words `eval`
                // or `arguments`.
                if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
                    for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
                        var id = i < 0 ? node.id : node.params[i];
                        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, "Defining '" + id.name + "' in strict mode");
                        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name) raise(id.start, "Argument name clash in strict mode");
                    }
                }
                return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
            }
            // Parses a comma-separated list of expressions, and returns them as
            // an array. `close` is the token type that ends the list, and
            // `allowEmpty` can be turned on to allow subsequent commas with
            // nothing in between them to be parsed as `null` (which is needed
            // for array literals).
            function parseExprList(close, allowTrailingComma, allowEmpty) {
                var elts = [], first = true;
                while (!eat(close)) {
                    if (!first) {
                        expect(_comma);
                        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
                    } else first = false;
                    if (allowEmpty && tokType === _comma) elts.push(null); else elts.push(parseExpression(true));
                }
                return elts;
            }
            // Parse the next token as an identifier. If `liberal` is true (used
            // when parsing properties), it will also convert keywords into
            // identifiers.
            function parseIdent(liberal) {
                var node = startNode();
                node.name = tokType === _name ? tokVal : liberal && !options.forbidReserved && tokType.keyword || unexpected();
                next();
                return finishNode(node, "Identifier");
            }
        })(typeof exports === "undefined" ? self.acorn = {} : exports);
    });
    define("hsp/compiler/jsgenerator/jsvalidator/validator.js", [ "acorn/acorn" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var acorn = require("acorn/acorn");
        /**
 * Validates a JavaScript string
 * @param {String} input the Javascript string
 * @return {Object} JSON structure with 'valid' and 'errors' properties e.g. {valid:false, errors:[{msg:'...',lineInfoTxt:'...',lineInfoHTML:'...',loc:{line:2,column:30}'}]}
 */
        module.exports.validate = function(input) {
            var result = {
                isValid: true
            };
            try {
                acorn.parse(input, {
                    ecmaVersion: 3,
                    strictSemicolons: false,
                    allowTrailingCommas: false,
                    forbidReserved: true
                });
            } catch (ex) {
                result.isValid = false;
                result.errors = [ formatError(ex, input) ];
            }
            return result;
        };
        /**
 * Formats the error as an error structure with line extract information.
 * @param {Object} error the exception.
 * @param {String} input the Javascript string.
 * @return {Object} the structured error.
 */
        function formatError(error, input) {
            var message = error.toString().replace(/\s*\(\d*\:\d*\)\s*$/i, "");
            // remove line number / col number
            var beforeMatch = ("" + input.slice(0, error.pos)).match(/.*$/i);
            var afterMatch = ("" + input.slice(error.pos)).match(/.*/i);
            var before = beforeMatch ? beforeMatch[0] : "";
            var after = afterMatch ? afterMatch[0] : "";
            // Prepare line info for txt display
            var cursorPos = before.length;
            var errChar = after.length ? after.slice(0, 1) : "X";
            var lineStr = before + after;
            var lncursor = [];
            for (var i = 0; i < lineStr.length; i++) {
                lncursor[i] = i === cursorPos ? "^" : "-";
            }
            var lineInfoTxt = lineStr + "\r\n" + lncursor.join("");
            // Prepare line info for HTML display
            var lineInfoHTML = [ '<span class="code">', before, '<span class="error" title="', message, '">', errChar, "</span>", after.slice(1), "</span>" ].join("");
            return {
                description: message,
                lineInfoTxt: lineInfoTxt,
                lineInfoHTML: lineInfoHTML,
                code: lineStr,
                line: error.loc ? error.loc.line : -1,
                column: error.loc ? error.loc.column : -1
            };
        }
    });
    define("hsp/compiler/jsgenerator/index.js", [ "./templateWalker", "./processors", "./jsvalidator/validator" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var TemplateWalker = require("./templateWalker").TemplateWalker;
        var processors = require("./processors");
        var jsv = require("./jsvalidator/validator");
        /**
 * Header added to all generated JS file
 */
        var HEADER_ARR = [ "", "// ################################################################ ", "//  This file has been generated by the hashspace compiler          ", "//  Direct MODIFICATIONS WILL BE LOST when the file is recompiled!  ", "// ################################################################ ", "" ];
        var HEADER = module.exports.HEADER = HEADER_ARR.join("\r\n");
        var HEADER_SZ = HEADER_ARR.length;
        /**
 * Generates the JS compiled string and a list of errors.
 * @param {Object} res the result of the previous steps of the compilation.
 * @param {String} template the template file content as a string.
 * @param {String} dirPath the directory path.
 * @param {String} fileName the name of the file being compiled (optional - used for error messages).
 * @param {Object} generator options; supported options are:
 *      includeSyntaxTree  if true, the result object will contain the syntax tree generated by the compiler.
 *      bypassJSvalidation  if true, the validation of the generated JS file (including non-template code) is bypassed - default:false.
 *      mode the type of module system the code shold comply with: either "commonJS" or "global" 
 *      globalRef the name of the runtime global reference when the "global" mode is used (default: "hsp")
 * @param {Boolean} includeSyntaxTree  if true, the result object will contain the syntax tree generated by the compiler.
 * @param {Boolean} bypassJSvalidation  if true, the validation of the generated JS file (including non-template code) is bypassed - default:false.
 * @return {JSON} a JSON structure with the following properties:
 *      errors: {Array} the error list - each error having the following structure:
 *          description: {String} - a message describing the error 
 *          line: {Number} - the error line number
 *          column: {Number} - the error column number 
 *          code: {String} - a code extract showing where the error occurs (optional)
 *      code: {String} the generated JavaScript code
 *      syntaxTree: {JSON} the syntax tree generated by the parser (optional - cf. parameters)
 *      lineMap: {Array} array of the new line indexes: lineMap[3] returns the new line index for line 4 in
 *          the orginal file (lineMap[0] is always 0 as all line count starts at 1 for both input and output values)
 */
        exports.generate = function(res, template, fileName, dirPath, options) {
            var includeSyntaxTree = options.includeSyntaxTree, bypassJSvalidation = options.bypassJSvalidation;
            res.code = "";
            if (!res.errors || !res.errors.length) {
                // It is sure that res is an array otherwise the parser would have thrown an exception
                var templateWalker = new TemplateWalker(fileName, dirPath, options.mode, options.globalRef);
                var out = templateWalker.walk(res.syntaxTree, processors);
                if (includeSyntaxTree === true) {
                    res.codeFragments = templateWalker.templates;
                }
                // don't add any newlines when joining blocks;
                // emit necessary newlines from the parser or template walker instead
                res.code = HEADER + out.join("");
                res.errors = templateWalker.errors;
            } else {
                // Generate a JS script to show the errors when the generated file is loaded
                res.code = HEADER;
            }
            if (!res.errors) {
                res.errors = [];
            } else if (res.errors.length > 0) {
                // remove all code so that script can still be loaded
                res.code = HEADER;
            }
            if (res.errors.length === 0 && bypassJSvalidation !== true) {
                var lineMap = _generateLineMap(res, template);
                res.lineMap = lineMap;
                var validationResult = _validate(res.code, lineMap);
                // call the JS validator
                // we don't checke for JS errors when there are template errors as the code generated by the template may be
                // wrong
                if (!validationResult.isValid) {
                    // remove all code so that script can still be loaded
                    res.code = HEADER;
                    Array.prototype.push.apply(res.errors, validationResult.errors);
                }
            }
            res.code += _getErrorScript(res.errors, fileName);
            if (includeSyntaxTree !== true) {
                res.syntaxTree = null;
            }
            return res;
        };
        /**
 * Validates a javascript string using the jsvalidator module, and generates an error report if not valid.
 * @param {String} code the javascript string.
 * @param {Object} lineMap the line mapping between the source template and the compiled one
 * @return {Object} a result map
 */
        function _validate(code, lineMap) {
            var validationResult = jsv.validate(code);
            var result = {
                isValid: validationResult.isValid
            };
            if (!validationResult.isValid) {
                // translate error line numbers
                var error, lineNumber;
                for (var i = 0; i < validationResult.errors.length; i++) {
                    error = validationResult.errors[i];
                    lineNumber = error.line;
                    error.line = -1;
                    // to avoid sending a wrong line in case of pb
                    for (var j = 0; j < lineMap.length; j++) {
                        if (lineMap[j] === lineNumber) {
                            error.line = j;
                            // original line nbr
                            break;
                        }
                    }
                }
                result.errors = validationResult.errors;
            }
            return result;
        }
        /**
 * Generate an error script to include in the template compiled script in order to show errors in the browser when the script is loaded
 * @param {Array} errors the errror list
 * @param {String} fileName the name of the file being compiled
 * @return {String} the javascript snippet to be included
 */
        function _getErrorScript(errors, fileName) {
            var result = "";
            if (errors && errors.length) {
                var err = errors[0];
                var ctxt = {
                    type: "error",
                    file: fileName,
                    code: err.code,
                    line: err.line,
                    column: err.column
                };
                result = [ '\r\nrequire("hsp/rt/log").error("', err.description, '",', JSON.stringify(ctxt, null), ");\r\n" ].join("");
            }
            return result;
        }
        /**
 * Generate the line map of a compilatin result
 * @param {JSON} res the result object of a compilation - cf. compile function
 * @param {String} file the template file (before compilation)
 */
        function _generateLineMap(res, file) {
            if (res.errors && res.errors.length) {
                return;
            }
            var syntaxTree = res.syntaxTree, templates = [];
            // identify the templates in the syntax tree
            for (var i = 0; i < syntaxTree.length; i++) {
                if (syntaxTree[i].type === "template") {
                    templates.push(syntaxTree[i]);
                }
            }
            var nbrOfLinesInCompiledTemplate = 5;
            //all generated templates got fixed no of LOC
            var lineMap = [], pos = HEADER_SZ, template;
            var pos1 = -1;
            // position of the next template start
            var pos2 = -1;
            // position of the next template end
            var tplIdx = -1;
            // position of the current template
            for (var i = 0; i < file.split(/\n/g).length + 1; i++) {
                if (i === 0 || i === pos2) {
                    // end of current template: let's determine next pos1 and pos2
                    tplIdx = i === 0 ? 0 : tplIdx + 1;
                    if (tplIdx < templates.length) {
                        // there is another template
                        template = templates[tplIdx];
                        pos1 = template.startLine;
                        pos2 = Math.max(template.endLine, pos1);
                    } else {
                        // last template has been found
                        tplIdx = pos1 = pos2 = -1;
                    }
                    if (i === 0) {
                        lineMap[0] = 0;
                    }
                    i++;
                }
                if (i === pos1) {
                    for (var j = pos1; j < pos2 + 1; j++) {
                        // all lines are set to the template start
                        lineMap[i] = pos;
                        i++;
                    }
                    pos += nbrOfLinesInCompiledTemplate;
                    i -= 2;
                } else {
                    lineMap[i] = pos;
                    pos++;
                }
            }
            return lineMap;
        }
    });
    define("uglify-js.js", [], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/
        "use strict";
        function array_to_hash(a) {
            var ret = Object.create(null);
            for (var i = 0; i < a.length; ++i) ret[a[i]] = true;
            return ret;
        }
        function slice(a, start) {
            return Array.prototype.slice.call(a, start || 0);
        }
        function characters(str) {
            return str.split("");
        }
        function member(name, array) {
            for (var i = array.length; --i >= 0; ) if (array[i] == name) return true;
            return false;
        }
        function find_if(func, array) {
            for (var i = 0, n = array.length; i < n; ++i) {
                if (func(array[i])) return array[i];
            }
        }
        function repeat_string(str, i) {
            if (i <= 0) return "";
            if (i == 1) return str;
            var d = repeat_string(str, i >> 1);
            d += d;
            if (i & 1) d += str;
            return d;
        }
        function DefaultsError(msg, defs) {
            Error.call(this, msg);
            this.msg = msg;
            this.defs = defs;
        }
        DefaultsError.prototype = Object.create(Error.prototype);
        DefaultsError.prototype.constructor = DefaultsError;
        DefaultsError.croak = function(msg, defs) {
            throw new DefaultsError(msg, defs);
        };
        function defaults(args, defs, croak) {
            if (args === true) args = {};
            var ret = args || {};
            if (croak) for (var i in ret) if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i)) DefaultsError.croak("`" + i + "` is not a supported option", defs);
            for (var i in defs) if (defs.hasOwnProperty(i)) {
                ret[i] = args && args.hasOwnProperty(i) ? args[i] : defs[i];
            }
            return ret;
        }
        function merge(obj, ext) {
            for (var i in ext) if (ext.hasOwnProperty(i)) {
                obj[i] = ext[i];
            }
            return obj;
        }
        function noop() {}
        var MAP = function() {
            function MAP(a, f, backwards) {
                var ret = [], top = [], i;
                function doit() {
                    var val = f(a[i], i);
                    var is_last = val instanceof Last;
                    if (is_last) val = val.v;
                    if (val instanceof AtTop) {
                        val = val.v;
                        if (val instanceof Splice) {
                            top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
                        } else {
                            top.push(val);
                        }
                    } else if (val !== skip) {
                        if (val instanceof Splice) {
                            ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
                        } else {
                            ret.push(val);
                        }
                    }
                    return is_last;
                }
                if (a instanceof Array) {
                    if (backwards) {
                        for (i = a.length; --i >= 0; ) if (doit()) break;
                        ret.reverse();
                        top.reverse();
                    } else {
                        for (i = 0; i < a.length; ++i) if (doit()) break;
                    }
                } else {
                    for (i in a) if (a.hasOwnProperty(i)) if (doit()) break;
                }
                return top.concat(ret);
            }
            MAP.at_top = function(val) {
                return new AtTop(val);
            };
            MAP.splice = function(val) {
                return new Splice(val);
            };
            MAP.last = function(val) {
                return new Last(val);
            };
            var skip = MAP.skip = {};
            function AtTop(val) {
                this.v = val;
            }
            function Splice(val) {
                this.v = val;
            }
            function Last(val) {
                this.v = val;
            }
            return MAP;
        }();
        function push_uniq(array, el) {
            if (array.indexOf(el) < 0) array.push(el);
        }
        function string_template(text, props) {
            return text.replace(/\{(.+?)\}/g, function(str, p) {
                return props[p];
            });
        }
        function remove(array, el) {
            for (var i = array.length; --i >= 0; ) {
                if (array[i] === el) array.splice(i, 1);
            }
        }
        function mergeSort(array, cmp) {
            if (array.length < 2) return array.slice();
            function merge(a, b) {
                var r = [], ai = 0, bi = 0, i = 0;
                while (ai < a.length && bi < b.length) {
                    cmp(a[ai], b[bi]) <= 0 ? r[i++] = a[ai++] : r[i++] = b[bi++];
                }
                if (ai < a.length) r.push.apply(r, a.slice(ai));
                if (bi < b.length) r.push.apply(r, b.slice(bi));
                return r;
            }
            function _ms(a) {
                if (a.length <= 1) return a;
                var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
                left = _ms(left);
                right = _ms(right);
                return merge(left, right);
            }
            return _ms(array);
        }
        function set_difference(a, b) {
            return a.filter(function(el) {
                return b.indexOf(el) < 0;
            });
        }
        function set_intersection(a, b) {
            return a.filter(function(el) {
                return b.indexOf(el) >= 0;
            });
        }
        // this function is taken from Acorn [1], written by Marijn Haverbeke
        // [1] https://github.com/marijnh/acorn
        function makePredicate(words) {
            if (!(words instanceof Array)) words = words.split(" ");
            var f = "", cats = [];
            out: for (var i = 0; i < words.length; ++i) {
                for (var j = 0; j < cats.length; ++j) if (cats[j][0].length == words[i].length) {
                    cats[j].push(words[i]);
                    continue out;
                }
                cats.push([ words[i] ]);
            }
            function compareTo(arr) {
                if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
                f += "switch(str){";
                for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
                f += "return true}return false;";
            }
            // When there are more than three length categories, an outer
            // switch first dispatches on the lengths, to save on comparisons.
            if (cats.length > 3) {
                cats.sort(function(a, b) {
                    return b.length - a.length;
                });
                f += "switch(str.length){";
                for (var i = 0; i < cats.length; ++i) {
                    var cat = cats[i];
                    f += "case " + cat[0].length + ":";
                    compareTo(cat);
                }
                f += "}";
            } else {
                compareTo(words);
            }
            return new Function("str", f);
        }
        function all(array, predicate) {
            for (var i = array.length; --i >= 0; ) if (!predicate(array[i])) return false;
            return true;
        }
        function Dictionary() {
            this._values = Object.create(null);
            this._size = 0;
        }
        Dictionary.prototype = {
            set: function(key, val) {
                if (!this.has(key)) ++this._size;
                this._values["$" + key] = val;
                return this;
            },
            add: function(key, val) {
                if (this.has(key)) {
                    this.get(key).push(val);
                } else {
                    this.set(key, [ val ]);
                }
                return this;
            },
            get: function(key) {
                return this._values["$" + key];
            },
            del: function(key) {
                if (this.has(key)) {
                    --this._size;
                    delete this._values["$" + key];
                }
                return this;
            },
            has: function(key) {
                return "$" + key in this._values;
            },
            each: function(f) {
                for (var i in this._values) f(this._values[i], i.substr(1));
            },
            size: function() {
                return this._size;
            },
            map: function(f) {
                var ret = [];
                for (var i in this._values) ret.push(f(this._values[i], i.substr(1)));
                return ret;
            }
        };
        exports.array_to_hash = array_to_hash;
        exports.slice = slice;
        exports.characters = characters;
        exports.member = member;
        exports.find_if = find_if;
        exports.repeat_string = repeat_string;
        exports.DefaultsError = DefaultsError;
        exports.defaults = defaults;
        exports.merge = merge;
        exports.noop = noop;
        exports.MAP = MAP;
        exports.push_uniq = push_uniq;
        exports.string_template = string_template;
        exports.remove = remove;
        exports.mergeSort = mergeSort;
        exports.set_difference = set_difference;
        exports.set_intersection = set_intersection;
        exports.makePredicate = makePredicate;
        exports.all = all;
        exports.Dictionary = Dictionary;
        /***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/
        "use strict";
        function DEFNODE(type, props, methods, base) {
            if (arguments.length < 4) base = AST_Node;
            if (!props) props = []; else props = props.split(/\s+/);
            var self_props = props;
            if (base && base.PROPS) props = props.concat(base.PROPS);
            var code = "return function AST_" + type + "(props){ if (props) { ";
            for (var i = props.length; --i >= 0; ) {
                code += "this." + props[i] + " = props." + props[i] + ";";
            }
            var proto = base && new base();
            if (proto && proto.initialize || methods && methods.initialize) code += "this.initialize();";
            code += "}}";
            var ctor = new Function(code)();
            if (proto) {
                ctor.prototype = proto;
                ctor.BASE = base;
            }
            if (base) base.SUBCLASSES.push(ctor);
            ctor.prototype.CTOR = ctor;
            ctor.PROPS = props || null;
            ctor.SELF_PROPS = self_props;
            ctor.SUBCLASSES = [];
            if (type) {
                ctor.prototype.TYPE = ctor.TYPE = type;
            }
            if (methods) for (i in methods) if (methods.hasOwnProperty(i)) {
                if (/^\$/.test(i)) {
                    ctor[i.substr(1)] = methods[i];
                } else {
                    ctor.prototype[i] = methods[i];
                }
            }
            ctor.DEFMETHOD = function(name, method) {
                this.prototype[name] = method;
            };
            return ctor;
        }
        var AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {}, null);
        var AST_Node = DEFNODE("Node", "start end", {
            clone: function() {
                return new this.CTOR(this);
            },
            $documentation: "Base class of all AST nodes",
            $propdoc: {
                start: "[AST_Token] The first token of this node",
                end: "[AST_Token] The last token of this node"
            },
            _walk: function(visitor) {
                return visitor._visit(this);
            },
            walk: function(visitor) {
                return this._walk(visitor);
            }
        }, null);
        AST_Node.warn_function = null;
        AST_Node.warn = function(txt, props) {
            if (AST_Node.warn_function) AST_Node.warn_function(string_template(txt, props));
        };
        /* -----[ statements ]----- */
        var AST_Statement = DEFNODE("Statement", null, {
            $documentation: "Base class of all statements"
        });
        var AST_Debugger = DEFNODE("Debugger", null, {
            $documentation: "Represents a debugger statement"
        }, AST_Statement);
        var AST_Directive = DEFNODE("Directive", "value scope", {
            $documentation: 'Represents a directive, like "use strict";',
            $propdoc: {
                value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
                scope: "[AST_Scope/S] The scope that this directive affects"
            }
        }, AST_Statement);
        var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
            $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
            $propdoc: {
                body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.body._walk(visitor);
                });
            }
        }, AST_Statement);
        function walk_body(node, visitor) {
            if (node.body instanceof AST_Statement) {
                node.body._walk(visitor);
            } else node.body.forEach(function(stat) {
                stat._walk(visitor);
            });
        }
        var AST_Block = DEFNODE("Block", "body", {
            $documentation: "A body of statements (usually bracketed)",
            $propdoc: {
                body: "[AST_Statement*] an array of statements"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    walk_body(this, visitor);
                });
            }
        }, AST_Statement);
        var AST_BlockStatement = DEFNODE("BlockStatement", null, {
            $documentation: "A block statement"
        }, AST_Block);
        var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
            $documentation: "The empty statement (empty block or simply a semicolon)",
            _walk: function(visitor) {
                return visitor._visit(this);
            }
        }, AST_Statement);
        var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
            $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
            $propdoc: {
                body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.body._walk(visitor);
                });
            }
        }, AST_Statement);
        var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
            $documentation: "Statement with a label",
            $propdoc: {
                label: "[AST_Label] a label definition"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.label._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST_StatementWithBody);
        var AST_IterationStatement = DEFNODE("IterationStatement", null, {
            $documentation: "Internal class.  All loops inherit from it."
        }, AST_StatementWithBody);
        var AST_DWLoop = DEFNODE("DWLoop", "condition", {
            $documentation: "Base class for do/while statements",
            $propdoc: {
                condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.condition._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST_IterationStatement);
        var AST_Do = DEFNODE("Do", null, {
            $documentation: "A `do` statement"
        }, AST_DWLoop);
        var AST_While = DEFNODE("While", null, {
            $documentation: "A `while` statement"
        }, AST_DWLoop);
        var AST_For = DEFNODE("For", "init condition step", {
            $documentation: "A `for` statement",
            $propdoc: {
                init: "[AST_Node?] the `for` initialization code, or null if empty",
                condition: "[AST_Node?] the `for` termination clause, or null if empty",
                step: "[AST_Node?] the `for` update clause, or null if empty"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    if (this.init) this.init._walk(visitor);
                    if (this.condition) this.condition._walk(visitor);
                    if (this.step) this.step._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST_IterationStatement);
        var AST_ForIn = DEFNODE("ForIn", "init name object", {
            $documentation: "A `for ... in` statement",
            $propdoc: {
                init: "[AST_Node] the `for/in` initialization code",
                name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
                object: "[AST_Node] the object that we're looping through"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.init._walk(visitor);
                    this.object._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST_IterationStatement);
        var AST_With = DEFNODE("With", "expression", {
            $documentation: "A `with` statement",
            $propdoc: {
                expression: "[AST_Node] the `with` expression"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.expression._walk(visitor);
                    this.body._walk(visitor);
                });
            }
        }, AST_StatementWithBody);
        /* -----[ scope and functions ]----- */
        var AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
            $documentation: "Base class for all statements introducing a lexical scope",
            $propdoc: {
                directives: "[string*/S] an array of directives declared in this scope",
                variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
                functions: "[Object/S] like `variables`, but only lists function declarations",
                uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
                uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
                parent_scope: "[AST_Scope?/S] link to the parent scope",
                enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
                cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
            }
        }, AST_Block);
        var AST_Toplevel = DEFNODE("Toplevel", "globals", {
            $documentation: "The toplevel scope",
            $propdoc: {
                globals: "[Object/S] a map of name -> SymbolDef for all undeclared names"
            },
            wrap_enclose: function(arg_parameter_pairs) {
                var self = this;
                var args = [];
                var parameters = [];
                arg_parameter_pairs.forEach(function(pair) {
                    var split = pair.split(":");
                    args.push(split[0]);
                    parameters.push(split[1]);
                });
                var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
                wrapped_tl = parse(wrapped_tl);
                wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
                    if (node instanceof AST_Directive && node.value == "$ORIG") {
                        return MAP.splice(self.body);
                    }
                }));
                return wrapped_tl;
            },
            wrap_commonjs: function(name, export_all) {
                var self = this;
                var to_export = [];
                if (export_all) {
                    self.figure_out_scope();
                    self.walk(new TreeWalker(function(node) {
                        if (node instanceof AST_SymbolDeclaration && node.definition().global) {
                            if (!find_if(function(n) {
                                return n.name == node.name;
                            }, to_export)) to_export.push(node);
                        }
                    }));
                }
                var wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";
                wrapped_tl = parse(wrapped_tl);
                wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {
                    if (node instanceof AST_SimpleStatement) {
                        node = node.body;
                        if (node instanceof AST_String) switch (node.getValue()) {
                          case "$ORIG":
                            return MAP.splice(self.body);

                          case "$EXPORTS":
                            var body = [];
                            to_export.forEach(function(sym) {
                                body.push(new AST_SimpleStatement({
                                    body: new AST_Assign({
                                        left: new AST_Sub({
                                            expression: new AST_SymbolRef({
                                                name: "exports"
                                            }),
                                            property: new AST_String({
                                                value: sym.name
                                            })
                                        }),
                                        operator: "=",
                                        right: new AST_SymbolRef(sym)
                                    })
                                }));
                            });
                            return MAP.splice(body);
                        }
                    }
                }));
                return wrapped_tl;
            }
        }, AST_Scope);
        var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
            $documentation: "Base class for functions",
            $propdoc: {
                name: "[AST_SymbolDeclaration?] the name of this function",
                argnames: "[AST_SymbolFunarg*] array of function arguments",
                uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    if (this.name) this.name._walk(visitor);
                    this.argnames.forEach(function(arg) {
                        arg._walk(visitor);
                    });
                    walk_body(this, visitor);
                });
            }
        }, AST_Scope);
        var AST_Accessor = DEFNODE("Accessor", null, {
            $documentation: "A setter/getter function.  The `name` property is always null."
        }, AST_Lambda);
        var AST_Function = DEFNODE("Function", null, {
            $documentation: "A function expression"
        }, AST_Lambda);
        var AST_Defun = DEFNODE("Defun", null, {
            $documentation: "A function definition"
        }, AST_Lambda);
        /* -----[ JUMPS ]----- */
        var AST_Jump = DEFNODE("Jump", null, {
            $documentation: "Base class for \u201cjumps\u201d (for now that's `return`, `throw`, `break` and `continue`)"
        }, AST_Statement);
        var AST_Exit = DEFNODE("Exit", "value", {
            $documentation: "Base class for \u201cexits\u201d (`return` and `throw`)",
            $propdoc: {
                value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
            },
            _walk: function(visitor) {
                return visitor._visit(this, this.value && function() {
                    this.value._walk(visitor);
                });
            }
        }, AST_Jump);
        var AST_Return = DEFNODE("Return", null, {
            $documentation: "A `return` statement"
        }, AST_Exit);
        var AST_Throw = DEFNODE("Throw", null, {
            $documentation: "A `throw` statement"
        }, AST_Exit);
        var AST_LoopControl = DEFNODE("LoopControl", "label", {
            $documentation: "Base class for loop control statements (`break` and `continue`)",
            $propdoc: {
                label: "[AST_LabelRef?] the label, or null if none"
            },
            _walk: function(visitor) {
                return visitor._visit(this, this.label && function() {
                    this.label._walk(visitor);
                });
            }
        }, AST_Jump);
        var AST_Break = DEFNODE("Break", null, {
            $documentation: "A `break` statement"
        }, AST_LoopControl);
        var AST_Continue = DEFNODE("Continue", null, {
            $documentation: "A `continue` statement"
        }, AST_LoopControl);
        /* -----[ IF ]----- */
        var AST_If = DEFNODE("If", "condition alternative", {
            $documentation: "A `if` statement",
            $propdoc: {
                condition: "[AST_Node] the `if` condition",
                alternative: "[AST_Statement?] the `else` part, or null if not present"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.condition._walk(visitor);
                    this.body._walk(visitor);
                    if (this.alternative) this.alternative._walk(visitor);
                });
            }
        }, AST_StatementWithBody);
        /* -----[ SWITCH ]----- */
        var AST_Switch = DEFNODE("Switch", "expression", {
            $documentation: "A `switch` statement",
            $propdoc: {
                expression: "[AST_Node] the `switch` \u201cdiscriminant\u201d"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.expression._walk(visitor);
                    walk_body(this, visitor);
                });
            }
        }, AST_Block);
        var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
            $documentation: "Base class for `switch` branches"
        }, AST_Block);
        var AST_Default = DEFNODE("Default", null, {
            $documentation: "A `default` switch branch"
        }, AST_SwitchBranch);
        var AST_Case = DEFNODE("Case", "expression", {
            $documentation: "A `case` switch branch",
            $propdoc: {
                expression: "[AST_Node] the `case` expression"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.expression._walk(visitor);
                    walk_body(this, visitor);
                });
            }
        }, AST_SwitchBranch);
        /* -----[ EXCEPTIONS ]----- */
        var AST_Try = DEFNODE("Try", "bcatch bfinally", {
            $documentation: "A `try` statement",
            $propdoc: {
                bcatch: "[AST_Catch?] the catch block, or null if not present",
                bfinally: "[AST_Finally?] the finally block, or null if not present"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    walk_body(this, visitor);
                    if (this.bcatch) this.bcatch._walk(visitor);
                    if (this.bfinally) this.bfinally._walk(visitor);
                });
            }
        }, AST_Block);
        var AST_Catch = DEFNODE("Catch", "argname", {
            $documentation: "A `catch` node; only makes sense as part of a `try` statement",
            $propdoc: {
                argname: "[AST_SymbolCatch] symbol for the exception"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.argname._walk(visitor);
                    walk_body(this, visitor);
                });
            }
        }, AST_Block);
        var AST_Finally = DEFNODE("Finally", null, {
            $documentation: "A `finally` node; only makes sense as part of a `try` statement"
        }, AST_Block);
        /* -----[ VAR/CONST ]----- */
        var AST_Definitions = DEFNODE("Definitions", "definitions", {
            $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
            $propdoc: {
                definitions: "[AST_VarDef*] array of variable definitions"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.definitions.forEach(function(def) {
                        def._walk(visitor);
                    });
                });
            }
        }, AST_Statement);
        var AST_Var = DEFNODE("Var", null, {
            $documentation: "A `var` statement"
        }, AST_Definitions);
        var AST_Const = DEFNODE("Const", null, {
            $documentation: "A `const` statement"
        }, AST_Definitions);
        var AST_VarDef = DEFNODE("VarDef", "name value", {
            $documentation: "A variable declaration; only appears in a AST_Definitions node",
            $propdoc: {
                name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
                value: "[AST_Node?] initializer, or null of there's no initializer"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.name._walk(visitor);
                    if (this.value) this.value._walk(visitor);
                });
            }
        });
        /* -----[ OTHER ]----- */
        var AST_Call = DEFNODE("Call", "expression args", {
            $documentation: "A function call expression",
            $propdoc: {
                expression: "[AST_Node] expression to invoke as function",
                args: "[AST_Node*] array of arguments"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.expression._walk(visitor);
                    this.args.forEach(function(arg) {
                        arg._walk(visitor);
                    });
                });
            }
        });
        var AST_New = DEFNODE("New", null, {
            $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
        }, AST_Call);
        var AST_Seq = DEFNODE("Seq", "car cdr", {
            $documentation: "A sequence expression (two comma-separated expressions)",
            $propdoc: {
                car: "[AST_Node] first element in sequence",
                cdr: "[AST_Node] second element in sequence"
            },
            $cons: function(x, y) {
                var seq = new AST_Seq(x);
                seq.car = x;
                seq.cdr = y;
                return seq;
            },
            $from_array: function(array) {
                if (array.length == 0) return null;
                if (array.length == 1) return array[0].clone();
                var list = null;
                for (var i = array.length; --i >= 0; ) {
                    list = AST_Seq.cons(array[i], list);
                }
                var p = list;
                while (p) {
                    if (p.cdr && !p.cdr.cdr) {
                        p.cdr = p.cdr.car;
                        break;
                    }
                    p = p.cdr;
                }
                return list;
            },
            to_array: function() {
                var p = this, a = [];
                while (p) {
                    a.push(p.car);
                    if (p.cdr && !(p.cdr instanceof AST_Seq)) {
                        a.push(p.cdr);
                        break;
                    }
                    p = p.cdr;
                }
                return a;
            },
            add: function(node) {
                var p = this;
                while (p) {
                    if (!(p.cdr instanceof AST_Seq)) {
                        var cell = AST_Seq.cons(p.cdr, node);
                        return p.cdr = cell;
                    }
                    p = p.cdr;
                }
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.car._walk(visitor);
                    if (this.cdr) this.cdr._walk(visitor);
                });
            }
        });
        var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
            $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
            $propdoc: {
                expression: "[AST_Node] the \u201ccontainer\u201d expression",
                property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
            }
        });
        var AST_Dot = DEFNODE("Dot", null, {
            $documentation: "A dotted property access expression",
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.expression._walk(visitor);
                });
            }
        }, AST_PropAccess);
        var AST_Sub = DEFNODE("Sub", null, {
            $documentation: 'Index-style property access, i.e. `a["foo"]`',
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.expression._walk(visitor);
                    this.property._walk(visitor);
                });
            }
        }, AST_PropAccess);
        var AST_Unary = DEFNODE("Unary", "operator expression", {
            $documentation: "Base class for unary expressions",
            $propdoc: {
                operator: "[string] the operator",
                expression: "[AST_Node] expression that this unary operator applies to"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.expression._walk(visitor);
                });
            }
        });
        var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
            $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
        }, AST_Unary);
        var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
            $documentation: "Unary postfix expression, i.e. `i++`"
        }, AST_Unary);
        var AST_Binary = DEFNODE("Binary", "left operator right", {
            $documentation: "Binary expression, i.e. `a + b`",
            $propdoc: {
                left: "[AST_Node] left-hand side expression",
                operator: "[string] the operator",
                right: "[AST_Node] right-hand side expression"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.left._walk(visitor);
                    this.right._walk(visitor);
                });
            }
        });
        var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
            $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
            $propdoc: {
                condition: "[AST_Node]",
                consequent: "[AST_Node]",
                alternative: "[AST_Node]"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.condition._walk(visitor);
                    this.consequent._walk(visitor);
                    this.alternative._walk(visitor);
                });
            }
        });
        var AST_Assign = DEFNODE("Assign", null, {
            $documentation: "An assignment expression \u2014 `a = b + 5`"
        }, AST_Binary);
        /* -----[ LITERALS ]----- */
        var AST_Array = DEFNODE("Array", "elements", {
            $documentation: "An array literal",
            $propdoc: {
                elements: "[AST_Node*] array of elements"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.elements.forEach(function(el) {
                        el._walk(visitor);
                    });
                });
            }
        });
        var AST_Object = DEFNODE("Object", "properties", {
            $documentation: "An object literal",
            $propdoc: {
                properties: "[AST_ObjectProperty*] array of properties"
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.properties.forEach(function(prop) {
                        prop._walk(visitor);
                    });
                });
            }
        });
        var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
            $documentation: "Base class for literal object properties",
            $propdoc: {
                key: "[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.",
                value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
            },
            _walk: function(visitor) {
                return visitor._visit(this, function() {
                    this.value._walk(visitor);
                });
            }
        });
        var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
            $documentation: "A key: value object property"
        }, AST_ObjectProperty);
        var AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
            $documentation: "An object setter property"
        }, AST_ObjectProperty);
        var AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
            $documentation: "An object getter property"
        }, AST_ObjectProperty);
        var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
            $propdoc: {
                name: "[string] name of this symbol",
                scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
                thedef: "[SymbolDef/S] the definition of this symbol"
            },
            $documentation: "Base class for all symbols"
        });
        var AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
            $documentation: "The name of a property accessor (setter/getter function)"
        }, AST_Symbol);
        var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
            $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
            $propdoc: {
                init: "[AST_Node*/S] array of initializers for this declaration."
            }
        }, AST_Symbol);
        var AST_SymbolVar = DEFNODE("SymbolVar", null, {
            $documentation: "Symbol defining a variable"
        }, AST_SymbolDeclaration);
        var AST_SymbolConst = DEFNODE("SymbolConst", null, {
            $documentation: "A constant declaration"
        }, AST_SymbolDeclaration);
        var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
            $documentation: "Symbol naming a function argument"
        }, AST_SymbolVar);
        var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
            $documentation: "Symbol defining a function"
        }, AST_SymbolDeclaration);
        var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
            $documentation: "Symbol naming a function expression"
        }, AST_SymbolDeclaration);
        var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
            $documentation: "Symbol naming the exception in catch"
        }, AST_SymbolDeclaration);
        var AST_Label = DEFNODE("Label", "references", {
            $documentation: "Symbol naming a label (declaration)",
            $propdoc: {
                references: "[AST_LoopControl*] a list of nodes referring to this label"
            },
            initialize: function() {
                this.references = [];
                this.thedef = this;
            }
        }, AST_Symbol);
        var AST_SymbolRef = DEFNODE("SymbolRef", null, {
            $documentation: "Reference to some symbol (not definition/declaration)"
        }, AST_Symbol);
        var AST_LabelRef = DEFNODE("LabelRef", null, {
            $documentation: "Reference to a label symbol"
        }, AST_Symbol);
        var AST_This = DEFNODE("This", null, {
            $documentation: "The `this` symbol"
        }, AST_Symbol);
        var AST_Constant = DEFNODE("Constant", null, {
            $documentation: "Base class for all constants",
            getValue: function() {
                return this.value;
            }
        });
        var AST_String = DEFNODE("String", "value", {
            $documentation: "A string literal",
            $propdoc: {
                value: "[string] the contents of this string"
            }
        }, AST_Constant);
        var AST_Number = DEFNODE("Number", "value", {
            $documentation: "A number literal",
            $propdoc: {
                value: "[number] the numeric value"
            }
        }, AST_Constant);
        var AST_RegExp = DEFNODE("RegExp", "value", {
            $documentation: "A regexp literal",
            $propdoc: {
                value: "[RegExp] the actual regexp"
            }
        }, AST_Constant);
        var AST_Atom = DEFNODE("Atom", null, {
            $documentation: "Base class for atoms"
        }, AST_Constant);
        var AST_Null = DEFNODE("Null", null, {
            $documentation: "The `null` atom",
            value: null
        }, AST_Atom);
        var AST_NaN = DEFNODE("NaN", null, {
            $documentation: "The impossible value",
            value: 0 / 0
        }, AST_Atom);
        var AST_Undefined = DEFNODE("Undefined", null, {
            $documentation: "The `undefined` value",
            value: function() {}()
        }, AST_Atom);
        var AST_Hole = DEFNODE("Hole", null, {
            $documentation: "A hole in an array",
            value: function() {}()
        }, AST_Atom);
        var AST_Infinity = DEFNODE("Infinity", null, {
            $documentation: "The `Infinity` value",
            value: 1 / 0
        }, AST_Atom);
        var AST_Boolean = DEFNODE("Boolean", null, {
            $documentation: "Base class for booleans"
        }, AST_Atom);
        var AST_False = DEFNODE("False", null, {
            $documentation: "The `false` atom",
            value: false
        }, AST_Boolean);
        var AST_True = DEFNODE("True", null, {
            $documentation: "The `true` atom",
            value: true
        }, AST_Boolean);
        /* -----[ TreeWalker ]----- */
        function TreeWalker(callback) {
            this.visit = callback;
            this.stack = [];
        }
        TreeWalker.prototype = {
            _visit: function(node, descend) {
                this.stack.push(node);
                var ret = this.visit(node, descend ? function() {
                    descend.call(node);
                } : noop);
                if (!ret && descend) {
                    descend.call(node);
                }
                this.stack.pop();
                return ret;
            },
            parent: function(n) {
                return this.stack[this.stack.length - 2 - (n || 0)];
            },
            push: function(node) {
                this.stack.push(node);
            },
            pop: function() {
                return this.stack.pop();
            },
            self: function() {
                return this.stack[this.stack.length - 1];
            },
            find_parent: function(type) {
                var stack = this.stack;
                for (var i = stack.length; --i >= 0; ) {
                    var x = stack[i];
                    if (x instanceof type) return x;
                }
            },
            has_directive: function(type) {
                return this.find_parent(AST_Scope).has_directive(type);
            },
            in_boolean_context: function() {
                var stack = this.stack;
                var i = stack.length, self = stack[--i];
                while (i > 0) {
                    var p = stack[--i];
                    if (p instanceof AST_If && p.condition === self || p instanceof AST_Conditional && p.condition === self || p instanceof AST_DWLoop && p.condition === self || p instanceof AST_For && p.condition === self || p instanceof AST_UnaryPrefix && p.operator == "!" && p.expression === self) {
                        return true;
                    }
                    if (!(p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||"))) return false;
                    self = p;
                }
            },
            loopcontrol_target: function(label) {
                var stack = this.stack;
                if (label) for (var i = stack.length; --i >= 0; ) {
                    var x = stack[i];
                    if (x instanceof AST_LabeledStatement && x.label.name == label.name) {
                        return x.body;
                    }
                } else for (var i = stack.length; --i >= 0; ) {
                    var x = stack[i];
                    if (x instanceof AST_Switch || x instanceof AST_IterationStatement) return x;
                }
            }
        };
        exports.DEFNODE = DEFNODE;
        exports.AST_Token = AST_Token;
        exports.AST_Node = AST_Node;
        exports.AST_Statement = AST_Statement;
        exports.AST_Debugger = AST_Debugger;
        exports.AST_Directive = AST_Directive;
        exports.AST_SimpleStatement = AST_SimpleStatement;
        exports.walk_body = walk_body;
        exports.AST_Block = AST_Block;
        exports.AST_BlockStatement = AST_BlockStatement;
        exports.AST_EmptyStatement = AST_EmptyStatement;
        exports.AST_StatementWithBody = AST_StatementWithBody;
        exports.AST_LabeledStatement = AST_LabeledStatement;
        exports.AST_IterationStatement = AST_IterationStatement;
        exports.AST_DWLoop = AST_DWLoop;
        exports.AST_Do = AST_Do;
        exports.AST_While = AST_While;
        exports.AST_For = AST_For;
        exports.AST_ForIn = AST_ForIn;
        exports.AST_With = AST_With;
        exports.AST_Scope = AST_Scope;
        exports.AST_Toplevel = AST_Toplevel;
        exports.AST_Lambda = AST_Lambda;
        exports.AST_Accessor = AST_Accessor;
        exports.AST_Function = AST_Function;
        exports.AST_Defun = AST_Defun;
        exports.AST_Jump = AST_Jump;
        exports.AST_Exit = AST_Exit;
        exports.AST_Return = AST_Return;
        exports.AST_Throw = AST_Throw;
        exports.AST_LoopControl = AST_LoopControl;
        exports.AST_Break = AST_Break;
        exports.AST_Continue = AST_Continue;
        exports.AST_If = AST_If;
        exports.AST_Switch = AST_Switch;
        exports.AST_SwitchBranch = AST_SwitchBranch;
        exports.AST_Default = AST_Default;
        exports.AST_Case = AST_Case;
        exports.AST_Try = AST_Try;
        exports.AST_Catch = AST_Catch;
        exports.AST_Finally = AST_Finally;
        exports.AST_Definitions = AST_Definitions;
        exports.AST_Var = AST_Var;
        exports.AST_Const = AST_Const;
        exports.AST_VarDef = AST_VarDef;
        exports.AST_Call = AST_Call;
        exports.AST_New = AST_New;
        exports.AST_Seq = AST_Seq;
        exports.AST_PropAccess = AST_PropAccess;
        exports.AST_Dot = AST_Dot;
        exports.AST_Sub = AST_Sub;
        exports.AST_Unary = AST_Unary;
        exports.AST_UnaryPrefix = AST_UnaryPrefix;
        exports.AST_UnaryPostfix = AST_UnaryPostfix;
        exports.AST_Binary = AST_Binary;
        exports.AST_Conditional = AST_Conditional;
        exports.AST_Assign = AST_Assign;
        exports.AST_Array = AST_Array;
        exports.AST_Object = AST_Object;
        exports.AST_ObjectProperty = AST_ObjectProperty;
        exports.AST_ObjectKeyVal = AST_ObjectKeyVal;
        exports.AST_ObjectSetter = AST_ObjectSetter;
        exports.AST_ObjectGetter = AST_ObjectGetter;
        exports.AST_Symbol = AST_Symbol;
        exports.AST_SymbolAccessor = AST_SymbolAccessor;
        exports.AST_SymbolDeclaration = AST_SymbolDeclaration;
        exports.AST_SymbolVar = AST_SymbolVar;
        exports.AST_SymbolConst = AST_SymbolConst;
        exports.AST_SymbolFunarg = AST_SymbolFunarg;
        exports.AST_SymbolDefun = AST_SymbolDefun;
        exports.AST_SymbolLambda = AST_SymbolLambda;
        exports.AST_SymbolCatch = AST_SymbolCatch;
        exports.AST_Label = AST_Label;
        exports.AST_SymbolRef = AST_SymbolRef;
        exports.AST_LabelRef = AST_LabelRef;
        exports.AST_This = AST_This;
        exports.AST_Constant = AST_Constant;
        exports.AST_String = AST_String;
        exports.AST_Number = AST_Number;
        exports.AST_RegExp = AST_RegExp;
        exports.AST_Atom = AST_Atom;
        exports.AST_Null = AST_Null;
        exports.AST_NaN = AST_NaN;
        exports.AST_Undefined = AST_Undefined;
        exports.AST_Hole = AST_Hole;
        exports.AST_Infinity = AST_Infinity;
        exports.AST_Boolean = AST_Boolean;
        exports.AST_False = AST_False;
        exports.AST_True = AST_True;
        exports.TreeWalker = TreeWalker;
        /***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/
        "use strict";
        var KEYWORDS = "break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with";
        var KEYWORDS_ATOM = "false null true";
        var RESERVED_WORDS = "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield" + " " + KEYWORDS_ATOM + " " + KEYWORDS;
        var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case";
        KEYWORDS = makePredicate(KEYWORDS);
        RESERVED_WORDS = makePredicate(RESERVED_WORDS);
        KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
        KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
        var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));
        var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
        var RE_OCT_NUMBER = /^0[0-7]+$/;
        var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
        var OPERATORS = makePredicate([ "in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "&&", "||" ]);
        var WHITESPACE_CHARS = makePredicate(characters(" \xa0\n\r	\f\u200b\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000"));
        var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:"));
        var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
        var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));
        /* -----[ Tokenizer ]----- */
        // regexps adapted from http://xregexp.com/plugins/#unicode
        var UNICODE = {
            letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
            non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
            space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
            connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
        };
        function is_letter(code) {
            return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));
        }
        function is_digit(code) {
            return code >= 48 && code <= 57;
        }
        function is_alphanumeric_char(code) {
            return is_digit(code) || is_letter(code);
        }
        function is_unicode_combining_mark(ch) {
            return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
        }
        function is_unicode_connector_punctuation(ch) {
            return UNICODE.connector_punctuation.test(ch);
        }
        function is_identifier(name) {
            return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);
        }
        function is_identifier_start(code) {
            return code == 36 || code == 95 || is_letter(code);
        }
        function is_identifier_char(ch) {
            var code = ch.charCodeAt(0);
            return is_identifier_start(code) || is_digit(code) || code == 8204 || code == 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);
        }
        function is_identifier_string(str) {
            var i = str.length;
            if (i == 0) return false;
            if (!is_identifier_start(str.charCodeAt(0))) return false;
            while (--i >= 0) {
                if (!is_identifier_char(str.charAt(i))) return false;
            }
            return true;
        }
        function parse_js_number(num) {
            if (RE_HEX_NUMBER.test(num)) {
                return parseInt(num.substr(2), 16);
            } else if (RE_OCT_NUMBER.test(num)) {
                return parseInt(num.substr(1), 8);
            } else if (RE_DEC_NUMBER.test(num)) {
                return parseFloat(num);
            }
        }
        function JS_Parse_Error(message, line, col, pos) {
            this.message = message;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.stack = new Error().stack;
        }
        JS_Parse_Error.prototype.toString = function() {
            return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack;
        };
        function js_error(message, filename, line, col, pos) {
            throw new JS_Parse_Error(message, line, col, pos);
        }
        function is_token(token, type, val) {
            return token.type == type && (val == null || token.value == val);
        }
        var EX_EOF = {};
        function tokenizer($TEXT, filename, html5_comments) {
            var S = {
                text: $TEXT.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ""),
                filename: filename,
                pos: 0,
                tokpos: 0,
                line: 1,
                tokline: 0,
                col: 0,
                tokcol: 0,
                newline_before: false,
                regex_allowed: false,
                comments_before: []
            };
            function peek() {
                return S.text.charAt(S.pos);
            }
            function next(signal_eof, in_string) {
                var ch = S.text.charAt(S.pos++);
                if (signal_eof && !ch) throw EX_EOF;
                if (ch == "\n") {
                    S.newline_before = S.newline_before || !in_string;
                    ++S.line;
                    S.col = 0;
                } else {
                    ++S.col;
                }
                return ch;
            }
            function forward(i) {
                while (i-- > 0) next();
            }
            function looking_at(str) {
                return S.text.substr(S.pos, str.length) == str;
            }
            function find(what, signal_eof) {
                var pos = S.text.indexOf(what, S.pos);
                if (signal_eof && pos == -1) throw EX_EOF;
                return pos;
            }
            function start_token() {
                S.tokline = S.line;
                S.tokcol = S.col;
                S.tokpos = S.pos;
            }
            var prev_was_dot = false;
            function token(type, value, is_comment) {
                S.regex_allowed = type == "operator" && !UNARY_POSTFIX(value) || type == "keyword" && KEYWORDS_BEFORE_EXPRESSION(value) || type == "punc" && PUNC_BEFORE_EXPRESSION(value);
                prev_was_dot = type == "punc" && value == ".";
                var ret = {
                    type: type,
                    value: value,
                    line: S.tokline,
                    col: S.tokcol,
                    pos: S.tokpos,
                    endpos: S.pos,
                    nlb: S.newline_before,
                    file: filename
                };
                if (!is_comment) {
                    ret.comments_before = S.comments_before;
                    S.comments_before = [];
                    // make note of any newlines in the comments that came before
                    for (var i = 0, len = ret.comments_before.length; i < len; i++) {
                        ret.nlb = ret.nlb || ret.comments_before[i].nlb;
                    }
                }
                S.newline_before = false;
                return new AST_Token(ret);
            }
            function skip_whitespace() {
                while (WHITESPACE_CHARS(peek())) next();
            }
            function read_while(pred) {
                var ret = "", ch, i = 0;
                while ((ch = peek()) && pred(ch, i++)) ret += next();
                return ret;
            }
            function parse_error(err) {
                js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
            }
            function read_num(prefix) {
                var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
                var num = read_while(function(ch, i) {
                    var code = ch.charCodeAt(0);
                    switch (code) {
                      case 120:
                      case 88:
                        // xX
                        return has_x ? false : has_x = true;

                      case 101:
                      case 69:
                        // eE
                        return has_x ? true : has_e ? false : has_e = after_e = true;

                      case 45:
                        // -
                        return after_e || i == 0 && !prefix;

                      case 43:
                        // +
                        return after_e;

                      case after_e = false, 46:
                        // .
                        return !has_dot && !has_x && !has_e ? has_dot = true : false;
                    }
                    return is_alphanumeric_char(code);
                });
                if (prefix) num = prefix + num;
                var valid = parse_js_number(num);
                if (!isNaN(valid)) {
                    return token("num", valid);
                } else {
                    parse_error("Invalid syntax: " + num);
                }
            }
            function read_escaped_char(in_string) {
                var ch = next(true, in_string);
                switch (ch.charCodeAt(0)) {
                  case 110:
                    return "\n";

                  case 114:
                    return "\r";

                  case 116:
                    return "	";

                  case 98:
                    return "\b";

                  case 118:
                    return "";

                  // \v
                    case 102:
                    return "\f";

                  case 48:
                    return "\x00";

                  case 120:
                    return String.fromCharCode(hex_bytes(2));

                  // \x
                    case 117:
                    return String.fromCharCode(hex_bytes(4));

                  // \u
                    case 10:
                    return "";

                  // newline
                    default:
                    return ch;
                }
            }
            function hex_bytes(n) {
                var num = 0;
                for (;n > 0; --n) {
                    var digit = parseInt(next(true), 16);
                    if (isNaN(digit)) parse_error("Invalid hex-character pattern in string");
                    num = num << 4 | digit;
                }
                return num;
            }
            var read_string = with_eof_error("Unterminated string constant", function() {
                var quote = next(), ret = "";
                for (;;) {
                    var ch = next(true);
                    if (ch == "\\") {
                        // read OctalEscapeSequence (XXX: deprecated if "strict mode")
                        // https://github.com/mishoo/UglifyJS/issues/178
                        var octal_len = 0, first = null;
                        ch = read_while(function(ch) {
                            if (ch >= "0" && ch <= "7") {
                                if (!first) {
                                    first = ch;
                                    return ++octal_len;
                                } else if (first <= "3" && octal_len <= 2) return ++octal_len; else if (first >= "4" && octal_len <= 1) return ++octal_len;
                            }
                            return false;
                        });
                        if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8)); else ch = read_escaped_char(true);
                    } else if (ch == quote) break;
                    ret += ch;
                }
                return token("string", ret);
            });
            function skip_line_comment(type) {
                var regex_allowed = S.regex_allowed;
                var i = find("\n"), ret;
                if (i == -1) {
                    ret = S.text.substr(S.pos);
                    S.pos = S.text.length;
                } else {
                    ret = S.text.substring(S.pos, i);
                    S.pos = i;
                }
                S.comments_before.push(token(type, ret, true));
                S.regex_allowed = regex_allowed;
                return next_token();
            }
            var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function() {
                var regex_allowed = S.regex_allowed;
                var i = find("*/", true);
                var text = S.text.substring(S.pos, i);
                var a = text.split("\n"), n = a.length;
                // update stream position
                S.pos = i + 2;
                S.line += n - 1;
                if (n > 1) S.col = a[n - 1].length; else S.col += a[n - 1].length;
                S.col += 2;
                var nlb = S.newline_before = S.newline_before || text.indexOf("\n") >= 0;
                S.comments_before.push(token("comment2", text, true));
                S.regex_allowed = regex_allowed;
                S.newline_before = nlb;
                return next_token();
            });
            function read_name() {
                var backslash = false, name = "", ch, escaped = false, hex;
                while ((ch = peek()) != null) {
                    if (!backslash) {
                        if (ch == "\\") escaped = backslash = true, next(); else if (is_identifier_char(ch)) name += next(); else break;
                    } else {
                        if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
                        ch = read_escaped_char();
                        if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
                        name += ch;
                        backslash = false;
                    }
                }
                if (KEYWORDS(name) && escaped) {
                    hex = name.charCodeAt(0).toString(16).toUpperCase();
                    name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
                }
                return name;
            }
            var read_regexp = with_eof_error("Unterminated regular expression", function(regexp) {
                var prev_backslash = false, ch, in_class = false;
                while (ch = next(true)) if (prev_backslash) {
                    regexp += "\\" + ch;
                    prev_backslash = false;
                } else if (ch == "[") {
                    in_class = true;
                    regexp += ch;
                } else if (ch == "]" && in_class) {
                    in_class = false;
                    regexp += ch;
                } else if (ch == "/" && !in_class) {
                    break;
                } else if (ch == "\\") {
                    prev_backslash = true;
                } else {
                    regexp += ch;
                }
                var mods = read_name();
                return token("regexp", new RegExp(regexp, mods));
            });
            function read_operator(prefix) {
                function grow(op) {
                    if (!peek()) return op;
                    var bigger = op + peek();
                    if (OPERATORS(bigger)) {
                        next();
                        return grow(bigger);
                    } else {
                        return op;
                    }
                }
                return token("operator", grow(prefix || next()));
            }
            function handle_slash() {
                next();
                switch (peek()) {
                  case "/":
                    next();
                    return skip_line_comment("comment1");

                  case "*":
                    next();
                    return skip_multiline_comment();
                }
                return S.regex_allowed ? read_regexp("") : read_operator("/");
            }
            function handle_dot() {
                next();
                return is_digit(peek().charCodeAt(0)) ? read_num(".") : token("punc", ".");
            }
            function read_word() {
                var word = read_name();
                if (prev_was_dot) return token("name", word);
                return KEYWORDS_ATOM(word) ? token("atom", word) : !KEYWORDS(word) ? token("name", word) : OPERATORS(word) ? token("operator", word) : token("keyword", word);
            }
            function with_eof_error(eof_error, cont) {
                return function(x) {
                    try {
                        return cont(x);
                    } catch (ex) {
                        if (ex === EX_EOF) parse_error(eof_error); else throw ex;
                    }
                };
            }
            function next_token(force_regexp) {
                if (force_regexp != null) return read_regexp(force_regexp);
                skip_whitespace();
                start_token();
                if (html5_comments) {
                    if (looking_at("<!--")) {
                        forward(4);
                        return skip_line_comment("comment3");
                    }
                    if (looking_at("-->") && S.newline_before) {
                        forward(3);
                        return skip_line_comment("comment4");
                    }
                }
                var ch = peek();
                if (!ch) return token("eof");
                var code = ch.charCodeAt(0);
                switch (code) {
                  case 34:
                  case 39:
                    return read_string();

                  case 46:
                    return handle_dot();

                  case 47:
                    return handle_slash();
                }
                if (is_digit(code)) return read_num();
                if (PUNC_CHARS(ch)) return token("punc", next());
                if (OPERATOR_CHARS(ch)) return read_operator();
                if (code == 92 || is_identifier_start(code)) return read_word();
                parse_error("Unexpected character '" + ch + "'");
            }
            next_token.context = function(nc) {
                if (nc) S = nc;
                return S;
            };
            return next_token;
        }
        /* -----[ Parser (constants) ]----- */
        var UNARY_PREFIX = makePredicate([ "typeof", "void", "delete", "--", "++", "!", "~", "-", "+" ]);
        var UNARY_POSTFIX = makePredicate([ "--", "++" ]);
        var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);
        var PRECEDENCE = function(a, ret) {
            for (var i = 0; i < a.length; ++i) {
                var b = a[i];
                for (var j = 0; j < b.length; ++j) {
                    ret[b[j]] = i + 1;
                }
            }
            return ret;
        }([ [ "||" ], [ "&&" ], [ "|" ], [ "^" ], [ "&" ], [ "==", "===", "!=", "!==" ], [ "<", ">", "<=", ">=", "in", "instanceof" ], [ ">>", "<<", ">>>" ], [ "+", "-" ], [ "*", "/", "%" ] ], {});
        var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);
        var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);
        /* -----[ Parser ]----- */
        function parse($TEXT, options) {
            options = defaults(options, {
                strict: false,
                filename: null,
                toplevel: null,
                expression: false,
                html5_comments: true
            });
            var S = {
                input: typeof $TEXT == "string" ? tokenizer($TEXT, options.filename, options.html5_comments) : $TEXT,
                token: null,
                prev: null,
                peeked: null,
                in_function: 0,
                in_directives: true,
                in_loop: 0,
                labels: []
            };
            S.token = next();
            function is(type, value) {
                return is_token(S.token, type, value);
            }
            function peek() {
                return S.peeked || (S.peeked = S.input());
            }
            function next() {
                S.prev = S.token;
                if (S.peeked) {
                    S.token = S.peeked;
                    S.peeked = null;
                } else {
                    S.token = S.input();
                }
                S.in_directives = S.in_directives && (S.token.type == "string" || is("punc", ";"));
                return S.token;
            }
            function prev() {
                return S.prev;
            }
            function croak(msg, line, col, pos) {
                var ctx = S.input.context();
                js_error(msg, ctx.filename, line != null ? line : ctx.tokline, col != null ? col : ctx.tokcol, pos != null ? pos : ctx.tokpos);
            }
            function token_error(token, msg) {
                croak(msg, token.line, token.col);
            }
            function unexpected(token) {
                if (token == null) token = S.token;
                token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
            }
            function expect_token(type, val) {
                if (is(type, val)) {
                    return next();
                }
                token_error(S.token, "Unexpected token " + S.token.type + " \xab" + S.token.value + "\xbb" + ", expected " + type + " \xab" + val + "\xbb");
            }
            function expect(punc) {
                return expect_token("punc", punc);
            }
            function can_insert_semicolon() {
                return !options.strict && (S.token.nlb || is("eof") || is("punc", "}"));
            }
            function semicolon() {
                if (is("punc", ";")) next(); else if (!can_insert_semicolon()) unexpected();
            }
            function parenthesised() {
                expect("(");
                var exp = expression(true);
                expect(")");
                return exp;
            }
            function embed_tokens(parser) {
                return function() {
                    var start = S.token;
                    var expr = parser();
                    var end = prev();
                    expr.start = start;
                    expr.end = end;
                    return expr;
                };
            }
            function handle_regexp() {
                if (is("operator", "/") || is("operator", "/=")) {
                    S.peeked = null;
                    S.token = S.input(S.token.value.substr(1));
                }
            }
            var statement = embed_tokens(function() {
                var tmp;
                handle_regexp();
                switch (S.token.type) {
                  case "string":
                    var dir = S.in_directives, stat = simple_statement();
                    // XXXv2: decide how to fix directives
                    if (dir && stat.body instanceof AST_String && !is("punc", ",")) return new AST_Directive({
                        value: stat.body.value
                    });
                    return stat;

                  case "num":
                  case "regexp":
                  case "operator":
                  case "atom":
                    return simple_statement();

                  case "name":
                    return is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement();

                  case "punc":
                    switch (S.token.value) {
                      case "{":
                        return new AST_BlockStatement({
                            start: S.token,
                            body: block_(),
                            end: prev()
                        });

                      case "[":
                      case "(":
                        return simple_statement();

                      case ";":
                        next();
                        return new AST_EmptyStatement();

                      default:
                        unexpected();
                    }

                  case "keyword":
                    switch (tmp = S.token.value, next(), tmp) {
                      case "break":
                        return break_cont(AST_Break);

                      case "continue":
                        return break_cont(AST_Continue);

                      case "debugger":
                        semicolon();
                        return new AST_Debugger();

                      case "do":
                        return new AST_Do({
                            body: in_loop(statement),
                            condition: (expect_token("keyword", "while"), tmp = parenthesised(), semicolon(), 
                            tmp)
                        });

                      case "while":
                        return new AST_While({
                            condition: parenthesised(),
                            body: in_loop(statement)
                        });

                      case "for":
                        return for_();

                      case "function":
                        return function_(AST_Defun);

                      case "if":
                        return if_();

                      case "return":
                        if (S.in_function == 0) croak("'return' outside of function");
                        return new AST_Return({
                            value: is("punc", ";") ? (next(), null) : can_insert_semicolon() ? null : (tmp = expression(true), 
                            semicolon(), tmp)
                        });

                      case "switch":
                        return new AST_Switch({
                            expression: parenthesised(),
                            body: in_loop(switch_body_)
                        });

                      case "throw":
                        if (S.token.nlb) croak("Illegal newline after 'throw'");
                        return new AST_Throw({
                            value: (tmp = expression(true), semicolon(), tmp)
                        });

                      case "try":
                        return try_();

                      case "var":
                        return tmp = var_(), semicolon(), tmp;

                      case "const":
                        return tmp = const_(), semicolon(), tmp;

                      case "with":
                        return new AST_With({
                            expression: parenthesised(),
                            body: statement()
                        });

                      default:
                        unexpected();
                    }
                }
            });
            function labeled_statement() {
                var label = as_symbol(AST_Label);
                if (find_if(function(l) {
                    return l.name == label.name;
                }, S.labels)) {
                    // ECMA-262, 12.12: An ECMAScript program is considered
                    // syntactically incorrect if it contains a
                    // LabelledStatement that is enclosed by a
                    // LabelledStatement with the same Identifier as label.
                    croak("Label " + label.name + " defined twice");
                }
                expect(":");
                S.labels.push(label);
                var stat = statement();
                S.labels.pop();
                if (!(stat instanceof AST_IterationStatement)) {
                    // check for `continue` that refers to this label.
                    // those should be reported as syntax errors.
                    // https://github.com/mishoo/UglifyJS2/issues/287
                    label.references.forEach(function(ref) {
                        if (ref instanceof AST_Continue) {
                            ref = ref.label.start;
                            croak("Continue label `" + label.name + "` refers to non-IterationStatement.", ref.line, ref.col, ref.pos);
                        }
                    });
                }
                return new AST_LabeledStatement({
                    body: stat,
                    label: label
                });
            }
            function simple_statement(tmp) {
                return new AST_SimpleStatement({
                    body: (tmp = expression(true), semicolon(), tmp)
                });
            }
            function break_cont(type) {
                var label = null, ldef;
                if (!can_insert_semicolon()) {
                    label = as_symbol(AST_LabelRef, true);
                }
                if (label != null) {
                    ldef = find_if(function(l) {
                        return l.name == label.name;
                    }, S.labels);
                    if (!ldef) croak("Undefined label " + label.name);
                    label.thedef = ldef;
                } else if (S.in_loop == 0) croak(type.TYPE + " not inside a loop or switch");
                semicolon();
                var stat = new type({
                    label: label
                });
                if (ldef) ldef.references.push(stat);
                return stat;
            }
            function for_() {
                expect("(");
                var init = null;
                if (!is("punc", ";")) {
                    init = is("keyword", "var") ? (next(), var_(true)) : expression(true, true);
                    if (is("operator", "in")) {
                        if (init instanceof AST_Var && init.definitions.length > 1) croak("Only one variable declaration allowed in for..in loop");
                        next();
                        return for_in(init);
                    }
                }
                return regular_for(init);
            }
            function regular_for(init) {
                expect(";");
                var test = is("punc", ";") ? null : expression(true);
                expect(";");
                var step = is("punc", ")") ? null : expression(true);
                expect(")");
                return new AST_For({
                    init: init,
                    condition: test,
                    step: step,
                    body: in_loop(statement)
                });
            }
            function for_in(init) {
                var lhs = init instanceof AST_Var ? init.definitions[0].name : null;
                var obj = expression(true);
                expect(")");
                return new AST_ForIn({
                    init: init,
                    name: lhs,
                    object: obj,
                    body: in_loop(statement)
                });
            }
            var function_ = function(ctor) {
                var in_statement = ctor === AST_Defun;
                var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
                if (in_statement && !name) unexpected();
                expect("(");
                return new ctor({
                    name: name,
                    argnames: function(first, a) {
                        while (!is("punc", ")")) {
                            if (first) first = false; else expect(",");
                            a.push(as_symbol(AST_SymbolFunarg));
                        }
                        next();
                        return a;
                    }(true, []),
                    body: function(loop, labels) {
                        ++S.in_function;
                        S.in_directives = true;
                        S.in_loop = 0;
                        S.labels = [];
                        var a = block_();
                        --S.in_function;
                        S.in_loop = loop;
                        S.labels = labels;
                        return a;
                    }(S.in_loop, S.labels)
                });
            };
            function if_() {
                var cond = parenthesised(), body = statement(), belse = null;
                if (is("keyword", "else")) {
                    next();
                    belse = statement();
                }
                return new AST_If({
                    condition: cond,
                    body: body,
                    alternative: belse
                });
            }
            function block_() {
                expect("{");
                var a = [];
                while (!is("punc", "}")) {
                    if (is("eof")) unexpected();
                    a.push(statement());
                }
                next();
                return a;
            }
            function switch_body_() {
                expect("{");
                var a = [], cur = null, branch = null, tmp;
                while (!is("punc", "}")) {
                    if (is("eof")) unexpected();
                    if (is("keyword", "case")) {
                        if (branch) branch.end = prev();
                        cur = [];
                        branch = new AST_Case({
                            start: (tmp = S.token, next(), tmp),
                            expression: expression(true),
                            body: cur
                        });
                        a.push(branch);
                        expect(":");
                    } else if (is("keyword", "default")) {
                        if (branch) branch.end = prev();
                        cur = [];
                        branch = new AST_Default({
                            start: (tmp = S.token, next(), expect(":"), tmp),
                            body: cur
                        });
                        a.push(branch);
                    } else {
                        if (!cur) unexpected();
                        cur.push(statement());
                    }
                }
                if (branch) branch.end = prev();
                next();
                return a;
            }
            function try_() {
                var body = block_(), bcatch = null, bfinally = null;
                if (is("keyword", "catch")) {
                    var start = S.token;
                    next();
                    expect("(");
                    var name = as_symbol(AST_SymbolCatch);
                    expect(")");
                    bcatch = new AST_Catch({
                        start: start,
                        argname: name,
                        body: block_(),
                        end: prev()
                    });
                }
                if (is("keyword", "finally")) {
                    var start = S.token;
                    next();
                    bfinally = new AST_Finally({
                        start: start,
                        body: block_(),
                        end: prev()
                    });
                }
                if (!bcatch && !bfinally) croak("Missing catch/finally blocks");
                return new AST_Try({
                    body: body,
                    bcatch: bcatch,
                    bfinally: bfinally
                });
            }
            function vardefs(no_in, in_const) {
                var a = [];
                for (;;) {
                    a.push(new AST_VarDef({
                        start: S.token,
                        name: as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
                        value: is("operator", "=") ? (next(), expression(false, no_in)) : null,
                        end: prev()
                    }));
                    if (!is("punc", ",")) break;
                    next();
                }
                return a;
            }
            var var_ = function(no_in) {
                return new AST_Var({
                    start: prev(),
                    definitions: vardefs(no_in, false),
                    end: prev()
                });
            };
            var const_ = function() {
                return new AST_Const({
                    start: prev(),
                    definitions: vardefs(false, true),
                    end: prev()
                });
            };
            var new_ = function() {
                var start = S.token;
                expect_token("operator", "new");
                var newexp = expr_atom(false), args;
                if (is("punc", "(")) {
                    next();
                    args = expr_list(")");
                } else {
                    args = [];
                }
                return subscripts(new AST_New({
                    start: start,
                    expression: newexp,
                    args: args,
                    end: prev()
                }), true);
            };
            function as_atom_node() {
                var tok = S.token, ret;
                switch (tok.type) {
                  case "name":
                  case "keyword":
                    ret = _make_symbol(AST_SymbolRef);
                    break;

                  case "num":
                    ret = new AST_Number({
                        start: tok,
                        end: tok,
                        value: tok.value
                    });
                    break;

                  case "string":
                    ret = new AST_String({
                        start: tok,
                        end: tok,
                        value: tok.value
                    });
                    break;

                  case "regexp":
                    ret = new AST_RegExp({
                        start: tok,
                        end: tok,
                        value: tok.value
                    });
                    break;

                  case "atom":
                    switch (tok.value) {
                      case "false":
                        ret = new AST_False({
                            start: tok,
                            end: tok
                        });
                        break;

                      case "true":
                        ret = new AST_True({
                            start: tok,
                            end: tok
                        });
                        break;

                      case "null":
                        ret = new AST_Null({
                            start: tok,
                            end: tok
                        });
                        break;
                    }
                    break;
                }
                next();
                return ret;
            }
            var expr_atom = function(allow_calls) {
                if (is("operator", "new")) {
                    return new_();
                }
                var start = S.token;
                if (is("punc")) {
                    switch (start.value) {
                      case "(":
                        next();
                        var ex = expression(true);
                        ex.start = start;
                        ex.end = S.token;
                        expect(")");
                        return subscripts(ex, allow_calls);

                      case "[":
                        return subscripts(array_(), allow_calls);

                      case "{":
                        return subscripts(object_(), allow_calls);
                    }
                    unexpected();
                }
                if (is("keyword", "function")) {
                    next();
                    var func = function_(AST_Function);
                    func.start = start;
                    func.end = prev();
                    return subscripts(func, allow_calls);
                }
                if (ATOMIC_START_TOKEN[S.token.type]) {
                    return subscripts(as_atom_node(), allow_calls);
                }
                unexpected();
            };
            function expr_list(closing, allow_trailing_comma, allow_empty) {
                var first = true, a = [];
                while (!is("punc", closing)) {
                    if (first) first = false; else expect(",");
                    if (allow_trailing_comma && is("punc", closing)) break;
                    if (is("punc", ",") && allow_empty) {
                        a.push(new AST_Hole({
                            start: S.token,
                            end: S.token
                        }));
                    } else {
                        a.push(expression(false));
                    }
                }
                next();
                return a;
            }
            var array_ = embed_tokens(function() {
                expect("[");
                return new AST_Array({
                    elements: expr_list("]", !options.strict, true)
                });
            });
            var object_ = embed_tokens(function() {
                expect("{");
                var first = true, a = [];
                while (!is("punc", "}")) {
                    if (first) first = false; else expect(",");
                    if (!options.strict && is("punc", "}")) // allow trailing comma
                    break;
                    var start = S.token;
                    var type = start.type;
                    var name = as_property_name();
                    if (type == "name" && !is("punc", ":")) {
                        if (name == "get") {
                            a.push(new AST_ObjectGetter({
                                start: start,
                                key: as_atom_node(),
                                value: function_(AST_Accessor),
                                end: prev()
                            }));
                            continue;
                        }
                        if (name == "set") {
                            a.push(new AST_ObjectSetter({
                                start: start,
                                key: as_atom_node(),
                                value: function_(AST_Accessor),
                                end: prev()
                            }));
                            continue;
                        }
                    }
                    expect(":");
                    a.push(new AST_ObjectKeyVal({
                        start: start,
                        key: name,
                        value: expression(false),
                        end: prev()
                    }));
                }
                next();
                return new AST_Object({
                    properties: a
                });
            });
            function as_property_name() {
                var tmp = S.token;
                next();
                switch (tmp.type) {
                  case "num":
                  case "string":
                  case "name":
                  case "operator":
                  case "keyword":
                  case "atom":
                    return tmp.value;

                  default:
                    unexpected();
                }
            }
            function as_name() {
                var tmp = S.token;
                next();
                switch (tmp.type) {
                  case "name":
                  case "operator":
                  case "keyword":
                  case "atom":
                    return tmp.value;

                  default:
                    unexpected();
                }
            }
            function _make_symbol(type) {
                var name = S.token.value;
                return new (name == "this" ? AST_This : type)({
                    name: String(name),
                    start: S.token,
                    end: S.token
                });
            }
            function as_symbol(type, noerror) {
                if (!is("name")) {
                    if (!noerror) croak("Name expected");
                    return null;
                }
                var sym = _make_symbol(type);
                next();
                return sym;
            }
            var subscripts = function(expr, allow_calls) {
                var start = expr.start;
                if (is("punc", ".")) {
                    next();
                    return subscripts(new AST_Dot({
                        start: start,
                        expression: expr,
                        property: as_name(),
                        end: prev()
                    }), allow_calls);
                }
                if (is("punc", "[")) {
                    next();
                    var prop = expression(true);
                    expect("]");
                    return subscripts(new AST_Sub({
                        start: start,
                        expression: expr,
                        property: prop,
                        end: prev()
                    }), allow_calls);
                }
                if (allow_calls && is("punc", "(")) {
                    next();
                    return subscripts(new AST_Call({
                        start: start,
                        expression: expr,
                        args: expr_list(")"),
                        end: prev()
                    }), true);
                }
                return expr;
            };
            var maybe_unary = function(allow_calls) {
                var start = S.token;
                if (is("operator") && UNARY_PREFIX(start.value)) {
                    next();
                    handle_regexp();
                    var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));
                    ex.start = start;
                    ex.end = prev();
                    return ex;
                }
                var val = expr_atom(allow_calls);
                while (is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
                    val = make_unary(AST_UnaryPostfix, S.token.value, val);
                    val.start = start;
                    val.end = S.token;
                    next();
                }
                return val;
            };
            function make_unary(ctor, op, expr) {
                if ((op == "++" || op == "--") && !is_assignable(expr)) croak("Invalid use of " + op + " operator");
                return new ctor({
                    operator: op,
                    expression: expr
                });
            }
            var expr_op = function(left, min_prec, no_in) {
                var op = is("operator") ? S.token.value : null;
                if (op == "in" && no_in) op = null;
                var prec = op != null ? PRECEDENCE[op] : null;
                if (prec != null && prec > min_prec) {
                    next();
                    var right = expr_op(maybe_unary(true), prec, no_in);
                    return expr_op(new AST_Binary({
                        start: left.start,
                        left: left,
                        operator: op,
                        right: right,
                        end: right.end
                    }), min_prec, no_in);
                }
                return left;
            };
            function expr_ops(no_in) {
                return expr_op(maybe_unary(true), 0, no_in);
            }
            var maybe_conditional = function(no_in) {
                var start = S.token;
                var expr = expr_ops(no_in);
                if (is("operator", "?")) {
                    next();
                    var yes = expression(false);
                    expect(":");
                    return new AST_Conditional({
                        start: start,
                        condition: expr,
                        consequent: yes,
                        alternative: expression(false, no_in),
                        end: prev()
                    });
                }
                return expr;
            };
            function is_assignable(expr) {
                if (!options.strict) return true;
                if (expr instanceof AST_This) return false;
                return expr instanceof AST_PropAccess || expr instanceof AST_Symbol;
            }
            var maybe_assign = function(no_in) {
                var start = S.token;
                var left = maybe_conditional(no_in), val = S.token.value;
                if (is("operator") && ASSIGNMENT(val)) {
                    if (is_assignable(left)) {
                        next();
                        return new AST_Assign({
                            start: start,
                            left: left,
                            operator: val,
                            right: maybe_assign(no_in),
                            end: prev()
                        });
                    }
                    croak("Invalid assignment");
                }
                return left;
            };
            var expression = function(commas, no_in) {
                var start = S.token;
                var expr = maybe_assign(no_in);
                if (commas && is("punc", ",")) {
                    next();
                    return new AST_Seq({
                        start: start,
                        car: expr,
                        cdr: expression(true, no_in),
                        end: peek()
                    });
                }
                return expr;
            };
            function in_loop(cont) {
                ++S.in_loop;
                var ret = cont();
                --S.in_loop;
                return ret;
            }
            if (options.expression) {
                return expression(true);
            }
            return function() {
                var start = S.token;
                var body = [];
                while (!is("eof")) body.push(statement());
                var end = prev();
                var toplevel = options.toplevel;
                if (toplevel) {
                    toplevel.body = toplevel.body.concat(body);
                    toplevel.end = end;
                } else {
                    toplevel = new AST_Toplevel({
                        start: start,
                        body: body,
                        end: end
                    });
                }
                return toplevel;
            }();
        }
        exports.KEYWORDS = KEYWORDS;
        exports.KEYWORDS_ATOM = KEYWORDS_ATOM;
        exports.RESERVED_WORDS = RESERVED_WORDS;
        exports.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;
        exports.OPERATOR_CHARS = OPERATOR_CHARS;
        exports.RE_HEX_NUMBER = RE_HEX_NUMBER;
        exports.RE_OCT_NUMBER = RE_OCT_NUMBER;
        exports.RE_DEC_NUMBER = RE_DEC_NUMBER;
        exports.OPERATORS = OPERATORS;
        exports.WHITESPACE_CHARS = WHITESPACE_CHARS;
        exports.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;
        exports.PUNC_CHARS = PUNC_CHARS;
        exports.REGEXP_MODIFIERS = REGEXP_MODIFIERS;
        exports.UNICODE = UNICODE;
        exports.is_letter = is_letter;
        exports.is_digit = is_digit;
        exports.is_alphanumeric_char = is_alphanumeric_char;
        exports.is_unicode_combining_mark = is_unicode_combining_mark;
        exports.is_unicode_connector_punctuation = is_unicode_connector_punctuation;
        exports.is_identifier = is_identifier;
        exports.is_identifier_start = is_identifier_start;
        exports.is_identifier_char = is_identifier_char;
        exports.is_identifier_string = is_identifier_string;
        exports.parse_js_number = parse_js_number;
        exports.JS_Parse_Error = JS_Parse_Error;
        exports.js_error = js_error;
        exports.is_token = is_token;
        exports.EX_EOF = EX_EOF;
        exports.tokenizer = tokenizer;
        exports.UNARY_PREFIX = UNARY_PREFIX;
        exports.UNARY_POSTFIX = UNARY_POSTFIX;
        exports.ASSIGNMENT = ASSIGNMENT;
        exports.PRECEDENCE = PRECEDENCE;
        exports.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;
        exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;
        exports.parse = parse;
        /***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/
        "use strict";
        // Tree transformer helpers.
        function TreeTransformer(before, after) {
            TreeWalker.call(this);
            this.before = before;
            this.after = after;
        }
        TreeTransformer.prototype = new TreeWalker();
        (function(undefined) {
            function _(node, descend) {
                node.DEFMETHOD("transform", function(tw, in_list) {
                    var x, y;
                    tw.push(this);
                    if (tw.before) x = tw.before(this, descend, in_list);
                    if (x === undefined) {
                        if (!tw.after) {
                            x = this;
                            descend(x, tw);
                        } else {
                            tw.stack[tw.stack.length - 1] = x = this.clone();
                            descend(x, tw);
                            y = tw.after(x, in_list);
                            if (y !== undefined) x = y;
                        }
                    }
                    tw.pop();
                    return x;
                });
            }
            function do_list(list, tw) {
                return MAP(list, function(node) {
                    return node.transform(tw, true);
                });
            }
            _(AST_Node, noop);
            _(AST_LabeledStatement, function(self, tw) {
                self.label = self.label.transform(tw);
                self.body = self.body.transform(tw);
            });
            _(AST_SimpleStatement, function(self, tw) {
                self.body = self.body.transform(tw);
            });
            _(AST_Block, function(self, tw) {
                self.body = do_list(self.body, tw);
            });
            _(AST_DWLoop, function(self, tw) {
                self.condition = self.condition.transform(tw);
                self.body = self.body.transform(tw);
            });
            _(AST_For, function(self, tw) {
                if (self.init) self.init = self.init.transform(tw);
                if (self.condition) self.condition = self.condition.transform(tw);
                if (self.step) self.step = self.step.transform(tw);
                self.body = self.body.transform(tw);
            });
            _(AST_ForIn, function(self, tw) {
                self.init = self.init.transform(tw);
                self.object = self.object.transform(tw);
                self.body = self.body.transform(tw);
            });
            _(AST_With, function(self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = self.body.transform(tw);
            });
            _(AST_Exit, function(self, tw) {
                if (self.value) self.value = self.value.transform(tw);
            });
            _(AST_LoopControl, function(self, tw) {
                if (self.label) self.label = self.label.transform(tw);
            });
            _(AST_If, function(self, tw) {
                self.condition = self.condition.transform(tw);
                self.body = self.body.transform(tw);
                if (self.alternative) self.alternative = self.alternative.transform(tw);
            });
            _(AST_Switch, function(self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = do_list(self.body, tw);
            });
            _(AST_Case, function(self, tw) {
                self.expression = self.expression.transform(tw);
                self.body = do_list(self.body, tw);
            });
            _(AST_Try, function(self, tw) {
                self.body = do_list(self.body, tw);
                if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
                if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
            });
            _(AST_Catch, function(self, tw) {
                self.argname = self.argname.transform(tw);
                self.body = do_list(self.body, tw);
            });
            _(AST_Definitions, function(self, tw) {
                self.definitions = do_list(self.definitions, tw);
            });
            _(AST_VarDef, function(self, tw) {
                self.name = self.name.transform(tw);
                if (self.value) self.value = self.value.transform(tw);
            });
            _(AST_Lambda, function(self, tw) {
                if (self.name) self.name = self.name.transform(tw);
                self.argnames = do_list(self.argnames, tw);
                self.body = do_list(self.body, tw);
            });
            _(AST_Call, function(self, tw) {
                self.expression = self.expression.transform(tw);
                self.args = do_list(self.args, tw);
            });
            _(AST_Seq, function(self, tw) {
                self.car = self.car.transform(tw);
                self.cdr = self.cdr.transform(tw);
            });
            _(AST_Dot, function(self, tw) {
                self.expression = self.expression.transform(tw);
            });
            _(AST_Sub, function(self, tw) {
                self.expression = self.expression.transform(tw);
                self.property = self.property.transform(tw);
            });
            _(AST_Unary, function(self, tw) {
                self.expression = self.expression.transform(tw);
            });
            _(AST_Binary, function(self, tw) {
                self.left = self.left.transform(tw);
                self.right = self.right.transform(tw);
            });
            _(AST_Conditional, function(self, tw) {
                self.condition = self.condition.transform(tw);
                self.consequent = self.consequent.transform(tw);
                self.alternative = self.alternative.transform(tw);
            });
            _(AST_Array, function(self, tw) {
                self.elements = do_list(self.elements, tw);
            });
            _(AST_Object, function(self, tw) {
                self.properties = do_list(self.properties, tw);
            });
            _(AST_ObjectProperty, function(self, tw) {
                self.value = self.value.transform(tw);
            });
        })();
        exports.TreeTransformer = TreeTransformer;
        /***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/
        "use strict";
        function SymbolDef(scope, index, orig) {
            this.name = orig.name;
            this.orig = [ orig ];
            this.scope = scope;
            this.references = [];
            this.global = false;
            this.mangled_name = null;
            this.undeclared = false;
            this.constant = false;
            this.index = index;
        }
        SymbolDef.prototype = {
            unmangleable: function(options) {
                return this.global && !(options && options.toplevel) || this.undeclared || !(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with);
            },
            mangle: function(options) {
                if (!this.mangled_name && !this.unmangleable(options)) {
                    var s = this.scope;
                    if (!options.screw_ie8 && this.orig[0] instanceof AST_SymbolLambda) s = s.parent_scope;
                    this.mangled_name = s.next_mangled(options, this);
                }
            }
        };
        AST_Toplevel.DEFMETHOD("figure_out_scope", function(options) {
            options = defaults(options, {
                screw_ie8: false
            });
            // pass 1: setup scope chaining and handle definitions
            var self = this;
            var scope = self.parent_scope = null;
            var defun = null;
            var nesting = 0;
            var tw = new TreeWalker(function(node, descend) {
                if (options.screw_ie8 && node instanceof AST_Catch) {
                    var save_scope = scope;
                    scope = new AST_Scope(node);
                    scope.init_scope_vars(nesting);
                    scope.parent_scope = save_scope;
                    descend();
                    scope = save_scope;
                    return true;
                }
                if (node instanceof AST_Scope) {
                    node.init_scope_vars(nesting);
                    var save_scope = node.parent_scope = scope;
                    var save_defun = defun;
                    defun = scope = node;
                    ++nesting;
                    descend();
                    --nesting;
                    scope = save_scope;
                    defun = save_defun;
                    return true;
                }
                if (node instanceof AST_Directive) {
                    node.scope = scope;
                    push_uniq(scope.directives, node.value);
                    return true;
                }
                if (node instanceof AST_With) {
                    for (var s = scope; s; s = s.parent_scope) s.uses_with = true;
                    return;
                }
                if (node instanceof AST_Symbol) {
                    node.scope = scope;
                }
                if (node instanceof AST_SymbolLambda) {
                    defun.def_function(node);
                } else if (node instanceof AST_SymbolDefun) {
                    // Careful here, the scope where this should be defined is
                    // the parent scope.  The reason is that we enter a new
                    // scope when we encounter the AST_Defun node (which is
                    // instanceof AST_Scope) but we get to the symbol a bit
                    // later.
                    (node.scope = defun.parent_scope).def_function(node);
                } else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolConst) {
                    var def = defun.def_variable(node);
                    def.constant = node instanceof AST_SymbolConst;
                    def.init = tw.parent().value;
                } else if (node instanceof AST_SymbolCatch) {
                    (options.screw_ie8 ? scope : defun).def_variable(node);
                }
            });
            self.walk(tw);
            // pass 2: find back references and eval
            var func = null;
            var globals = self.globals = new Dictionary();
            var tw = new TreeWalker(function(node, descend) {
                if (node instanceof AST_Lambda) {
                    var prev_func = func;
                    func = node;
                    descend();
                    func = prev_func;
                    return true;
                }
                if (node instanceof AST_SymbolRef) {
                    var name = node.name;
                    var sym = node.scope.find_variable(name);
                    if (!sym) {
                        var g;
                        if (globals.has(name)) {
                            g = globals.get(name);
                        } else {
                            g = new SymbolDef(self, globals.size(), node);
                            g.undeclared = true;
                            g.global = true;
                            globals.set(name, g);
                        }
                        node.thedef = g;
                        if (name == "eval" && tw.parent() instanceof AST_Call) {
                            for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) s.uses_eval = true;
                        }
                        if (func && name == "arguments") {
                            func.uses_arguments = true;
                        }
                    } else {
                        node.thedef = sym;
                    }
                    node.reference();
                    return true;
                }
            });
            self.walk(tw);
        });
        AST_Scope.DEFMETHOD("init_scope_vars", function(nesting) {
            this.directives = [];
            // contains the directives defined in this scope, i.e. "use strict"
            this.variables = new Dictionary();
            // map name to AST_SymbolVar (variables defined in this scope; includes functions)
            this.functions = new Dictionary();
            // map name to AST_SymbolDefun (functions defined in this scope)
            this.uses_with = false;
            // will be set to true if this or some nested scope uses the `with` statement
            this.uses_eval = false;
            // will be set to true if this or nested scope uses the global `eval`
            this.parent_scope = null;
            // the parent scope
            this.enclosed = [];
            // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
            this.cname = -1;
            // the current index for mangling functions/variables
            this.nesting = nesting;
        });
        AST_Scope.DEFMETHOD("strict", function() {
            return this.has_directive("use strict");
        });
        AST_Lambda.DEFMETHOD("init_scope_vars", function() {
            AST_Scope.prototype.init_scope_vars.apply(this, arguments);
            this.uses_arguments = false;
        });
        AST_SymbolRef.DEFMETHOD("reference", function() {
            var def = this.definition();
            def.references.push(this);
            var s = this.scope;
            while (s) {
                push_uniq(s.enclosed, def);
                if (s === def.scope) break;
                s = s.parent_scope;
            }
            this.frame = this.scope.nesting - def.scope.nesting;
        });
        AST_Scope.DEFMETHOD("find_variable", function(name) {
            if (name instanceof AST_Symbol) name = name.name;
            return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);
        });
        AST_Scope.DEFMETHOD("has_directive", function(value) {
            return this.parent_scope && this.parent_scope.has_directive(value) || (this.directives.indexOf(value) >= 0 ? this : null);
        });
        AST_Scope.DEFMETHOD("def_function", function(symbol) {
            this.functions.set(symbol.name, this.def_variable(symbol));
        });
        AST_Scope.DEFMETHOD("def_variable", function(symbol) {
            var def;
            if (!this.variables.has(symbol.name)) {
                def = new SymbolDef(this, this.variables.size(), symbol);
                this.variables.set(symbol.name, def);
                def.global = !this.parent_scope;
            } else {
                def = this.variables.get(symbol.name);
                def.orig.push(symbol);
            }
            return symbol.thedef = def;
        });
        AST_Scope.DEFMETHOD("next_mangled", function(options) {
            var ext = this.enclosed;
            out: while (true) {
                var m = base54(++this.cname);
                if (!is_identifier(m)) continue;
                // skip over "do"
                // https://github.com/mishoo/UglifyJS2/issues/242 -- do not
                // shadow a name excepted from mangling.
                if (options.except.indexOf(m) >= 0) continue;
                // we must ensure that the mangled name does not shadow a name
                // from some parent scope that is referenced in this or in
                // inner scopes.
                for (var i = ext.length; --i >= 0; ) {
                    var sym = ext[i];
                    var name = sym.mangled_name || sym.unmangleable(options) && sym.name;
                    if (m == name) continue out;
                }
                return m;
            }
        });
        AST_Function.DEFMETHOD("next_mangled", function(options, def) {
            // #179, #326
            // in Safari strict mode, something like (function x(x){...}) is a syntax error;
            // a function expression's argument cannot shadow the function expression's name
            var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
            while (true) {
                var name = AST_Lambda.prototype.next_mangled.call(this, options, def);
                if (!(tricky_def && tricky_def.mangled_name == name)) return name;
            }
        });
        AST_Scope.DEFMETHOD("references", function(sym) {
            if (sym instanceof AST_Symbol) sym = sym.definition();
            return this.enclosed.indexOf(sym) < 0 ? null : sym;
        });
        AST_Symbol.DEFMETHOD("unmangleable", function(options) {
            return this.definition().unmangleable(options);
        });
        // property accessors are not mangleable
        AST_SymbolAccessor.DEFMETHOD("unmangleable", function() {
            return true;
        });
        // labels are always mangleable
        AST_Label.DEFMETHOD("unmangleable", function() {
            return false;
        });
        AST_Symbol.DEFMETHOD("unreferenced", function() {
            return this.definition().references.length == 0 && !(this.scope.uses_eval || this.scope.uses_with);
        });
        AST_Symbol.DEFMETHOD("undeclared", function() {
            return this.definition().undeclared;
        });
        AST_LabelRef.DEFMETHOD("undeclared", function() {
            return false;
        });
        AST_Label.DEFMETHOD("undeclared", function() {
            return false;
        });
        AST_Symbol.DEFMETHOD("definition", function() {
            return this.thedef;
        });
        AST_Symbol.DEFMETHOD("global", function() {
            return this.definition().global;
        });
        AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options) {
            return defaults(options, {
                except: [],
                eval: false,
                sort: false,
                toplevel: false,
                screw_ie8: false
            });
        });
        AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
            options = this._default_mangler_options(options);
            // We only need to mangle declaration nodes.  Special logic wired
            // into the code generator will display the mangled name if it's
            // present (and for AST_SymbolRef-s it'll use the mangled name of
            // the AST_SymbolDeclaration that it points to).
            var lname = -1;
            var to_mangle = [];
            var tw = new TreeWalker(function(node, descend) {
                if (node instanceof AST_LabeledStatement) {
                    // lname is incremented when we get to the AST_Label
                    var save_nesting = lname;
                    descend();
                    lname = save_nesting;
                    return true;
                }
                if (node instanceof AST_Scope) {
                    var p = tw.parent(), a = [];
                    node.variables.each(function(symbol) {
                        if (options.except.indexOf(symbol.name) < 0) {
                            a.push(symbol);
                        }
                    });
                    if (options.sort) a.sort(function(a, b) {
                        return b.references.length - a.references.length;
                    });
                    to_mangle.push.apply(to_mangle, a);
                    return;
                }
                if (node instanceof AST_Label) {
                    var name;
                    do name = base54(++lname); while (!is_identifier(name));
                    node.mangled_name = name;
                    return true;
                }
            });
            this.walk(tw);
            to_mangle.forEach(function(def) {
                def.mangle(options);
            });
        });
        AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
            options = this._default_mangler_options(options);
            var tw = new TreeWalker(function(node) {
                if (node instanceof AST_Constant) base54.consider(node.print_to_string()); else if (node instanceof AST_Return) base54.consider("return"); else if (node instanceof AST_Throw) base54.consider("throw"); else if (node instanceof AST_Continue) base54.consider("continue"); else if (node instanceof AST_Break) base54.consider("break"); else if (node instanceof AST_Debugger) base54.consider("debugger"); else if (node instanceof AST_Directive) base54.consider(node.value); else if (node instanceof AST_While) base54.consider("while"); else if (node instanceof AST_Do) base54.consider("do while"); else if (node instanceof AST_If) {
                    base54.consider("if");
                    if (node.alternative) base54.consider("else");
                } else if (node instanceof AST_Var) base54.consider("var"); else if (node instanceof AST_Const) base54.consider("const"); else if (node instanceof AST_Lambda) base54.consider("function"); else if (node instanceof AST_For) base54.consider("for"); else if (node instanceof AST_ForIn) base54.consider("for in"); else if (node instanceof AST_Switch) base54.consider("switch"); else if (node instanceof AST_Case) base54.consider("case"); else if (node instanceof AST_Default) base54.consider("default"); else if (node instanceof AST_With) base54.consider("with"); else if (node instanceof AST_ObjectSetter) base54.consider("set" + node.key); else if (node instanceof AST_ObjectGetter) base54.consider("get" + node.key); else if (node instanceof AST_ObjectKeyVal) base54.consider(node.key); else if (node instanceof AST_New) base54.consider("new"); else if (node instanceof AST_This) base54.consider("this"); else if (node instanceof AST_Try) base54.consider("try"); else if (node instanceof AST_Catch) base54.consider("catch"); else if (node instanceof AST_Finally) base54.consider("finally"); else if (node instanceof AST_Symbol && node.unmangleable(options)) base54.consider(node.name); else if (node instanceof AST_Unary || node instanceof AST_Binary) base54.consider(node.operator); else if (node instanceof AST_Dot) base54.consider(node.property);
            });
            this.walk(tw);
            base54.sort();
        });
        var base54 = function() {
            var string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
            var chars, frequency;
            function reset() {
                frequency = Object.create(null);
                chars = string.split("").map(function(ch) {
                    return ch.charCodeAt(0);
                });
                chars.forEach(function(ch) {
                    frequency[ch] = 0;
                });
            }
            base54.consider = function(str) {
                for (var i = str.length; --i >= 0; ) {
                    var code = str.charCodeAt(i);
                    if (code in frequency) ++frequency[code];
                }
            };
            base54.sort = function() {
                chars = mergeSort(chars, function(a, b) {
                    if (is_digit(a) && !is_digit(b)) return 1;
                    if (is_digit(b) && !is_digit(a)) return -1;
                    return frequency[b] - frequency[a];
                });
            };
            base54.reset = reset;
            reset();
            base54.get = function() {
                return chars;
            };
            base54.freq = function() {
                return frequency;
            };
            function base54(num) {
                var ret = "", base = 54;
                do {
                    ret += String.fromCharCode(chars[num % base]);
                    num = Math.floor(num / base);
                    base = 64;
                } while (num > 0);
                return ret;
            }
            return base54;
        }();
        AST_Toplevel.DEFMETHOD("scope_warnings", function(options) {
            options = defaults(options, {
                undeclared: false,
                // this makes a lot of noise
                unreferenced: true,
                assign_to_global: true,
                func_arguments: true,
                nested_defuns: true,
                eval: true
            });
            var tw = new TreeWalker(function(node) {
                if (options.undeclared && node instanceof AST_SymbolRef && node.undeclared()) {
                    // XXX: this also warns about JS standard names,
                    // i.e. Object, Array, parseInt etc.  Should add a list of
                    // exceptions.
                    AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
                        name: node.name,
                        file: node.start.file,
                        line: node.start.line,
                        col: node.start.col
                    });
                }
                if (options.assign_to_global) {
                    var sym = null;
                    if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) sym = node.left; else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef) sym = node.init;
                    if (sym && (sym.undeclared() || sym.global() && sym.scope !== sym.definition().scope)) {
                        AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
                            msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
                            name: sym.name,
                            file: sym.start.file,
                            line: sym.start.line,
                            col: sym.start.col
                        });
                    }
                }
                if (options.eval && node instanceof AST_SymbolRef && node.undeclared() && node.name == "eval") {
                    AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start);
                }
                if (options.unreferenced && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label) && node.unreferenced()) {
                    AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
                        type: node instanceof AST_Label ? "Label" : "Symbol",
                        name: node.name,
                        file: node.start.file,
                        line: node.start.line,
                        col: node.start.col
                    });
                }
                if (options.func_arguments && node instanceof AST_Lambda && node.uses_arguments) {
                    AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
                        name: node.name ? node.name.name : "anonymous",
                        file: node.start.file,
                        line: node.start.line,
                        col: node.start.col
                    });
                }
                if (options.nested_defuns && node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope)) {
                    AST_Node.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]', {
                        name: node.name.name,
                        type: tw.parent().TYPE,
                        file: node.start.file,
                        line: node.start.line,
                        col: node.start.col
                    });
                }
            });
            this.walk(tw);
        });
        exports.SymbolDef = SymbolDef;
        exports.base54 = base54;
        /***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/
        "use strict";
        function OutputStream(options) {
            options = defaults(options, {
                indent_start: 0,
                indent_level: 4,
                quote_keys: false,
                space_colon: true,
                ascii_only: false,
                inline_script: false,
                width: 80,
                max_line_len: 32e3,
                beautify: false,
                source_map: null,
                bracketize: false,
                semicolons: true,
                comments: false,
                preserve_line: false,
                screw_ie8: false,
                preamble: null
            }, true);
            var indentation = 0;
            var current_col = 0;
            var current_line = 1;
            var current_pos = 0;
            var OUTPUT = "";
            function to_ascii(str, identifier) {
                return str.replace(/[\u0080-\uffff]/g, function(ch) {
                    var code = ch.charCodeAt(0).toString(16);
                    if (code.length <= 2 && !identifier) {
                        while (code.length < 2) code = "0" + code;
                        return "\\x" + code;
                    } else {
                        while (code.length < 4) code = "0" + code;
                        return "\\u" + code;
                    }
                });
            }
            function make_string(str) {
                var dq = 0, sq = 0;
                str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s) {
                    switch (s) {
                      case "\\":
                        return "\\\\";

                      case "\b":
                        return "\\b";

                      case "\f":
                        return "\\f";

                      case "\n":
                        return "\\n";

                      case "\r":
                        return "\\r";

                      case "\u2028":
                        return "\\u2028";

                      case "\u2029":
                        return "\\u2029";

                      case '"':
                        ++dq;
                        return '"';

                      case "'":
                        ++sq;
                        return "'";

                      case "\x00":
                        return "\\x00";
                    }
                    return s;
                });
                if (options.ascii_only) str = to_ascii(str);
                if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'"; else return '"' + str.replace(/\x22/g, '\\"') + '"';
            }
            function encode_string(str) {
                var ret = make_string(str);
                if (options.inline_script) ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
                return ret;
            }
            function make_name(name) {
                name = name.toString();
                if (options.ascii_only) name = to_ascii(name, true);
                return name;
            }
            function make_indent(back) {
                return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
            }
            /* -----[ beautification/minification ]----- */
            var might_need_space = false;
            var might_need_semicolon = false;
            var last = null;
            function last_char() {
                return last.charAt(last.length - 1);
            }
            function maybe_newline() {
                if (options.max_line_len && current_col > options.max_line_len) print("\n");
            }
            var requireSemicolonChars = makePredicate("( [ + * / - , .");
            function print(str) {
                str = String(str);
                var ch = str.charAt(0);
                if (might_need_semicolon) {
                    if ((!ch || ";}".indexOf(ch) < 0) && !/[;]$/.test(last)) {
                        if (options.semicolons || requireSemicolonChars(ch)) {
                            OUTPUT += ";";
                            current_col++;
                            current_pos++;
                        } else {
                            OUTPUT += "\n";
                            current_pos++;
                            current_line++;
                            current_col = 0;
                        }
                        if (!options.beautify) might_need_space = false;
                    }
                    might_need_semicolon = false;
                    maybe_newline();
                }
                if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
                    var target_line = stack[stack.length - 1].start.line;
                    while (current_line < target_line) {
                        OUTPUT += "\n";
                        current_pos++;
                        current_line++;
                        current_col = 0;
                        might_need_space = false;
                    }
                }
                if (might_need_space) {
                    var prev = last_char();
                    if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || /^[\+\-\/]$/.test(ch) && ch == prev) {
                        OUTPUT += " ";
                        current_col++;
                        current_pos++;
                    }
                    might_need_space = false;
                }
                var a = str.split(/\r?\n/), n = a.length - 1;
                current_line += n;
                if (n == 0) {
                    current_col += a[n].length;
                } else {
                    current_col = a[n].length;
                }
                current_pos += str.length;
                last = str;
                OUTPUT += str;
            }
            var space = options.beautify ? function() {
                print(" ");
            } : function() {
                might_need_space = true;
            };
            var indent = options.beautify ? function(half) {
                if (options.beautify) {
                    print(make_indent(half ? .5 : 0));
                }
            } : noop;
            var with_indent = options.beautify ? function(col, cont) {
                if (col === true) col = next_indent();
                var save_indentation = indentation;
                indentation = col;
                var ret = cont();
                indentation = save_indentation;
                return ret;
            } : function(col, cont) {
                return cont();
            };
            var newline = options.beautify ? function() {
                print("\n");
            } : noop;
            var semicolon = options.beautify ? function() {
                print(";");
            } : function() {
                might_need_semicolon = true;
            };
            function force_semicolon() {
                might_need_semicolon = false;
                print(";");
            }
            function next_indent() {
                return indentation + options.indent_level;
            }
            function with_block(cont) {
                var ret;
                print("{");
                newline();
                with_indent(next_indent(), function() {
                    ret = cont();
                });
                indent();
                print("}");
                return ret;
            }
            function with_parens(cont) {
                print("(");
                //XXX: still nice to have that for argument lists
                //var ret = with_indent(current_col, cont);
                var ret = cont();
                print(")");
                return ret;
            }
            function with_square(cont) {
                print("[");
                //var ret = with_indent(current_col, cont);
                var ret = cont();
                print("]");
                return ret;
            }
            function comma() {
                print(",");
                space();
            }
            function colon() {
                print(":");
                if (options.space_colon) space();
            }
            var add_mapping = options.source_map ? function(token, name) {
                try {
                    if (token) options.source_map.add(token.file || "?", current_line, current_col, token.line, token.col, !name && token.type == "name" ? token.value : name);
                } catch (ex) {
                    AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} \u2192 {cline},{ccol} [{name}]", {
                        file: token.file,
                        line: token.line,
                        col: token.col,
                        cline: current_line,
                        ccol: current_col,
                        name: name || ""
                    });
                }
            } : noop;
            function get() {
                return OUTPUT;
            }
            if (options.preamble) {
                print(options.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
            }
            var stack = [];
            return {
                get: get,
                toString: get,
                indent: indent,
                indentation: function() {
                    return indentation;
                },
                current_width: function() {
                    return current_col - indentation;
                },
                should_break: function() {
                    return options.width && this.current_width() >= options.width;
                },
                newline: newline,
                print: print,
                space: space,
                comma: comma,
                colon: colon,
                last: function() {
                    return last;
                },
                semicolon: semicolon,
                force_semicolon: force_semicolon,
                to_ascii: to_ascii,
                print_name: function(name) {
                    print(make_name(name));
                },
                print_string: function(str) {
                    print(encode_string(str));
                },
                next_indent: next_indent,
                with_indent: with_indent,
                with_block: with_block,
                with_parens: with_parens,
                with_square: with_square,
                add_mapping: add_mapping,
                option: function(opt) {
                    return options[opt];
                },
                line: function() {
                    return current_line;
                },
                col: function() {
                    return current_col;
                },
                pos: function() {
                    return current_pos;
                },
                push_node: function(node) {
                    stack.push(node);
                },
                pop_node: function() {
                    return stack.pop();
                },
                stack: function() {
                    return stack;
                },
                parent: function(n) {
                    return stack[stack.length - 2 - (n || 0)];
                }
            };
        }
        /* -----[ code generators ]----- */
        (function() {
            /* -----[ utils ]----- */
            function DEFPRINT(nodetype, generator) {
                nodetype.DEFMETHOD("_codegen", generator);
            }
            AST_Node.DEFMETHOD("print", function(stream, force_parens) {
                var self = this, generator = self._codegen;
                function doit() {
                    self.add_comments(stream);
                    self.add_source_map(stream);
                    generator(self, stream);
                }
                stream.push_node(self);
                if (force_parens || self.needs_parens(stream)) {
                    stream.with_parens(doit);
                } else {
                    doit();
                }
                stream.pop_node();
            });
            AST_Node.DEFMETHOD("print_to_string", function(options) {
                var s = OutputStream(options);
                this.print(s);
                return s.get();
            });
            /* -----[ comments ]----- */
            AST_Node.DEFMETHOD("add_comments", function(output) {
                var c = output.option("comments"), self = this;
                if (c) {
                    var start = self.start;
                    if (start && !start._comments_dumped) {
                        start._comments_dumped = true;
                        var comments = start.comments_before || [];
                        // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
                        //               and https://github.com/mishoo/UglifyJS2/issues/372
                        if (self instanceof AST_Exit && self.value) {
                            self.value.walk(new TreeWalker(function(node) {
                                if (node.start && node.start.comments_before) {
                                    comments = comments.concat(node.start.comments_before);
                                    node.start.comments_before = [];
                                }
                                if (node instanceof AST_Function || node instanceof AST_Array || node instanceof AST_Object) {
                                    return true;
                                }
                            }));
                        }
                        if (c.test) {
                            comments = comments.filter(function(comment) {
                                return c.test(comment.value);
                            });
                        } else if (typeof c == "function") {
                            comments = comments.filter(function(comment) {
                                return c(self, comment);
                            });
                        }
                        comments.forEach(function(c) {
                            if (/comment[134]/.test(c.type)) {
                                output.print("//" + c.value + "\n");
                                output.indent();
                            } else if (c.type == "comment2") {
                                output.print("/*" + c.value + "*/");
                                if (start.nlb) {
                                    output.print("\n");
                                    output.indent();
                                } else {
                                    output.space();
                                }
                            }
                        });
                    }
                }
            });
            /* -----[ PARENTHESES ]----- */
            function PARENS(nodetype, func) {
                nodetype.DEFMETHOD("needs_parens", func);
            }
            PARENS(AST_Node, function() {
                return false;
            });
            // a function expression needs parens around it when it's provably
            // the first token to appear in a statement.
            PARENS(AST_Function, function(output) {
                return first_in_statement(output);
            });
            // same goes for an object literal, because otherwise it would be
            // interpreted as a block of code.
            PARENS(AST_Object, function(output) {
                return first_in_statement(output);
            });
            PARENS(AST_Unary, function(output) {
                var p = output.parent();
                return p instanceof AST_PropAccess && p.expression === this;
            });
            PARENS(AST_Seq, function(output) {
                var p = output.parent();
                return p instanceof AST_Call || p instanceof AST_Unary || p instanceof AST_Binary || p instanceof AST_VarDef || p instanceof AST_PropAccess || p instanceof AST_Array || p instanceof AST_ObjectProperty || p instanceof AST_Conditional;
            });
            PARENS(AST_Binary, function(output) {
                var p = output.parent();
                // (foo && bar)()
                if (p instanceof AST_Call && p.expression === this) return true;
                // typeof (foo && bar)
                if (p instanceof AST_Unary) return true;
                // (foo && bar)["prop"], (foo && bar).prop
                if (p instanceof AST_PropAccess && p.expression === this) return true;
                // this deals with precedence: 3 * (2 + 1)
                if (p instanceof AST_Binary) {
                    var po = p.operator, pp = PRECEDENCE[po];
                    var so = this.operator, sp = PRECEDENCE[so];
                    if (pp > sp || pp == sp && this === p.right) {
                        return true;
                    }
                }
            });
            PARENS(AST_PropAccess, function(output) {
                var p = output.parent();
                if (p instanceof AST_New && p.expression === this) {
                    // i.e. new (foo.bar().baz)
                    //
                    // if there's one call into this subtree, then we need
                    // parens around it too, otherwise the call will be
                    // interpreted as passing the arguments to the upper New
                    // expression.
                    try {
                        this.walk(new TreeWalker(function(node) {
                            if (node instanceof AST_Call) throw p;
                        }));
                    } catch (ex) {
                        if (ex !== p) throw ex;
                        return true;
                    }
                }
            });
            PARENS(AST_Call, function(output) {
                var p = output.parent(), p1;
                if (p instanceof AST_New && p.expression === this) return true;
                // workaround for Safari bug.
                // https://bugs.webkit.org/show_bug.cgi?id=123506
                return this.expression instanceof AST_Function && p instanceof AST_PropAccess && p.expression === this && (p1 = output.parent(1)) instanceof AST_Assign && p1.left === p;
            });
            PARENS(AST_New, function(output) {
                var p = output.parent();
                if (no_constructor_parens(this, output) && (p instanceof AST_PropAccess || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)
                return true;
            });
            PARENS(AST_Number, function(output) {
                var p = output.parent();
                if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this) return true;
            });
            PARENS(AST_NaN, function(output) {
                var p = output.parent();
                if (p instanceof AST_PropAccess && p.expression === this) return true;
            });
            function assign_and_conditional_paren_rules(output) {
                var p = output.parent();
                // !(a = false)  true
                if (p instanceof AST_Unary) return true;
                // 1 + (a = 2) + 3  6, side effect setting a = 2
                if (p instanceof AST_Binary && !(p instanceof AST_Assign)) return true;
                // (a = func)() or new (a = Object)()
                if (p instanceof AST_Call && p.expression === this) return true;
                // (a = foo) ? bar : baz
                if (p instanceof AST_Conditional && p.condition === this) return true;
                // (a = foo)["prop"] or (a = foo).prop
                if (p instanceof AST_PropAccess && p.expression === this) return true;
            }
            PARENS(AST_Assign, assign_and_conditional_paren_rules);
            PARENS(AST_Conditional, assign_and_conditional_paren_rules);
            /* -----[ PRINTERS ]----- */
            DEFPRINT(AST_Directive, function(self, output) {
                output.print_string(self.value);
                output.semicolon();
            });
            DEFPRINT(AST_Debugger, function(self, output) {
                output.print("debugger");
                output.semicolon();
            });
            /* -----[ statements ]----- */
            function display_body(body, is_toplevel, output) {
                var last = body.length - 1;
                body.forEach(function(stmt, i) {
                    if (!(stmt instanceof AST_EmptyStatement)) {
                        output.indent();
                        stmt.print(output);
                        if (!(i == last && is_toplevel)) {
                            output.newline();
                            if (is_toplevel) output.newline();
                        }
                    }
                });
            }
            AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
                force_statement(this.body, output);
            });
            DEFPRINT(AST_Statement, function(self, output) {
                self.body.print(output);
                output.semicolon();
            });
            DEFPRINT(AST_Toplevel, function(self, output) {
                display_body(self.body, true, output);
                output.print("");
            });
            DEFPRINT(AST_LabeledStatement, function(self, output) {
                self.label.print(output);
                output.colon();
                self.body.print(output);
            });
            DEFPRINT(AST_SimpleStatement, function(self, output) {
                self.body.print(output);
                output.semicolon();
            });
            function print_bracketed(body, output) {
                if (body.length > 0) output.with_block(function() {
                    display_body(body, false, output);
                }); else output.print("{}");
            }
            DEFPRINT(AST_BlockStatement, function(self, output) {
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST_EmptyStatement, function(self, output) {
                output.semicolon();
            });
            DEFPRINT(AST_Do, function(self, output) {
                output.print("do");
                output.space();
                self._do_print_body(output);
                output.space();
                output.print("while");
                output.space();
                output.with_parens(function() {
                    self.condition.print(output);
                });
                output.semicolon();
            });
            DEFPRINT(AST_While, function(self, output) {
                output.print("while");
                output.space();
                output.with_parens(function() {
                    self.condition.print(output);
                });
                output.space();
                self._do_print_body(output);
            });
            DEFPRINT(AST_For, function(self, output) {
                output.print("for");
                output.space();
                output.with_parens(function() {
                    if (self.init) {
                        if (self.init instanceof AST_Definitions) {
                            self.init.print(output);
                        } else {
                            parenthesize_for_noin(self.init, output, true);
                        }
                        output.print(";");
                        output.space();
                    } else {
                        output.print(";");
                    }
                    if (self.condition) {
                        self.condition.print(output);
                        output.print(";");
                        output.space();
                    } else {
                        output.print(";");
                    }
                    if (self.step) {
                        self.step.print(output);
                    }
                });
                output.space();
                self._do_print_body(output);
            });
            DEFPRINT(AST_ForIn, function(self, output) {
                output.print("for");
                output.space();
                output.with_parens(function() {
                    self.init.print(output);
                    output.space();
                    output.print("in");
                    output.space();
                    self.object.print(output);
                });
                output.space();
                self._do_print_body(output);
            });
            DEFPRINT(AST_With, function(self, output) {
                output.print("with");
                output.space();
                output.with_parens(function() {
                    self.expression.print(output);
                });
                output.space();
                self._do_print_body(output);
            });
            /* -----[ functions ]----- */
            AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
                var self = this;
                if (!nokeyword) {
                    output.print("function");
                }
                if (self.name) {
                    output.space();
                    self.name.print(output);
                }
                output.with_parens(function() {
                    self.argnames.forEach(function(arg, i) {
                        if (i) output.comma();
                        arg.print(output);
                    });
                });
                output.space();
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST_Lambda, function(self, output) {
                self._do_print(output);
            });
            /* -----[ exits ]----- */
            AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
                output.print(kind);
                if (this.value) {
                    output.space();
                    this.value.print(output);
                }
                output.semicolon();
            });
            DEFPRINT(AST_Return, function(self, output) {
                self._do_print(output, "return");
            });
            DEFPRINT(AST_Throw, function(self, output) {
                self._do_print(output, "throw");
            });
            /* -----[ loop control ]----- */
            AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
                output.print(kind);
                if (this.label) {
                    output.space();
                    this.label.print(output);
                }
                output.semicolon();
            });
            DEFPRINT(AST_Break, function(self, output) {
                self._do_print(output, "break");
            });
            DEFPRINT(AST_Continue, function(self, output) {
                self._do_print(output, "continue");
            });
            /* -----[ if ]----- */
            function make_then(self, output) {
                if (output.option("bracketize")) {
                    make_block(self.body, output);
                    return;
                }
                // The squeezer replaces "block"-s that contain only a single
                // statement with the statement itself; technically, the AST
                // is correct, but this can create problems when we output an
                // IF having an ELSE clause where the THEN clause ends in an
                // IF *without* an ELSE block (then the outer ELSE would refer
                // to the inner IF).  This function checks for this case and
                // adds the block brackets if needed.
                if (!self.body) return output.force_semicolon();
                if (self.body instanceof AST_Do && !output.option("screw_ie8")) {
                    // https://github.com/mishoo/UglifyJS/issues/#issue/57 IE
                    // croaks with "syntax error" on code like this: if (foo)
                    // do ... while(cond); else ...  we need block brackets
                    // around do/while
                    make_block(self.body, output);
                    return;
                }
                var b = self.body;
                while (true) {
                    if (b instanceof AST_If) {
                        if (!b.alternative) {
                            make_block(self.body, output);
                            return;
                        }
                        b = b.alternative;
                    } else if (b instanceof AST_StatementWithBody) {
                        b = b.body;
                    } else break;
                }
                force_statement(self.body, output);
            }
            DEFPRINT(AST_If, function(self, output) {
                output.print("if");
                output.space();
                output.with_parens(function() {
                    self.condition.print(output);
                });
                output.space();
                if (self.alternative) {
                    make_then(self, output);
                    output.space();
                    output.print("else");
                    output.space();
                    force_statement(self.alternative, output);
                } else {
                    self._do_print_body(output);
                }
            });
            /* -----[ switch ]----- */
            DEFPRINT(AST_Switch, function(self, output) {
                output.print("switch");
                output.space();
                output.with_parens(function() {
                    self.expression.print(output);
                });
                output.space();
                if (self.body.length > 0) output.with_block(function() {
                    self.body.forEach(function(stmt, i) {
                        if (i) output.newline();
                        output.indent(true);
                        stmt.print(output);
                    });
                }); else output.print("{}");
            });
            AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
                if (this.body.length > 0) {
                    output.newline();
                    this.body.forEach(function(stmt) {
                        output.indent();
                        stmt.print(output);
                        output.newline();
                    });
                }
            });
            DEFPRINT(AST_Default, function(self, output) {
                output.print("default:");
                self._do_print_body(output);
            });
            DEFPRINT(AST_Case, function(self, output) {
                output.print("case");
                output.space();
                self.expression.print(output);
                output.print(":");
                self._do_print_body(output);
            });
            /* -----[ exceptions ]----- */
            DEFPRINT(AST_Try, function(self, output) {
                output.print("try");
                output.space();
                print_bracketed(self.body, output);
                if (self.bcatch) {
                    output.space();
                    self.bcatch.print(output);
                }
                if (self.bfinally) {
                    output.space();
                    self.bfinally.print(output);
                }
            });
            DEFPRINT(AST_Catch, function(self, output) {
                output.print("catch");
                output.space();
                output.with_parens(function() {
                    self.argname.print(output);
                });
                output.space();
                print_bracketed(self.body, output);
            });
            DEFPRINT(AST_Finally, function(self, output) {
                output.print("finally");
                output.space();
                print_bracketed(self.body, output);
            });
            /* -----[ var/const ]----- */
            AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
                output.print(kind);
                output.space();
                this.definitions.forEach(function(def, i) {
                    if (i) output.comma();
                    def.print(output);
                });
                var p = output.parent();
                var in_for = p instanceof AST_For || p instanceof AST_ForIn;
                var avoid_semicolon = in_for && p.init === this;
                if (!avoid_semicolon) output.semicolon();
            });
            DEFPRINT(AST_Var, function(self, output) {
                self._do_print(output, "var");
            });
            DEFPRINT(AST_Const, function(self, output) {
                self._do_print(output, "const");
            });
            function parenthesize_for_noin(node, output, noin) {
                if (!noin) node.print(output); else try {
                    // need to take some precautions here:
                    //    https://github.com/mishoo/UglifyJS2/issues/60
                    node.walk(new TreeWalker(function(node) {
                        if (node instanceof AST_Binary && node.operator == "in") throw output;
                    }));
                    node.print(output);
                } catch (ex) {
                    if (ex !== output) throw ex;
                    node.print(output, true);
                }
            }
            DEFPRINT(AST_VarDef, function(self, output) {
                self.name.print(output);
                if (self.value) {
                    output.space();
                    output.print("=");
                    output.space();
                    var p = output.parent(1);
                    var noin = p instanceof AST_For || p instanceof AST_ForIn;
                    parenthesize_for_noin(self.value, output, noin);
                }
            });
            /* -----[ other expressions ]----- */
            DEFPRINT(AST_Call, function(self, output) {
                self.expression.print(output);
                if (self instanceof AST_New && no_constructor_parens(self, output)) return;
                output.with_parens(function() {
                    self.args.forEach(function(expr, i) {
                        if (i) output.comma();
                        expr.print(output);
                    });
                });
            });
            DEFPRINT(AST_New, function(self, output) {
                output.print("new");
                output.space();
                AST_Call.prototype._codegen(self, output);
            });
            AST_Seq.DEFMETHOD("_do_print", function(output) {
                this.car.print(output);
                if (this.cdr) {
                    output.comma();
                    if (output.should_break()) {
                        output.newline();
                        output.indent();
                    }
                    this.cdr.print(output);
                }
            });
            DEFPRINT(AST_Seq, function(self, output) {
                self._do_print(output);
            });
            DEFPRINT(AST_Dot, function(self, output) {
                var expr = self.expression;
                expr.print(output);
                if (expr instanceof AST_Number && expr.getValue() >= 0) {
                    if (!/[xa-f.]/i.test(output.last())) {
                        output.print(".");
                    }
                }
                output.print(".");
                // the name after dot would be mapped about here.
                output.add_mapping(self.end);
                output.print_name(self.property);
            });
            DEFPRINT(AST_Sub, function(self, output) {
                self.expression.print(output);
                output.print("[");
                self.property.print(output);
                output.print("]");
            });
            DEFPRINT(AST_UnaryPrefix, function(self, output) {
                var op = self.operator;
                output.print(op);
                if (/^[a-z]/i.test(op)) output.space();
                self.expression.print(output);
            });
            DEFPRINT(AST_UnaryPostfix, function(self, output) {
                self.expression.print(output);
                output.print(self.operator);
            });
            DEFPRINT(AST_Binary, function(self, output) {
                self.left.print(output);
                output.space();
                output.print(self.operator);
                if (self.operator == "<" && self.right instanceof AST_UnaryPrefix && self.right.operator == "!" && self.right.expression instanceof AST_UnaryPrefix && self.right.expression.operator == "--") {
                    // space is mandatory to avoid outputting <!--
                    // http://javascript.spec.whatwg.org/#comment-syntax
                    output.print(" ");
                } else {
                    // the space is optional depending on "beautify"
                    output.space();
                }
                self.right.print(output);
            });
            DEFPRINT(AST_Conditional, function(self, output) {
                self.condition.print(output);
                output.space();
                output.print("?");
                output.space();
                self.consequent.print(output);
                output.space();
                output.colon();
                self.alternative.print(output);
            });
            /* -----[ literals ]----- */
            DEFPRINT(AST_Array, function(self, output) {
                output.with_square(function() {
                    var a = self.elements, len = a.length;
                    if (len > 0) output.space();
                    a.forEach(function(exp, i) {
                        if (i) output.comma();
                        exp.print(output);
                        // If the final element is a hole, we need to make sure it
                        // doesn't look like a trailing comma, by inserting an actual
                        // trailing comma.
                        if (i === len - 1 && exp instanceof AST_Hole) output.comma();
                    });
                    if (len > 0) output.space();
                });
            });
            DEFPRINT(AST_Object, function(self, output) {
                if (self.properties.length > 0) output.with_block(function() {
                    self.properties.forEach(function(prop, i) {
                        if (i) {
                            output.print(",");
                            output.newline();
                        }
                        output.indent();
                        prop.print(output);
                    });
                    output.newline();
                }); else output.print("{}");
            });
            DEFPRINT(AST_ObjectKeyVal, function(self, output) {
                var key = self.key;
                if (output.option("quote_keys")) {
                    output.print_string(key + "");
                } else if ((typeof key == "number" || !output.option("beautify") && +key + "" == key) && parseFloat(key) >= 0) {
                    output.print(make_num(key));
                } else if (RESERVED_WORDS(key) ? output.option("screw_ie8") : is_identifier_string(key)) {
                    output.print_name(key);
                } else {
                    output.print_string(key);
                }
                output.colon();
                self.value.print(output);
            });
            DEFPRINT(AST_ObjectSetter, function(self, output) {
                output.print("set");
                output.space();
                self.key.print(output);
                self.value._do_print(output, true);
            });
            DEFPRINT(AST_ObjectGetter, function(self, output) {
                output.print("get");
                output.space();
                self.key.print(output);
                self.value._do_print(output, true);
            });
            DEFPRINT(AST_Symbol, function(self, output) {
                var def = self.definition();
                output.print_name(def ? def.mangled_name || def.name : self.name);
            });
            DEFPRINT(AST_Undefined, function(self, output) {
                output.print("void 0");
            });
            DEFPRINT(AST_Hole, noop);
            DEFPRINT(AST_Infinity, function(self, output) {
                output.print("1/0");
            });
            DEFPRINT(AST_NaN, function(self, output) {
                output.print("0/0");
            });
            DEFPRINT(AST_This, function(self, output) {
                output.print("this");
            });
            DEFPRINT(AST_Constant, function(self, output) {
                output.print(self.getValue());
            });
            DEFPRINT(AST_String, function(self, output) {
                output.print_string(self.getValue());
            });
            DEFPRINT(AST_Number, function(self, output) {
                output.print(make_num(self.getValue()));
            });
            function regexp_safe_literal(code) {
                return [ 92, // \
                47, // /
                46, // .
                43, // +
                42, // *
                63, // ?
                40, // (
                41, // )
                91, // [
                93, // ]
                123, // {
                125, // }
                36, // $
                94, // ^
                58, // :
                124, // |
                33, // !
                10, // \n
                13, // \r
                65279, // Unicode BOM
                8232, // unicode "line separator"
                8233 ].indexOf(code) < 0;
            }
            DEFPRINT(AST_RegExp, function(self, output) {
                var str = self.getValue().toString();
                if (output.option("ascii_only")) {
                    str = output.to_ascii(str);
                } else {
                    str = str.split("\\\\").map(function(str) {
                        return str.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, function(s) {
                            var code = parseInt(s.substr(2), 16);
                            return regexp_safe_literal(code) ? String.fromCharCode(code) : s;
                        });
                    }).join("\\\\");
                }
                output.print(str);
                var p = output.parent();
                if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self) output.print(" ");
            });
            function force_statement(stat, output) {
                if (output.option("bracketize")) {
                    if (!stat || stat instanceof AST_EmptyStatement) output.print("{}"); else if (stat instanceof AST_BlockStatement) stat.print(output); else output.with_block(function() {
                        output.indent();
                        stat.print(output);
                        output.newline();
                    });
                } else {
                    if (!stat || stat instanceof AST_EmptyStatement) output.force_semicolon(); else stat.print(output);
                }
            }
            // return true if the node at the top of the stack (that means the
            // innermost node in the current output) is lexically the first in
            // a statement.
            function first_in_statement(output) {
                var a = output.stack(), i = a.length, node = a[--i], p = a[--i];
                while (i > 0) {
                    if (p instanceof AST_Statement && p.body === node) return true;
                    if (p instanceof AST_Seq && p.car === node || p instanceof AST_Call && p.expression === node && !(p instanceof AST_New) || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {
                        node = p;
                        p = a[--i];
                    } else {
                        return false;
                    }
                }
            }
            // self should be AST_New.  decide if we want to show parens or not.
            function no_constructor_parens(self, output) {
                return self.args.length == 0 && !output.option("beautify");
            }
            function best_of(a) {
                var best = a[0], len = best.length;
                for (var i = 1; i < a.length; ++i) {
                    if (a[i].length < len) {
                        best = a[i];
                        len = best.length;
                    }
                }
                return best;
            }
            function make_num(num) {
                var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace("e+", "e") ], m;
                if (Math.floor(num) === num) {
                    if (num >= 0) {
                        a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
                        "0" + num.toString(8));
                    } else {
                        a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
                        "-0" + (-num).toString(8));
                    }
                    if (m = /^(.*?)(0+)$/.exec(num)) {
                        a.push(m[1] + "e" + m[2].length);
                    }
                } else if (m = /^0?\.(0+)(.*)$/.exec(num)) {
                    a.push(m[2] + "e-" + (m[1].length + m[2].length), str.substr(str.indexOf(".")));
                }
                return best_of(a);
            }
            function make_block(stmt, output) {
                if (stmt instanceof AST_BlockStatement) {
                    stmt.print(output);
                    return;
                }
                output.with_block(function() {
                    output.indent();
                    stmt.print(output);
                    output.newline();
                });
            }
            /* -----[ source map generators ]----- */
            function DEFMAP(nodetype, generator) {
                nodetype.DEFMETHOD("add_source_map", function(stream) {
                    generator(this, stream);
                });
            }
            // We could easily add info for ALL nodes, but it seems to me that
            // would be quite wasteful, hence this noop in the base class.
            DEFMAP(AST_Node, noop);
            function basic_sourcemap_gen(self, output) {
                output.add_mapping(self.start);
            }
            // XXX: I'm not exactly sure if we need it for all of these nodes,
            // or if we should add even more.
            DEFMAP(AST_Directive, basic_sourcemap_gen);
            DEFMAP(AST_Debugger, basic_sourcemap_gen);
            DEFMAP(AST_Symbol, basic_sourcemap_gen);
            DEFMAP(AST_Jump, basic_sourcemap_gen);
            DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);
            DEFMAP(AST_LabeledStatement, noop);
            // since the label symbol will mark it
            DEFMAP(AST_Lambda, basic_sourcemap_gen);
            DEFMAP(AST_Switch, basic_sourcemap_gen);
            DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);
            DEFMAP(AST_BlockStatement, basic_sourcemap_gen);
            DEFMAP(AST_Toplevel, noop);
            DEFMAP(AST_New, basic_sourcemap_gen);
            DEFMAP(AST_Try, basic_sourcemap_gen);
            DEFMAP(AST_Catch, basic_sourcemap_gen);
            DEFMAP(AST_Finally, basic_sourcemap_gen);
            DEFMAP(AST_Definitions, basic_sourcemap_gen);
            DEFMAP(AST_Constant, basic_sourcemap_gen);
            DEFMAP(AST_ObjectProperty, function(self, output) {
                output.add_mapping(self.start, self.key);
            });
        })();
        exports.OutputStream = OutputStream;
        /***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/
        "use strict";
        function Compressor(options, false_by_default) {
            if (!(this instanceof Compressor)) return new Compressor(options, false_by_default);
            TreeTransformer.call(this, this.before, this.after);
            this.options = defaults(options, {
                sequences: !false_by_default,
                properties: !false_by_default,
                dead_code: !false_by_default,
                drop_debugger: !false_by_default,
                unsafe: false,
                unsafe_comps: false,
                conditionals: !false_by_default,
                comparisons: !false_by_default,
                evaluate: !false_by_default,
                booleans: !false_by_default,
                loops: !false_by_default,
                unused: !false_by_default,
                hoist_funs: !false_by_default,
                hoist_vars: false,
                if_return: !false_by_default,
                join_vars: !false_by_default,
                cascade: !false_by_default,
                side_effects: !false_by_default,
                pure_getters: false,
                pure_funcs: null,
                negate_iife: !false_by_default,
                screw_ie8: false,
                drop_console: false,
                angular: false,
                warnings: true,
                global_defs: {}
            }, true);
        }
        Compressor.prototype = new TreeTransformer();
        merge(Compressor.prototype, {
            option: function(key) {
                return this.options[key];
            },
            warn: function() {
                if (this.options.warnings) AST_Node.warn.apply(AST_Node, arguments);
            },
            before: function(node, descend, in_list) {
                if (node._squeezed) return node;
                var was_scope = false;
                if (node instanceof AST_Scope) {
                    node = node.hoist_declarations(this);
                    was_scope = true;
                }
                descend(node, this);
                node = node.optimize(this);
                if (was_scope && node instanceof AST_Scope) {
                    node.drop_unused(this);
                    descend(node, this);
                }
                node._squeezed = true;
                return node;
            }
        });
        (function() {
            function OPT(node, optimizer) {
                node.DEFMETHOD("optimize", function(compressor) {
                    var self = this;
                    if (self._optimized) return self;
                    var opt = optimizer(self, compressor);
                    opt._optimized = true;
                    if (opt === self) return opt;
                    return opt.transform(compressor);
                });
            }
            OPT(AST_Node, function(self, compressor) {
                return self;
            });
            AST_Node.DEFMETHOD("equivalent_to", function(node) {
                // XXX: this is a rather expensive way to test two node's equivalence:
                return this.print_to_string() == node.print_to_string();
            });
            function make_node(ctor, orig, props) {
                if (!props) props = {};
                if (orig) {
                    if (!props.start) props.start = orig.start;
                    if (!props.end) props.end = orig.end;
                }
                return new ctor(props);
            }
            function make_node_from_constant(compressor, val, orig) {
                // XXX: WIP.
                // if (val instanceof AST_Node) return val.transform(new TreeTransformer(null, function(node){
                //     if (node instanceof AST_SymbolRef) {
                //         var scope = compressor.find_parent(AST_Scope);
                //         var def = scope.find_variable(node);
                //         node.thedef = def;
                //         return node;
                //     }
                // })).transform(compressor);
                if (val instanceof AST_Node) return val.transform(compressor);
                switch (typeof val) {
                  case "string":
                    return make_node(AST_String, orig, {
                        value: val
                    }).optimize(compressor);

                  case "number":
                    return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, {
                        value: val
                    }).optimize(compressor);

                  case "boolean":
                    return make_node(val ? AST_True : AST_False, orig).optimize(compressor);

                  case "undefined":
                    return make_node(AST_Undefined, orig).optimize(compressor);

                  default:
                    if (val === null) {
                        return make_node(AST_Null, orig).optimize(compressor);
                    }
                    if (val instanceof RegExp) {
                        return make_node(AST_RegExp, orig).optimize(compressor);
                    }
                    throw new Error(string_template("Can't handle constant of type: {type}", {
                        type: typeof val
                    }));
                }
            }
            function as_statement_array(thing) {
                if (thing === null) return [];
                if (thing instanceof AST_BlockStatement) return thing.body;
                if (thing instanceof AST_EmptyStatement) return [];
                if (thing instanceof AST_Statement) return [ thing ];
                throw new Error("Can't convert thing to statement array");
            }
            function is_empty(thing) {
                if (thing === null) return true;
                if (thing instanceof AST_EmptyStatement) return true;
                if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
                return false;
            }
            function loop_body(x) {
                if (x instanceof AST_Switch) return x;
                if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {
                    return x.body instanceof AST_BlockStatement ? x.body : x;
                }
                return x;
            }
            function tighten_body(statements, compressor) {
                var CHANGED;
                do {
                    CHANGED = false;
                    if (compressor.option("angular")) {
                        statements = process_for_angular(statements);
                    }
                    statements = eliminate_spurious_blocks(statements);
                    if (compressor.option("dead_code")) {
                        statements = eliminate_dead_code(statements, compressor);
                    }
                    if (compressor.option("if_return")) {
                        statements = handle_if_return(statements, compressor);
                    }
                    if (compressor.option("sequences")) {
                        statements = sequencesize(statements, compressor);
                    }
                    if (compressor.option("join_vars")) {
                        statements = join_consecutive_vars(statements, compressor);
                    }
                } while (CHANGED);
                if (compressor.option("negate_iife")) {
                    negate_iifes(statements, compressor);
                }
                return statements;
                function process_for_angular(statements) {
                    function make_injector(func, name) {
                        return make_node(AST_SimpleStatement, func, {
                            body: make_node(AST_Assign, func, {
                                operator: "=",
                                left: make_node(AST_Dot, name, {
                                    expression: make_node(AST_SymbolRef, name, name),
                                    property: "$inject"
                                }),
                                right: make_node(AST_Array, func, {
                                    elements: func.argnames.map(function(sym) {
                                        return make_node(AST_String, sym, {
                                            value: sym.name
                                        });
                                    })
                                })
                            })
                        });
                    }
                    return statements.reduce(function(a, stat) {
                        a.push(stat);
                        var token = stat.start;
                        var comments = token.comments_before;
                        if (comments && comments.length > 0) {
                            var last = comments.pop();
                            if (/@ngInject/.test(last.value)) {
                                // case 1: defun
                                if (stat instanceof AST_Defun) {
                                    a.push(make_injector(stat, stat.name));
                                } else if (stat instanceof AST_Definitions) {
                                    stat.definitions.forEach(function(def) {
                                        if (def.value && def.value instanceof AST_Lambda) {
                                            a.push(make_injector(def.value, def.name));
                                        }
                                    });
                                } else {
                                    compressor.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]", token);
                                }
                            }
                        }
                        return a;
                    }, []);
                }
                function eliminate_spurious_blocks(statements) {
                    var seen_dirs = [];
                    return statements.reduce(function(a, stat) {
                        if (stat instanceof AST_BlockStatement) {
                            CHANGED = true;
                            a.push.apply(a, eliminate_spurious_blocks(stat.body));
                        } else if (stat instanceof AST_EmptyStatement) {
                            CHANGED = true;
                        } else if (stat instanceof AST_Directive) {
                            if (seen_dirs.indexOf(stat.value) < 0) {
                                a.push(stat);
                                seen_dirs.push(stat.value);
                            } else {
                                CHANGED = true;
                            }
                        } else {
                            a.push(stat);
                        }
                        return a;
                    }, []);
                }
                function handle_if_return(statements, compressor) {
                    var self = compressor.self();
                    var in_lambda = self instanceof AST_Lambda;
                    var ret = [];
                    loop: for (var i = statements.length; --i >= 0; ) {
                        var stat = statements[i];
                        switch (true) {
                          case in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0:
                            CHANGED = true;
                            // note, ret.length is probably always zero
                            // because we drop unreachable code before this
                            // step.  nevertheless, it's good to check.
                            continue loop;

                          case stat instanceof AST_If:
                            if (stat.body instanceof AST_Return) {
                                //---
                                // pretty silly case, but:
                                // if (foo()) return; return; ==> foo(); return;
                                if ((in_lambda && ret.length == 0 || ret[0] instanceof AST_Return && !ret[0].value) && !stat.body.value && !stat.alternative) {
                                    CHANGED = true;
                                    var cond = make_node(AST_SimpleStatement, stat.condition, {
                                        body: stat.condition
                                    });
                                    ret.unshift(cond);
                                    continue loop;
                                }
                                //---
                                // if (foo()) return x; return y; ==> return foo() ? x : y;
                                if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.alternative = ret[0];
                                    ret[0] = stat.transform(compressor);
                                    continue loop;
                                }
                                //---
                                // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;
                                if ((ret.length == 0 || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.alternative = ret[0] || make_node(AST_Return, stat, {
                                        value: make_node(AST_Undefined, stat)
                                    });
                                    ret[0] = stat.transform(compressor);
                                    continue loop;
                                }
                                //---
                                // if (foo()) return; [ else x... ]; y... ==> if (!foo()) { x...; y... }
                                if (!stat.body.value && in_lambda) {
                                    CHANGED = true;
                                    stat = stat.clone();
                                    stat.condition = stat.condition.negate(compressor);
                                    stat.body = make_node(AST_BlockStatement, stat, {
                                        body: as_statement_array(stat.alternative).concat(ret)
                                    });
                                    stat.alternative = null;
                                    ret = [ stat.transform(compressor) ];
                                    continue loop;
                                }
                                //---
                                if (ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {
                                    CHANGED = true;
                                    ret.push(make_node(AST_Return, ret[0], {
                                        value: make_node(AST_Undefined, ret[0])
                                    }).transform(compressor));
                                    ret = as_statement_array(stat.alternative).concat(ret);
                                    ret.unshift(stat);
                                    continue loop;
                                }
                            }
                            var ab = aborts(stat.body);
                            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                            if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {
                                if (ab.label) {
                                    remove(ab.label.thedef.references, ab);
                                }
                                CHANGED = true;
                                var body = as_statement_array(stat.body).slice(0, -1);
                                stat = stat.clone();
                                stat.condition = stat.condition.negate(compressor);
                                stat.body = make_node(AST_BlockStatement, stat, {
                                    body: ret
                                });
                                stat.alternative = make_node(AST_BlockStatement, stat, {
                                    body: body
                                });
                                ret = [ stat.transform(compressor) ];
                                continue loop;
                            }
                            var ab = aborts(stat.alternative);
                            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;
                            if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {
                                if (ab.label) {
                                    remove(ab.label.thedef.references, ab);
                                }
                                CHANGED = true;
                                stat = stat.clone();
                                stat.body = make_node(AST_BlockStatement, stat.body, {
                                    body: as_statement_array(stat.body).concat(ret)
                                });
                                stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                                    body: as_statement_array(stat.alternative).slice(0, -1)
                                });
                                ret = [ stat.transform(compressor) ];
                                continue loop;
                            }
                            ret.unshift(stat);
                            break;

                          default:
                            ret.unshift(stat);
                            break;
                        }
                    }
                    return ret;
                }
                function eliminate_dead_code(statements, compressor) {
                    var has_quit = false;
                    var orig = statements.length;
                    var self = compressor.self();
                    statements = statements.reduce(function(a, stat) {
                        if (has_quit) {
                            extract_declarations_from_unreachable_code(compressor, stat, a);
                        } else {
                            if (stat instanceof AST_LoopControl) {
                                var lct = compressor.loopcontrol_target(stat.label);
                                if (stat instanceof AST_Break && lct instanceof AST_BlockStatement && loop_body(lct) === self || stat instanceof AST_Continue && loop_body(lct) === self) {
                                    if (stat.label) {
                                        remove(stat.label.thedef.references, stat);
                                    }
                                } else {
                                    a.push(stat);
                                }
                            } else {
                                a.push(stat);
                            }
                            if (aborts(stat)) has_quit = true;
                        }
                        return a;
                    }, []);
                    CHANGED = statements.length != orig;
                    return statements;
                }
                function sequencesize(statements, compressor) {
                    if (statements.length < 2) return statements;
                    var seq = [], ret = [];
                    function push_seq() {
                        seq = AST_Seq.from_array(seq);
                        if (seq) ret.push(make_node(AST_SimpleStatement, seq, {
                            body: seq
                        }));
                        seq = [];
                    }
                    statements.forEach(function(stat) {
                        if (stat instanceof AST_SimpleStatement) seq.push(stat.body); else push_seq(), ret.push(stat);
                    });
                    push_seq();
                    ret = sequencesize_2(ret, compressor);
                    CHANGED = ret.length != statements.length;
                    return ret;
                }
                function sequencesize_2(statements, compressor) {
                    function cons_seq(right) {
                        ret.pop();
                        var left = prev.body;
                        if (left instanceof AST_Seq) {
                            left.add(right);
                        } else {
                            left = AST_Seq.cons(left, right);
                        }
                        return left.transform(compressor);
                    }
                    var ret = [], prev = null;
                    statements.forEach(function(stat) {
                        if (prev) {
                            if (stat instanceof AST_For) {
                                var opera = {};
                                try {
                                    prev.body.walk(new TreeWalker(function(node) {
                                        if (node instanceof AST_Binary && node.operator == "in") throw opera;
                                    }));
                                    if (stat.init && !(stat.init instanceof AST_Definitions)) {
                                        stat.init = cons_seq(stat.init);
                                    } else if (!stat.init) {
                                        stat.init = prev.body;
                                        ret.pop();
                                    }
                                } catch (ex) {
                                    if (ex !== opera) throw ex;
                                }
                            } else if (stat instanceof AST_If) {
                                stat.condition = cons_seq(stat.condition);
                            } else if (stat instanceof AST_With) {
                                stat.expression = cons_seq(stat.expression);
                            } else if (stat instanceof AST_Exit && stat.value) {
                                stat.value = cons_seq(stat.value);
                            } else if (stat instanceof AST_Exit) {
                                stat.value = cons_seq(make_node(AST_Undefined, stat));
                            } else if (stat instanceof AST_Switch) {
                                stat.expression = cons_seq(stat.expression);
                            }
                        }
                        ret.push(stat);
                        prev = stat instanceof AST_SimpleStatement ? stat : null;
                    });
                    return ret;
                }
                function join_consecutive_vars(statements, compressor) {
                    var prev = null;
                    return statements.reduce(function(a, stat) {
                        if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {
                            prev.definitions = prev.definitions.concat(stat.definitions);
                            CHANGED = true;
                        } else if (stat instanceof AST_For && prev instanceof AST_Definitions && (!stat.init || stat.init.TYPE == prev.TYPE)) {
                            CHANGED = true;
                            a.pop();
                            if (stat.init) {
                                stat.init.definitions = prev.definitions.concat(stat.init.definitions);
                            } else {
                                stat.init = prev;
                            }
                            a.push(stat);
                            prev = stat;
                        } else {
                            prev = stat;
                            a.push(stat);
                        }
                        return a;
                    }, []);
                }
                function negate_iifes(statements, compressor) {
                    statements.forEach(function(stat) {
                        if (stat instanceof AST_SimpleStatement) {
                            stat.body = function transform(thing) {
                                return thing.transform(new TreeTransformer(function(node) {
                                    if (node instanceof AST_Call && node.expression instanceof AST_Function) {
                                        return make_node(AST_UnaryPrefix, node, {
                                            operator: "!",
                                            expression: node
                                        });
                                    } else if (node instanceof AST_Call) {
                                        node.expression = transform(node.expression);
                                    } else if (node instanceof AST_Seq) {
                                        node.car = transform(node.car);
                                    } else if (node instanceof AST_Conditional) {
                                        var expr = transform(node.condition);
                                        if (expr !== node.condition) {
                                            // it has been negated, reverse
                                            node.condition = expr;
                                            var tmp = node.consequent;
                                            node.consequent = node.alternative;
                                            node.alternative = tmp;
                                        }
                                    }
                                    return node;
                                }));
                            }(stat.body);
                        }
                    });
                }
            }
            function extract_declarations_from_unreachable_code(compressor, stat, target) {
                compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
                stat.walk(new TreeWalker(function(node) {
                    if (node instanceof AST_Definitions) {
                        compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
                        node.remove_initializers();
                        target.push(node);
                        return true;
                    }
                    if (node instanceof AST_Defun) {
                        target.push(node);
                        return true;
                    }
                    if (node instanceof AST_Scope) {
                        return true;
                    }
                }));
            }
            /* -----[ boolean/negation helpers ]----- */
            // methods to determine whether an expression has a boolean result type
            (function(def) {
                var unary_bool = [ "!", "delete" ];
                var binary_bool = [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ];
                def(AST_Node, function() {
                    return false;
                });
                def(AST_UnaryPrefix, function() {
                    return member(this.operator, unary_bool);
                });
                def(AST_Binary, function() {
                    return member(this.operator, binary_bool) || (this.operator == "&&" || this.operator == "||") && this.left.is_boolean() && this.right.is_boolean();
                });
                def(AST_Conditional, function() {
                    return this.consequent.is_boolean() && this.alternative.is_boolean();
                });
                def(AST_Assign, function() {
                    return this.operator == "=" && this.right.is_boolean();
                });
                def(AST_Seq, function() {
                    return this.cdr.is_boolean();
                });
                def(AST_True, function() {
                    return true;
                });
                def(AST_False, function() {
                    return true;
                });
            })(function(node, func) {
                node.DEFMETHOD("is_boolean", func);
            });
            // methods to determine if an expression has a string result type
            (function(def) {
                def(AST_Node, function() {
                    return false;
                });
                def(AST_String, function() {
                    return true;
                });
                def(AST_UnaryPrefix, function() {
                    return this.operator == "typeof";
                });
                def(AST_Binary, function(compressor) {
                    return this.operator == "+" && (this.left.is_string(compressor) || this.right.is_string(compressor));
                });
                def(AST_Assign, function(compressor) {
                    return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
                });
                def(AST_Seq, function(compressor) {
                    return this.cdr.is_string(compressor);
                });
                def(AST_Conditional, function(compressor) {
                    return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
                });
                def(AST_Call, function(compressor) {
                    return compressor.option("unsafe") && this.expression instanceof AST_SymbolRef && this.expression.name == "String" && this.expression.undeclared();
                });
            })(function(node, func) {
                node.DEFMETHOD("is_string", func);
            });
            function best_of(ast1, ast2) {
                return ast1.print_to_string().length > ast2.print_to_string().length ? ast2 : ast1;
            }
            // methods to evaluate a constant expression
            (function(def) {
                // The evaluate method returns an array with one or two
                // elements.  If the node has been successfully reduced to a
                // constant, then the second element tells us the value;
                // otherwise the second element is missing.  The first element
                // of the array is always an AST_Node descendant; if
                // evaluation was successful it's a node that represents the
                // constant; otherwise it's the original or a replacement node.
                AST_Node.DEFMETHOD("evaluate", function(compressor) {
                    if (!compressor.option("evaluate")) return [ this ];
                    try {
                        var val = this._eval(compressor);
                        return [ best_of(make_node_from_constant(compressor, val, this), this), val ];
                    } catch (ex) {
                        if (ex !== def) throw ex;
                        return [ this ];
                    }
                });
                def(AST_Statement, function() {
                    throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
                });
                def(AST_Function, function() {
                    // XXX: AST_Function inherits from AST_Scope, which itself
                    // inherits from AST_Statement; however, an AST_Function
                    // isn't really a statement.  This could byte in other
                    // places too. :-( Wish JS had multiple inheritance.
                    throw def;
                });
                function ev(node, compressor) {
                    if (!compressor) throw new Error("Compressor must be passed");
                    return node._eval(compressor);
                }
                def(AST_Node, function() {
                    throw def;
                });
                def(AST_Constant, function() {
                    return this.getValue();
                });
                def(AST_UnaryPrefix, function(compressor) {
                    var e = this.expression;
                    switch (this.operator) {
                      case "!":
                        return !ev(e, compressor);

                      case "typeof":
                        // Function would be evaluated to an array and so typeof would
                        // incorrectly return 'object'. Hence making is a special case.
                        if (e instanceof AST_Function) return typeof function() {};
                        e = ev(e, compressor);
                        // typeof <RegExp> returns "object" or "function" on different platforms
                        // so cannot evaluate reliably
                        if (e instanceof RegExp) throw def;
                        return typeof e;

                      case "void":
                        return void ev(e, compressor);

                      case "~":
                        return ~ev(e, compressor);

                      case "-":
                        e = ev(e, compressor);
                        if (e === 0) throw def;
                        return -e;

                      case "+":
                        return +ev(e, compressor);
                    }
                    throw def;
                });
                def(AST_Binary, function(c) {
                    var left = this.left, right = this.right;
                    switch (this.operator) {
                      case "&&":
                        return ev(left, c) && ev(right, c);

                      case "||":
                        return ev(left, c) || ev(right, c);

                      case "|":
                        return ev(left, c) | ev(right, c);

                      case "&":
                        return ev(left, c) & ev(right, c);

                      case "^":
                        return ev(left, c) ^ ev(right, c);

                      case "+":
                        return ev(left, c) + ev(right, c);

                      case "*":
                        return ev(left, c) * ev(right, c);

                      case "/":
                        return ev(left, c) / ev(right, c);

                      case "%":
                        return ev(left, c) % ev(right, c);

                      case "-":
                        return ev(left, c) - ev(right, c);

                      case "<<":
                        return ev(left, c) << ev(right, c);

                      case ">>":
                        return ev(left, c) >> ev(right, c);

                      case ">>>":
                        return ev(left, c) >>> ev(right, c);

                      case "==":
                        return ev(left, c) == ev(right, c);

                      case "===":
                        return ev(left, c) === ev(right, c);

                      case "!=":
                        return ev(left, c) != ev(right, c);

                      case "!==":
                        return ev(left, c) !== ev(right, c);

                      case "<":
                        return ev(left, c) < ev(right, c);

                      case "<=":
                        return ev(left, c) <= ev(right, c);

                      case ">":
                        return ev(left, c) > ev(right, c);

                      case ">=":
                        return ev(left, c) >= ev(right, c);

                      case "in":
                        return ev(left, c) in ev(right, c);

                      case "instanceof":
                        return ev(left, c) instanceof ev(right, c);
                    }
                    throw def;
                });
                def(AST_Conditional, function(compressor) {
                    return ev(this.condition, compressor) ? ev(this.consequent, compressor) : ev(this.alternative, compressor);
                });
                def(AST_SymbolRef, function(compressor) {
                    var d = this.definition();
                    if (d && d.constant && d.init) return ev(d.init, compressor);
                    throw def;
                });
            })(function(node, func) {
                node.DEFMETHOD("_eval", func);
            });
            // method to negate an expression
            (function(def) {
                function basic_negation(exp) {
                    return make_node(AST_UnaryPrefix, exp, {
                        operator: "!",
                        expression: exp
                    });
                }
                def(AST_Node, function() {
                    return basic_negation(this);
                });
                def(AST_Statement, function() {
                    throw new Error("Cannot negate a statement");
                });
                def(AST_Function, function() {
                    return basic_negation(this);
                });
                def(AST_UnaryPrefix, function() {
                    if (this.operator == "!") return this.expression;
                    return basic_negation(this);
                });
                def(AST_Seq, function(compressor) {
                    var self = this.clone();
                    self.cdr = self.cdr.negate(compressor);
                    return self;
                });
                def(AST_Conditional, function(compressor) {
                    var self = this.clone();
                    self.consequent = self.consequent.negate(compressor);
                    self.alternative = self.alternative.negate(compressor);
                    return best_of(basic_negation(this), self);
                });
                def(AST_Binary, function(compressor) {
                    var self = this.clone(), op = this.operator;
                    if (compressor.option("unsafe_comps")) {
                        switch (op) {
                          case "<=":
                            self.operator = ">";
                            return self;

                          case "<":
                            self.operator = ">=";
                            return self;

                          case ">=":
                            self.operator = "<";
                            return self;

                          case ">":
                            self.operator = "<=";
                            return self;
                        }
                    }
                    switch (op) {
                      case "==":
                        self.operator = "!=";
                        return self;

                      case "!=":
                        self.operator = "==";
                        return self;

                      case "===":
                        self.operator = "!==";
                        return self;

                      case "!==":
                        self.operator = "===";
                        return self;

                      case "&&":
                        self.operator = "||";
                        self.left = self.left.negate(compressor);
                        self.right = self.right.negate(compressor);
                        return best_of(basic_negation(this), self);

                      case "||":
                        self.operator = "&&";
                        self.left = self.left.negate(compressor);
                        self.right = self.right.negate(compressor);
                        return best_of(basic_negation(this), self);
                    }
                    return basic_negation(this);
                });
            })(function(node, func) {
                node.DEFMETHOD("negate", function(compressor) {
                    return func.call(this, compressor);
                });
            });
            // determine if expression has side effects
            (function(def) {
                def(AST_Node, function(compressor) {
                    return true;
                });
                def(AST_EmptyStatement, function(compressor) {
                    return false;
                });
                def(AST_Constant, function(compressor) {
                    return false;
                });
                def(AST_This, function(compressor) {
                    return false;
                });
                def(AST_Call, function(compressor) {
                    var pure = compressor.option("pure_funcs");
                    if (!pure) return true;
                    return pure.indexOf(this.expression.print_to_string()) < 0;
                });
                def(AST_Block, function(compressor) {
                    for (var i = this.body.length; --i >= 0; ) {
                        if (this.body[i].has_side_effects(compressor)) return true;
                    }
                    return false;
                });
                def(AST_SimpleStatement, function(compressor) {
                    return this.body.has_side_effects(compressor);
                });
                def(AST_Defun, function(compressor) {
                    return true;
                });
                def(AST_Function, function(compressor) {
                    return false;
                });
                def(AST_Binary, function(compressor) {
                    return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor);
                });
                def(AST_Assign, function(compressor) {
                    return true;
                });
                def(AST_Conditional, function(compressor) {
                    return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);
                });
                def(AST_Unary, function(compressor) {
                    return this.operator == "delete" || this.operator == "++" || this.operator == "--" || this.expression.has_side_effects(compressor);
                });
                def(AST_SymbolRef, function(compressor) {
                    return false;
                });
                def(AST_Object, function(compressor) {
                    for (var i = this.properties.length; --i >= 0; ) if (this.properties[i].has_side_effects(compressor)) return true;
                    return false;
                });
                def(AST_ObjectProperty, function(compressor) {
                    return this.value.has_side_effects(compressor);
                });
                def(AST_Array, function(compressor) {
                    for (var i = this.elements.length; --i >= 0; ) if (this.elements[i].has_side_effects(compressor)) return true;
                    return false;
                });
                def(AST_Dot, function(compressor) {
                    if (!compressor.option("pure_getters")) return true;
                    return this.expression.has_side_effects(compressor);
                });
                def(AST_Sub, function(compressor) {
                    if (!compressor.option("pure_getters")) return true;
                    return this.expression.has_side_effects(compressor) || this.property.has_side_effects(compressor);
                });
                def(AST_PropAccess, function(compressor) {
                    return !compressor.option("pure_getters");
                });
                def(AST_Seq, function(compressor) {
                    return this.car.has_side_effects(compressor) || this.cdr.has_side_effects(compressor);
                });
            })(function(node, func) {
                node.DEFMETHOD("has_side_effects", func);
            });
            // tell me if a statement aborts
            function aborts(thing) {
                return thing && thing.aborts();
            }
            (function(def) {
                def(AST_Statement, function() {
                    return null;
                });
                def(AST_Jump, function() {
                    return this;
                });
                function block_aborts() {
                    var n = this.body.length;
                    return n > 0 && aborts(this.body[n - 1]);
                }
                def(AST_BlockStatement, block_aborts);
                def(AST_SwitchBranch, block_aborts);
                def(AST_If, function() {
                    return this.alternative && aborts(this.body) && aborts(this.alternative);
                });
            })(function(node, func) {
                node.DEFMETHOD("aborts", func);
            });
            /* -----[ optimizers ]----- */
            OPT(AST_Directive, function(self, compressor) {
                if (self.scope.has_directive(self.value) !== self.scope) {
                    return make_node(AST_EmptyStatement, self);
                }
                return self;
            });
            OPT(AST_Debugger, function(self, compressor) {
                if (compressor.option("drop_debugger")) return make_node(AST_EmptyStatement, self);
                return self;
            });
            OPT(AST_LabeledStatement, function(self, compressor) {
                if (self.body instanceof AST_Break && compressor.loopcontrol_target(self.body.label) === self.body) {
                    return make_node(AST_EmptyStatement, self);
                }
                return self.label.references.length == 0 ? self.body : self;
            });
            OPT(AST_Block, function(self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });
            OPT(AST_BlockStatement, function(self, compressor) {
                self.body = tighten_body(self.body, compressor);
                switch (self.body.length) {
                  case 1:
                    return self.body[0];

                  case 0:
                    return make_node(AST_EmptyStatement, self);
                }
                return self;
            });
            AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
                var self = this;
                if (compressor.option("unused") && !(self instanceof AST_Toplevel) && !self.uses_eval) {
                    var in_use = [];
                    var initializations = new Dictionary();
                    // pass 1: find out which symbols are directly used in
                    // this scope (not in nested scopes).
                    var scope = this;
                    var tw = new TreeWalker(function(node, descend) {
                        if (node !== self) {
                            if (node instanceof AST_Defun) {
                                initializations.add(node.name.name, node);
                                return true;
                            }
                            if (node instanceof AST_Definitions && scope === self) {
                                node.definitions.forEach(function(def) {
                                    if (def.value) {
                                        initializations.add(def.name.name, def.value);
                                        if (def.value.has_side_effects(compressor)) {
                                            def.value.walk(tw);
                                        }
                                    }
                                });
                                return true;
                            }
                            if (node instanceof AST_SymbolRef) {
                                push_uniq(in_use, node.definition());
                                return true;
                            }
                            if (node instanceof AST_Scope) {
                                var save_scope = scope;
                                scope = node;
                                descend();
                                scope = save_scope;
                                return true;
                            }
                        }
                    });
                    self.walk(tw);
                    // pass 2: for every used symbol we need to walk its
                    // initialization code to figure out if it uses other
                    // symbols (that may not be in_use).
                    for (var i = 0; i < in_use.length; ++i) {
                        in_use[i].orig.forEach(function(decl) {
                            // undeclared globals will be instanceof AST_SymbolRef
                            var init = initializations.get(decl.name);
                            if (init) init.forEach(function(init) {
                                var tw = new TreeWalker(function(node) {
                                    if (node instanceof AST_SymbolRef) {
                                        push_uniq(in_use, node.definition());
                                    }
                                });
                                init.walk(tw);
                            });
                        });
                    }
                    // pass 3: we should drop declarations not in_use
                    var tt = new TreeTransformer(function before(node, descend, in_list) {
                        if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
                            for (var a = node.argnames, i = a.length; --i >= 0; ) {
                                var sym = a[i];
                                if (sym.unreferenced()) {
                                    a.pop();
                                    compressor.warn("Dropping unused function argument {name} [{file}:{line},{col}]", {
                                        name: sym.name,
                                        file: sym.start.file,
                                        line: sym.start.line,
                                        col: sym.start.col
                                    });
                                } else break;
                            }
                        }
                        if (node instanceof AST_Defun && node !== self) {
                            if (!member(node.name.definition(), in_use)) {
                                compressor.warn("Dropping unused function {name} [{file}:{line},{col}]", {
                                    name: node.name.name,
                                    file: node.name.start.file,
                                    line: node.name.start.line,
                                    col: node.name.start.col
                                });
                                return make_node(AST_EmptyStatement, node);
                            }
                            return node;
                        }
                        if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {
                            var def = node.definitions.filter(function(def) {
                                if (member(def.name.definition(), in_use)) return true;
                                var w = {
                                    name: def.name.name,
                                    file: def.name.start.file,
                                    line: def.name.start.line,
                                    col: def.name.start.col
                                };
                                if (def.value && def.value.has_side_effects(compressor)) {
                                    def._unused_side_effects = true;
                                    compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
                                    return true;
                                }
                                compressor.warn("Dropping unused variable {name} [{file}:{line},{col}]", w);
                                return false;
                            });
                            // place uninitialized names at the start
                            def = mergeSort(def, function(a, b) {
                                if (!a.value && b.value) return -1;
                                if (!b.value && a.value) return 1;
                                return 0;
                            });
                            // for unused names whose initialization has
                            // side effects, we can cascade the init. code
                            // into the next one, or next statement.
                            var side_effects = [];
                            for (var i = 0; i < def.length; ) {
                                var x = def[i];
                                if (x._unused_side_effects) {
                                    side_effects.push(x.value);
                                    def.splice(i, 1);
                                } else {
                                    if (side_effects.length > 0) {
                                        side_effects.push(x.value);
                                        x.value = AST_Seq.from_array(side_effects);
                                        side_effects = [];
                                    }
                                    ++i;
                                }
                            }
                            if (side_effects.length > 0) {
                                side_effects = make_node(AST_BlockStatement, node, {
                                    body: [ make_node(AST_SimpleStatement, node, {
                                        body: AST_Seq.from_array(side_effects)
                                    }) ]
                                });
                            } else {
                                side_effects = null;
                            }
                            if (def.length == 0 && !side_effects) {
                                return make_node(AST_EmptyStatement, node);
                            }
                            if (def.length == 0) {
                                return side_effects;
                            }
                            node.definitions = def;
                            if (side_effects) {
                                side_effects.body.unshift(node);
                                node = side_effects;
                            }
                            return node;
                        }
                        if (node instanceof AST_For) {
                            descend(node, this);
                            if (node.init instanceof AST_BlockStatement) {
                                // certain combination of unused name + side effect leads to:
                                //    https://github.com/mishoo/UglifyJS2/issues/44
                                // that's an invalid AST.
                                // We fix it at this stage by moving the `var` outside the `for`.
                                var body = node.init.body.slice(0, -1);
                                node.init = node.init.body.slice(-1)[0].body;
                                body.push(node);
                                return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {
                                    body: body
                                });
                            }
                        }
                        if (node instanceof AST_Scope && node !== self) return node;
                    });
                    self.transform(tt);
                }
            });
            AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
                var hoist_funs = compressor.option("hoist_funs");
                var hoist_vars = compressor.option("hoist_vars");
                var self = this;
                if (hoist_funs || hoist_vars) {
                    var dirs = [];
                    var hoisted = [];
                    var vars = new Dictionary(), vars_found = 0, var_decl = 0;
                    // let's count var_decl first, we seem to waste a lot of
                    // space if we hoist `var` when there's only one.
                    self.walk(new TreeWalker(function(node) {
                        if (node instanceof AST_Scope && node !== self) return true;
                        if (node instanceof AST_Var) {
                            ++var_decl;
                            return true;
                        }
                    }));
                    hoist_vars = hoist_vars && var_decl > 1;
                    var tt = new TreeTransformer(function before(node) {
                        if (node !== self) {
                            if (node instanceof AST_Directive) {
                                dirs.push(node);
                                return make_node(AST_EmptyStatement, node);
                            }
                            if (node instanceof AST_Defun && hoist_funs) {
                                hoisted.push(node);
                                return make_node(AST_EmptyStatement, node);
                            }
                            if (node instanceof AST_Var && hoist_vars) {
                                node.definitions.forEach(function(def) {
                                    vars.set(def.name.name, def);
                                    ++vars_found;
                                });
                                var seq = node.to_assignments();
                                var p = tt.parent();
                                if (p instanceof AST_ForIn && p.init === node) {
                                    if (seq == null) return node.definitions[0].name;
                                    return seq;
                                }
                                if (p instanceof AST_For && p.init === node) {
                                    return seq;
                                }
                                if (!seq) return make_node(AST_EmptyStatement, node);
                                return make_node(AST_SimpleStatement, node, {
                                    body: seq
                                });
                            }
                            if (node instanceof AST_Scope) return node;
                        }
                    });
                    self = self.transform(tt);
                    if (vars_found > 0) {
                        // collect only vars which don't show up in self's arguments list
                        var defs = [];
                        vars.each(function(def, name) {
                            if (self instanceof AST_Lambda && find_if(function(x) {
                                return x.name == def.name.name;
                            }, self.argnames)) {
                                vars.del(name);
                            } else {
                                def = def.clone();
                                def.value = null;
                                defs.push(def);
                                vars.set(name, def);
                            }
                        });
                        if (defs.length > 0) {
                            // try to merge in assignments
                            for (var i = 0; i < self.body.length; ) {
                                if (self.body[i] instanceof AST_SimpleStatement) {
                                    var expr = self.body[i].body, sym, assign;
                                    if (expr instanceof AST_Assign && expr.operator == "=" && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {
                                        var def = vars.get(sym.name);
                                        if (def.value) break;
                                        def.value = expr.right;
                                        remove(defs, def);
                                        defs.push(def);
                                        self.body.splice(i, 1);
                                        continue;
                                    }
                                    if (expr instanceof AST_Seq && (assign = expr.car) instanceof AST_Assign && assign.operator == "=" && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {
                                        var def = vars.get(sym.name);
                                        if (def.value) break;
                                        def.value = assign.right;
                                        remove(defs, def);
                                        defs.push(def);
                                        self.body[i].body = expr.cdr;
                                        continue;
                                    }
                                }
                                if (self.body[i] instanceof AST_EmptyStatement) {
                                    self.body.splice(i, 1);
                                    continue;
                                }
                                if (self.body[i] instanceof AST_BlockStatement) {
                                    var tmp = [ i, 1 ].concat(self.body[i].body);
                                    self.body.splice.apply(self.body, tmp);
                                    continue;
                                }
                                break;
                            }
                            defs = make_node(AST_Var, self, {
                                definitions: defs
                            });
                            hoisted.push(defs);
                        }
                    }
                    self.body = dirs.concat(hoisted, self.body);
                }
                return self;
            });
            OPT(AST_SimpleStatement, function(self, compressor) {
                if (compressor.option("side_effects")) {
                    if (!self.body.has_side_effects(compressor)) {
                        compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
                        return make_node(AST_EmptyStatement, self);
                    }
                }
                return self;
            });
            OPT(AST_DWLoop, function(self, compressor) {
                var cond = self.condition.evaluate(compressor);
                self.condition = cond[0];
                if (!compressor.option("loops")) return self;
                if (cond.length > 1) {
                    if (cond[1]) {
                        return make_node(AST_For, self, {
                            body: self.body
                        });
                    } else if (self instanceof AST_While) {
                        if (compressor.option("dead_code")) {
                            var a = [];
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            return make_node(AST_BlockStatement, self, {
                                body: a
                            });
                        }
                    }
                }
                return self;
            });
            function if_break_in_loop(self, compressor) {
                function drop_it(rest) {
                    rest = as_statement_array(rest);
                    if (self.body instanceof AST_BlockStatement) {
                        self.body = self.body.clone();
                        self.body.body = rest.concat(self.body.body.slice(1));
                        self.body = self.body.transform(compressor);
                    } else {
                        self.body = make_node(AST_BlockStatement, self.body, {
                            body: rest
                        }).transform(compressor);
                    }
                    if_break_in_loop(self, compressor);
                }
                var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
                if (first instanceof AST_If) {
                    if (first.body instanceof AST_Break && compressor.loopcontrol_target(first.body.label) === self) {
                        if (self.condition) {
                            self.condition = make_node(AST_Binary, self.condition, {
                                left: self.condition,
                                operator: "&&",
                                right: first.condition.negate(compressor)
                            });
                        } else {
                            self.condition = first.condition.negate(compressor);
                        }
                        drop_it(first.alternative);
                    } else if (first.alternative instanceof AST_Break && compressor.loopcontrol_target(first.alternative.label) === self) {
                        if (self.condition) {
                            self.condition = make_node(AST_Binary, self.condition, {
                                left: self.condition,
                                operator: "&&",
                                right: first.condition
                            });
                        } else {
                            self.condition = first.condition;
                        }
                        drop_it(first.body);
                    }
                }
            }
            OPT(AST_While, function(self, compressor) {
                if (!compressor.option("loops")) return self;
                self = AST_DWLoop.prototype.optimize.call(self, compressor);
                if (self instanceof AST_While) {
                    if_break_in_loop(self, compressor);
                    self = make_node(AST_For, self, self).transform(compressor);
                }
                return self;
            });
            OPT(AST_For, function(self, compressor) {
                var cond = self.condition;
                if (cond) {
                    cond = cond.evaluate(compressor);
                    self.condition = cond[0];
                }
                if (!compressor.option("loops")) return self;
                if (cond) {
                    if (cond.length > 1 && !cond[1]) {
                        if (compressor.option("dead_code")) {
                            var a = [];
                            if (self.init instanceof AST_Statement) {
                                a.push(self.init);
                            } else if (self.init) {
                                a.push(make_node(AST_SimpleStatement, self.init, {
                                    body: self.init
                                }));
                            }
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            return make_node(AST_BlockStatement, self, {
                                body: a
                            });
                        }
                    }
                }
                if_break_in_loop(self, compressor);
                return self;
            });
            OPT(AST_If, function(self, compressor) {
                if (!compressor.option("conditionals")) return self;
                // if condition can be statically determined, warn and drop
                // one of the blocks.  note, statically determined implies
                // has no side effects; also it doesn't work for cases like
                // `x && true`, though it probably should.
                var cond = self.condition.evaluate(compressor);
                self.condition = cond[0];
                if (cond.length > 1) {
                    if (cond[1]) {
                        compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
                        if (compressor.option("dead_code")) {
                            var a = [];
                            if (self.alternative) {
                                extract_declarations_from_unreachable_code(compressor, self.alternative, a);
                            }
                            a.push(self.body);
                            return make_node(AST_BlockStatement, self, {
                                body: a
                            }).transform(compressor);
                        }
                    } else {
                        compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
                        if (compressor.option("dead_code")) {
                            var a = [];
                            extract_declarations_from_unreachable_code(compressor, self.body, a);
                            if (self.alternative) a.push(self.alternative);
                            return make_node(AST_BlockStatement, self, {
                                body: a
                            }).transform(compressor);
                        }
                    }
                }
                if (is_empty(self.alternative)) self.alternative = null;
                var negated = self.condition.negate(compressor);
                var negated_is_best = best_of(self.condition, negated) === negated;
                if (self.alternative && negated_is_best) {
                    negated_is_best = false;
                    // because we already do the switch here.
                    self.condition = negated;
                    var tmp = self.body;
                    self.body = self.alternative || make_node(AST_EmptyStatement);
                    self.alternative = tmp;
                }
                if (is_empty(self.body) && is_empty(self.alternative)) {
                    return make_node(AST_SimpleStatement, self.condition, {
                        body: self.condition
                    }).transform(compressor);
                }
                if (self.body instanceof AST_SimpleStatement && self.alternative instanceof AST_SimpleStatement) {
                    return make_node(AST_SimpleStatement, self, {
                        body: make_node(AST_Conditional, self, {
                            condition: self.condition,
                            consequent: self.body.body,
                            alternative: self.alternative.body
                        })
                    }).transform(compressor);
                }
                if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
                    if (negated_is_best) return make_node(AST_SimpleStatement, self, {
                        body: make_node(AST_Binary, self, {
                            operator: "||",
                            left: negated,
                            right: self.body.body
                        })
                    }).transform(compressor);
                    return make_node(AST_SimpleStatement, self, {
                        body: make_node(AST_Binary, self, {
                            operator: "&&",
                            left: self.condition,
                            right: self.body.body
                        })
                    }).transform(compressor);
                }
                if (self.body instanceof AST_EmptyStatement && self.alternative && self.alternative instanceof AST_SimpleStatement) {
                    return make_node(AST_SimpleStatement, self, {
                        body: make_node(AST_Binary, self, {
                            operator: "||",
                            left: self.condition,
                            right: self.alternative.body
                        })
                    }).transform(compressor);
                }
                if (self.body instanceof AST_Exit && self.alternative instanceof AST_Exit && self.body.TYPE == self.alternative.TYPE) {
                    return make_node(self.body.CTOR, self, {
                        value: make_node(AST_Conditional, self, {
                            condition: self.condition,
                            consequent: self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),
                            alternative: self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)
                        })
                    }).transform(compressor);
                }
                if (self.body instanceof AST_If && !self.body.alternative && !self.alternative) {
                    self.condition = make_node(AST_Binary, self.condition, {
                        operator: "&&",
                        left: self.condition,
                        right: self.body.condition
                    }).transform(compressor);
                    self.body = self.body.body;
                }
                if (aborts(self.body)) {
                    if (self.alternative) {
                        var alt = self.alternative;
                        self.alternative = null;
                        return make_node(AST_BlockStatement, self, {
                            body: [ self, alt ]
                        }).transform(compressor);
                    }
                }
                if (aborts(self.alternative)) {
                    var body = self.body;
                    self.body = self.alternative;
                    self.condition = negated_is_best ? negated : self.condition.negate(compressor);
                    self.alternative = null;
                    return make_node(AST_BlockStatement, self, {
                        body: [ self, body ]
                    }).transform(compressor);
                }
                return self;
            });
            OPT(AST_Switch, function(self, compressor) {
                if (self.body.length == 0 && compressor.option("conditionals")) {
                    return make_node(AST_SimpleStatement, self, {
                        body: self.expression
                    }).transform(compressor);
                }
                for (;;) {
                    var last_branch = self.body[self.body.length - 1];
                    if (last_branch) {
                        var stat = last_branch.body[last_branch.body.length - 1];
                        // last statement
                        if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self) last_branch.body.pop();
                        if (last_branch instanceof AST_Default && last_branch.body.length == 0) {
                            self.body.pop();
                            continue;
                        }
                    }
                    break;
                }
                var exp = self.expression.evaluate(compressor);
                out: if (exp.length == 2) try {
                    // constant expression
                    self.expression = exp[0];
                    if (!compressor.option("dead_code")) break out;
                    var value = exp[1];
                    var in_if = false;
                    var in_block = false;
                    var started = false;
                    var stopped = false;
                    var ruined = false;
                    var tt = new TreeTransformer(function(node, descend, in_list) {
                        if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) {
                            // no need to descend these node types
                            return node;
                        } else if (node instanceof AST_Switch && node === self) {
                            node = node.clone();
                            descend(node, this);
                            return ruined ? node : make_node(AST_BlockStatement, node, {
                                body: node.body.reduce(function(a, branch) {
                                    return a.concat(branch.body);
                                }, [])
                            }).transform(compressor);
                        } else if (node instanceof AST_If || node instanceof AST_Try) {
                            var save = in_if;
                            in_if = !in_block;
                            descend(node, this);
                            in_if = save;
                            return node;
                        } else if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {
                            var save = in_block;
                            in_block = true;
                            descend(node, this);
                            in_block = save;
                            return node;
                        } else if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) {
                            if (in_if) {
                                ruined = true;
                                return node;
                            }
                            if (in_block) return node;
                            stopped = true;
                            return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
                        } else if (node instanceof AST_SwitchBranch && this.parent() === self) {
                            if (stopped) return MAP.skip;
                            if (node instanceof AST_Case) {
                                var exp = node.expression.evaluate(compressor);
                                if (exp.length < 2) {
                                    // got a case with non-constant expression, baling out
                                    throw self;
                                }
                                if (exp[1] === value || started) {
                                    started = true;
                                    if (aborts(node)) stopped = true;
                                    descend(node, this);
                                    return node;
                                }
                                return MAP.skip;
                            }
                            descend(node, this);
                            return node;
                        }
                    });
                    tt.stack = compressor.stack.slice();
                    // so that's able to see parent nodes
                    self = self.transform(tt);
                } catch (ex) {
                    if (ex !== self) throw ex;
                }
                return self;
            });
            OPT(AST_Case, function(self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });
            OPT(AST_Try, function(self, compressor) {
                self.body = tighten_body(self.body, compressor);
                return self;
            });
            AST_Definitions.DEFMETHOD("remove_initializers", function() {
                this.definitions.forEach(function(def) {
                    def.value = null;
                });
            });
            AST_Definitions.DEFMETHOD("to_assignments", function() {
                var assignments = this.definitions.reduce(function(a, def) {
                    if (def.value) {
                        var name = make_node(AST_SymbolRef, def.name, def.name);
                        a.push(make_node(AST_Assign, def, {
                            operator: "=",
                            left: name,
                            right: def.value
                        }));
                    }
                    return a;
                }, []);
                if (assignments.length == 0) return null;
                return AST_Seq.from_array(assignments);
            });
            OPT(AST_Definitions, function(self, compressor) {
                if (self.definitions.length == 0) return make_node(AST_EmptyStatement, self);
                return self;
            });
            OPT(AST_Function, function(self, compressor) {
                self = AST_Lambda.prototype.optimize.call(self, compressor);
                if (compressor.option("unused")) {
                    if (self.name && self.name.unreferenced()) {
                        self.name = null;
                    }
                }
                return self;
            });
            OPT(AST_Call, function(self, compressor) {
                if (compressor.option("unsafe")) {
                    var exp = self.expression;
                    if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                        switch (exp.name) {
                          case "Array":
                            if (self.args.length != 1) {
                                return make_node(AST_Array, self, {
                                    elements: self.args
                                }).transform(compressor);
                            }
                            break;

                          case "Object":
                            if (self.args.length == 0) {
                                return make_node(AST_Object, self, {
                                    properties: []
                                });
                            }
                            break;

                          case "String":
                            if (self.args.length == 0) return make_node(AST_String, self, {
                                value: ""
                            });
                            if (self.args.length <= 1) return make_node(AST_Binary, self, {
                                left: self.args[0],
                                operator: "+",
                                right: make_node(AST_String, self, {
                                    value: ""
                                })
                            }).transform(compressor);
                            break;

                          case "Number":
                            if (self.args.length == 0) return make_node(AST_Number, self, {
                                value: 0
                            });
                            if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
                                expression: self.args[0],
                                operator: "+"
                            }).transform(compressor);

                          case "Boolean":
                            if (self.args.length == 0) return make_node(AST_False, self);
                            if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
                                expression: make_node(AST_UnaryPrefix, null, {
                                    expression: self.args[0],
                                    operator: "!"
                                }),
                                operator: "!"
                            }).transform(compressor);
                            break;

                          case "Function":
                            if (all(self.args, function(x) {
                                return x instanceof AST_String;
                            })) {
                                // quite a corner-case, but we can handle it:
                                //   https://github.com/mishoo/UglifyJS2/issues/203
                                // if the code argument is a constant, then we can minify it.
                                try {
                                    var code = "(function(" + self.args.slice(0, -1).map(function(arg) {
                                        return arg.value;
                                    }).join(",") + "){" + self.args[self.args.length - 1].value + "})()";
                                    var ast = parse(code);
                                    ast.figure_out_scope({
                                        screw_ie8: compressor.option("screw_ie8")
                                    });
                                    var comp = new Compressor(compressor.options);
                                    ast = ast.transform(comp);
                                    ast.figure_out_scope({
                                        screw_ie8: compressor.option("screw_ie8")
                                    });
                                    ast.mangle_names();
                                    var fun;
                                    try {
                                        ast.walk(new TreeWalker(function(node) {
                                            if (node instanceof AST_Lambda) {
                                                fun = node;
                                                throw ast;
                                            }
                                        }));
                                    } catch (ex) {
                                        if (ex !== ast) throw ex;
                                    }
                                    var args = fun.argnames.map(function(arg, i) {
                                        return make_node(AST_String, self.args[i], {
                                            value: arg.print_to_string()
                                        });
                                    });
                                    var code = OutputStream();
                                    AST_BlockStatement.prototype._codegen.call(fun, fun, code);
                                    code = code.toString().replace(/^\{|\}$/g, "");
                                    args.push(make_node(AST_String, self.args[self.args.length - 1], {
                                        value: code
                                    }));
                                    self.args = args;
                                    return self;
                                } catch (ex) {
                                    if (ex instanceof JS_Parse_Error) {
                                        compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
                                        compressor.warn(ex.toString());
                                    } else {
                                        console.log(ex);
                                        throw ex;
                                    }
                                }
                            }
                            break;
                        }
                    } else if (exp instanceof AST_Dot && exp.property == "toString" && self.args.length == 0) {
                        return make_node(AST_Binary, self, {
                            left: make_node(AST_String, self, {
                                value: ""
                            }),
                            operator: "+",
                            right: exp.expression
                        }).transform(compressor);
                    } else if (exp instanceof AST_Dot && exp.expression instanceof AST_Array && exp.property == "join") EXIT: {
                        var separator = self.args.length == 0 ? "," : self.args[0].evaluate(compressor)[1];
                        if (separator == null) break EXIT;
                        // not a constant
                        var elements = exp.expression.elements.reduce(function(a, el) {
                            el = el.evaluate(compressor);
                            if (a.length == 0 || el.length == 1) {
                                a.push(el);
                            } else {
                                var last = a[a.length - 1];
                                if (last.length == 2) {
                                    // it's a constant
                                    var val = "" + last[1] + separator + el[1];
                                    a[a.length - 1] = [ make_node_from_constant(compressor, val, last[0]), val ];
                                } else {
                                    a.push(el);
                                }
                            }
                            return a;
                        }, []);
                        if (elements.length == 0) return make_node(AST_String, self, {
                            value: ""
                        });
                        if (elements.length == 1) return elements[0][0];
                        if (separator == "") {
                            var first;
                            if (elements[0][0] instanceof AST_String || elements[1][0] instanceof AST_String) {
                                first = elements.shift()[0];
                            } else {
                                first = make_node(AST_String, self, {
                                    value: ""
                                });
                            }
                            return elements.reduce(function(prev, el) {
                                return make_node(AST_Binary, el[0], {
                                    operator: "+",
                                    left: prev,
                                    right: el[0]
                                });
                            }, first).transform(compressor);
                        }
                        // need this awkward cloning to not affect original element
                        // best_of will decide which one to get through.
                        var node = self.clone();
                        node.expression = node.expression.clone();
                        node.expression.expression = node.expression.expression.clone();
                        node.expression.expression.elements = elements.map(function(el) {
                            return el[0];
                        });
                        return best_of(self, node);
                    }
                }
                if (compressor.option("side_effects")) {
                    if (self.expression instanceof AST_Function && self.args.length == 0 && !AST_Block.prototype.has_side_effects.call(self.expression, compressor)) {
                        return make_node(AST_Undefined, self).transform(compressor);
                    }
                }
                if (compressor.option("drop_console")) {
                    if (self.expression instanceof AST_PropAccess && self.expression.expression instanceof AST_SymbolRef && self.expression.expression.name == "console" && self.expression.expression.undeclared()) {
                        return make_node(AST_Undefined, self).transform(compressor);
                    }
                }
                return self.evaluate(compressor)[0];
            });
            OPT(AST_New, function(self, compressor) {
                if (compressor.option("unsafe")) {
                    var exp = self.expression;
                    if (exp instanceof AST_SymbolRef && exp.undeclared()) {
                        switch (exp.name) {
                          case "Object":
                          case "RegExp":
                          case "Function":
                          case "Error":
                          case "Array":
                            return make_node(AST_Call, self, self).transform(compressor);
                        }
                    }
                }
                return self;
            });
            OPT(AST_Seq, function(self, compressor) {
                if (!compressor.option("side_effects")) return self;
                if (!self.car.has_side_effects(compressor)) {
                    // we shouldn't compress (1,eval)(something) to
                    // eval(something) because that changes the meaning of
                    // eval (becomes lexical instead of global).
                    var p;
                    if (!(self.cdr instanceof AST_SymbolRef && self.cdr.name == "eval" && self.cdr.undeclared() && (p = compressor.parent()) instanceof AST_Call && p.expression === self)) {
                        return self.cdr;
                    }
                }
                if (compressor.option("cascade")) {
                    if (self.car instanceof AST_Assign && !self.car.left.has_side_effects(compressor)) {
                        if (self.car.left.equivalent_to(self.cdr)) {
                            return self.car;
                        }
                        if (self.cdr instanceof AST_Call && self.cdr.expression.equivalent_to(self.car.left)) {
                            self.cdr.expression = self.car;
                            return self.cdr;
                        }
                    }
                    if (!self.car.has_side_effects(compressor) && !self.cdr.has_side_effects(compressor) && self.car.equivalent_to(self.cdr)) {
                        return self.car;
                    }
                }
                if (self.cdr instanceof AST_UnaryPrefix && self.cdr.operator == "void" && !self.cdr.expression.has_side_effects(compressor)) {
                    self.cdr.operator = self.car;
                    return self.cdr;
                }
                if (self.cdr instanceof AST_Undefined) {
                    return make_node(AST_UnaryPrefix, self, {
                        operator: "void",
                        expression: self.car
                    });
                }
                return self;
            });
            AST_Unary.DEFMETHOD("lift_sequences", function(compressor) {
                if (compressor.option("sequences")) {
                    if (this.expression instanceof AST_Seq) {
                        var seq = this.expression;
                        var x = seq.to_array();
                        this.expression = x.pop();
                        x.push(this);
                        seq = AST_Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                }
                return this;
            });
            OPT(AST_UnaryPostfix, function(self, compressor) {
                return self.lift_sequences(compressor);
            });
            OPT(AST_UnaryPrefix, function(self, compressor) {
                self = self.lift_sequences(compressor);
                var e = self.expression;
                if (compressor.option("booleans") && compressor.in_boolean_context()) {
                    switch (self.operator) {
                      case "!":
                        if (e instanceof AST_UnaryPrefix && e.operator == "!") {
                            // !!foo ==> foo, if we're in boolean context
                            return e.expression;
                        }
                        break;

                      case "typeof":
                        // typeof always returns a non-empty string, thus it's
                        // always true in booleans
                        compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
                        return make_node(AST_True, self);
                    }
                    if (e instanceof AST_Binary && self.operator == "!") {
                        self = best_of(self, e.negate(compressor));
                    }
                }
                return self.evaluate(compressor)[0];
            });
            function has_side_effects_or_prop_access(node, compressor) {
                var save_pure_getters = compressor.option("pure_getters");
                compressor.options.pure_getters = false;
                var ret = node.has_side_effects(compressor);
                compressor.options.pure_getters = save_pure_getters;
                return ret;
            }
            AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
                if (compressor.option("sequences")) {
                    if (this.left instanceof AST_Seq) {
                        var seq = this.left;
                        var x = seq.to_array();
                        this.left = x.pop();
                        x.push(this);
                        seq = AST_Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                    if (this.right instanceof AST_Seq && this instanceof AST_Assign && !has_side_effects_or_prop_access(this.left, compressor)) {
                        var seq = this.right;
                        var x = seq.to_array();
                        this.right = x.pop();
                        x.push(this);
                        seq = AST_Seq.from_array(x).transform(compressor);
                        return seq;
                    }
                }
                return this;
            });
            var commutativeOperators = makePredicate("== === != !== * & | ^");
            OPT(AST_Binary, function(self, compressor) {
                var reverse = compressor.has_directive("use asm") ? noop : function(op, force) {
                    if (force || !(self.left.has_side_effects(compressor) || self.right.has_side_effects(compressor))) {
                        if (op) self.operator = op;
                        var tmp = self.left;
                        self.left = self.right;
                        self.right = tmp;
                    }
                };
                if (commutativeOperators(self.operator)) {
                    if (self.right instanceof AST_Constant && !(self.left instanceof AST_Constant)) {
                        // if right is a constant, whatever side effects the
                        // left side might have could not influence the
                        // result.  hence, force switch.
                        if (!(self.left instanceof AST_Binary && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
                            reverse(null, true);
                        }
                    }
                    if (/^[!=]==?$/.test(self.operator)) {
                        if (self.left instanceof AST_SymbolRef && self.right instanceof AST_Conditional) {
                            if (self.right.consequent instanceof AST_SymbolRef && self.right.consequent.definition() === self.left.definition()) {
                                if (/^==/.test(self.operator)) return self.right.condition;
                                if (/^!=/.test(self.operator)) return self.right.condition.negate(compressor);
                            }
                            if (self.right.alternative instanceof AST_SymbolRef && self.right.alternative.definition() === self.left.definition()) {
                                if (/^==/.test(self.operator)) return self.right.condition.negate(compressor);
                                if (/^!=/.test(self.operator)) return self.right.condition;
                            }
                        }
                        if (self.right instanceof AST_SymbolRef && self.left instanceof AST_Conditional) {
                            if (self.left.consequent instanceof AST_SymbolRef && self.left.consequent.definition() === self.right.definition()) {
                                if (/^==/.test(self.operator)) return self.left.condition;
                                if (/^!=/.test(self.operator)) return self.left.condition.negate(compressor);
                            }
                            if (self.left.alternative instanceof AST_SymbolRef && self.left.alternative.definition() === self.right.definition()) {
                                if (/^==/.test(self.operator)) return self.left.condition.negate(compressor);
                                if (/^!=/.test(self.operator)) return self.left.condition;
                            }
                        }
                    }
                }
                self = self.lift_sequences(compressor);
                if (compressor.option("comparisons")) switch (self.operator) {
                  case "===":
                  case "!==":
                    if (self.left.is_string(compressor) && self.right.is_string(compressor) || self.left.is_boolean() && self.right.is_boolean()) {
                        self.operator = self.operator.substr(0, 2);
                    }

                  // XXX: intentionally falling down to the next case
                    case "==":
                  case "!=":
                    if (self.left instanceof AST_String && self.left.value == "undefined" && self.right instanceof AST_UnaryPrefix && self.right.operator == "typeof" && compressor.option("unsafe")) {
                        if (!(self.right.expression instanceof AST_SymbolRef) || !self.right.expression.undeclared()) {
                            self.right = self.right.expression;
                            self.left = make_node(AST_Undefined, self.left).optimize(compressor);
                            if (self.operator.length == 2) self.operator += "=";
                        }
                    }
                    break;
                }
                if (compressor.option("booleans") && compressor.in_boolean_context()) switch (self.operator) {
                  case "&&":
                    var ll = self.left.evaluate(compressor);
                    var rr = self.right.evaluate(compressor);
                    if (ll.length > 1 && !ll[1] || rr.length > 1 && !rr[1]) {
                        compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
                        return make_node(AST_False, self);
                    }
                    if (ll.length > 1 && ll[1]) {
                        return rr[0];
                    }
                    if (rr.length > 1 && rr[1]) {
                        return ll[0];
                    }
                    break;

                  case "||":
                    var ll = self.left.evaluate(compressor);
                    var rr = self.right.evaluate(compressor);
                    if (ll.length > 1 && ll[1] || rr.length > 1 && rr[1]) {
                        compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
                        return make_node(AST_True, self);
                    }
                    if (ll.length > 1 && !ll[1]) {
                        return rr[0];
                    }
                    if (rr.length > 1 && !rr[1]) {
                        return ll[0];
                    }
                    break;

                  case "+":
                    var ll = self.left.evaluate(compressor);
                    var rr = self.right.evaluate(compressor);
                    if (ll.length > 1 && ll[0] instanceof AST_String && ll[1] || rr.length > 1 && rr[0] instanceof AST_String && rr[1]) {
                        compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
                        return make_node(AST_True, self);
                    }
                    break;
                }
                if (compressor.option("comparisons")) {
                    if (!(compressor.parent() instanceof AST_Binary) || compressor.parent() instanceof AST_Assign) {
                        var negated = make_node(AST_UnaryPrefix, self, {
                            operator: "!",
                            expression: self.negate(compressor)
                        });
                        self = best_of(self, negated);
                    }
                    switch (self.operator) {
                      case "<":
                        reverse(">");
                        break;

                      case "<=":
                        reverse(">=");
                        break;
                    }
                }
                if (self.operator == "+" && self.right instanceof AST_String && self.right.getValue() === "" && self.left instanceof AST_Binary && self.left.operator == "+" && self.left.is_string(compressor)) {
                    return self.left;
                }
                if (compressor.option("evaluate")) {
                    if (self.operator == "+") {
                        if (self.left instanceof AST_Constant && self.right instanceof AST_Binary && self.right.operator == "+" && self.right.left instanceof AST_Constant && self.right.is_string(compressor)) {
                            self = make_node(AST_Binary, self, {
                                operator: "+",
                                left: make_node(AST_String, null, {
                                    value: "" + self.left.getValue() + self.right.left.getValue(),
                                    start: self.left.start,
                                    end: self.right.left.end
                                }),
                                right: self.right.right
                            });
                        }
                        if (self.right instanceof AST_Constant && self.left instanceof AST_Binary && self.left.operator == "+" && self.left.right instanceof AST_Constant && self.left.is_string(compressor)) {
                            self = make_node(AST_Binary, self, {
                                operator: "+",
                                left: self.left.left,
                                right: make_node(AST_String, null, {
                                    value: "" + self.left.right.getValue() + self.right.getValue(),
                                    start: self.left.right.start,
                                    end: self.right.end
                                })
                            });
                        }
                        if (self.left instanceof AST_Binary && self.left.operator == "+" && self.left.is_string(compressor) && self.left.right instanceof AST_Constant && self.right instanceof AST_Binary && self.right.operator == "+" && self.right.left instanceof AST_Constant && self.right.is_string(compressor)) {
                            self = make_node(AST_Binary, self, {
                                operator: "+",
                                left: make_node(AST_Binary, self.left, {
                                    operator: "+",
                                    left: self.left.left,
                                    right: make_node(AST_String, null, {
                                        value: "" + self.left.right.getValue() + self.right.left.getValue(),
                                        start: self.left.right.start,
                                        end: self.right.left.end
                                    })
                                }),
                                right: self.right.right
                            });
                        }
                    }
                }
                // x * (y * z)  ==>  x * y * z
                if (self.right instanceof AST_Binary && self.right.operator == self.operator && (self.operator == "*" || self.operator == "&&" || self.operator == "||")) {
                    self.left = make_node(AST_Binary, self.left, {
                        operator: self.operator,
                        left: self.left,
                        right: self.right.left
                    });
                    self.right = self.right.right;
                    return self.transform(compressor);
                }
                return self.evaluate(compressor)[0];
            });
            OPT(AST_SymbolRef, function(self, compressor) {
                if (self.undeclared()) {
                    var defines = compressor.option("global_defs");
                    if (defines && defines.hasOwnProperty(self.name)) {
                        return make_node_from_constant(compressor, defines[self.name], self);
                    }
                    switch (self.name) {
                      case "undefined":
                        return make_node(AST_Undefined, self);

                      case "NaN":
                        return make_node(AST_NaN, self);

                      case "Infinity":
                        return make_node(AST_Infinity, self);
                    }
                }
                return self;
            });
            OPT(AST_Undefined, function(self, compressor) {
                if (compressor.option("unsafe")) {
                    var scope = compressor.find_parent(AST_Scope);
                    var undef = scope.find_variable("undefined");
                    if (undef) {
                        var ref = make_node(AST_SymbolRef, self, {
                            name: "undefined",
                            scope: scope,
                            thedef: undef
                        });
                        ref.reference();
                        return ref;
                    }
                }
                return self;
            });
            var ASSIGN_OPS = [ "+", "-", "/", "*", "%", ">>", "<<", ">>>", "|", "^", "&" ];
            OPT(AST_Assign, function(self, compressor) {
                self = self.lift_sequences(compressor);
                if (self.operator == "=" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary && self.right.left instanceof AST_SymbolRef && self.right.left.name == self.left.name && member(self.right.operator, ASSIGN_OPS)) {
                    self.operator = self.right.operator + "=";
                    self.right = self.right.right;
                }
                return self;
            });
            OPT(AST_Conditional, function(self, compressor) {
                if (!compressor.option("conditionals")) return self;
                if (self.condition instanceof AST_Seq) {
                    var car = self.condition.car;
                    self.condition = self.condition.cdr;
                    return AST_Seq.cons(car, self);
                }
                var cond = self.condition.evaluate(compressor);
                if (cond.length > 1) {
                    if (cond[1]) {
                        compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
                        return self.consequent;
                    } else {
                        compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
                        return self.alternative;
                    }
                }
                var negated = cond[0].negate(compressor);
                if (best_of(cond[0], negated) === negated) {
                    self = make_node(AST_Conditional, self, {
                        condition: negated,
                        consequent: self.alternative,
                        alternative: self.consequent
                    });
                }
                var consequent = self.consequent;
                var alternative = self.alternative;
                if (consequent instanceof AST_Assign && alternative instanceof AST_Assign && consequent.operator == alternative.operator && consequent.left.equivalent_to(alternative.left)) {
                    /*
             * Stuff like this:
             * if (foo) exp = something; else exp = something_else;
             * ==>
             * exp = foo ? something : something_else;
             */
                    return make_node(AST_Assign, self, {
                        operator: consequent.operator,
                        left: consequent.left,
                        right: make_node(AST_Conditional, self, {
                            condition: self.condition,
                            consequent: consequent.right,
                            alternative: alternative.right
                        })
                    });
                }
                if (consequent instanceof AST_Call && alternative.TYPE === consequent.TYPE && consequent.args.length == alternative.args.length && consequent.expression.equivalent_to(alternative.expression)) {
                    if (consequent.args.length == 0) {
                        return make_node(AST_Seq, self, {
                            car: self.condition,
                            cdr: consequent
                        });
                    }
                    if (consequent.args.length == 1) {
                        consequent.args[0] = make_node(AST_Conditional, self, {
                            condition: self.condition,
                            consequent: consequent.args[0],
                            alternative: alternative.args[0]
                        });
                        return consequent;
                    }
                }
                return self;
            });
            OPT(AST_Boolean, function(self, compressor) {
                if (compressor.option("booleans")) {
                    var p = compressor.parent();
                    if (p instanceof AST_Binary && (p.operator == "==" || p.operator == "!=")) {
                        compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
                            operator: p.operator,
                            value: self.value,
                            file: p.start.file,
                            line: p.start.line,
                            col: p.start.col
                        });
                        return make_node(AST_Number, self, {
                            value: +self.value
                        });
                    }
                    return make_node(AST_UnaryPrefix, self, {
                        operator: "!",
                        expression: make_node(AST_Number, self, {
                            value: 1 - self.value
                        })
                    });
                }
                return self;
            });
            OPT(AST_Sub, function(self, compressor) {
                var prop = self.property;
                if (prop instanceof AST_String && compressor.option("properties")) {
                    prop = prop.getValue();
                    if (RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is_identifier_string(prop)) {
                        return make_node(AST_Dot, self, {
                            expression: self.expression,
                            property: prop
                        });
                    }
                    var v = parseFloat(prop);
                    if (!isNaN(v) && v.toString() == prop) {
                        self.property = make_node(AST_Number, self.property, {
                            value: v
                        });
                    }
                }
                return self;
            });
            function literals_in_boolean_context(self, compressor) {
                if (compressor.option("booleans") && compressor.in_boolean_context()) {
                    return make_node(AST_True, self);
                }
                return self;
            }
            OPT(AST_Array, literals_in_boolean_context);
            OPT(AST_Object, literals_in_boolean_context);
            OPT(AST_RegExp, literals_in_boolean_context);
        })();
        exports.Compressor = Compressor;
    });
    define("hsp/transpiler/processAST.js", [ "uglify-js" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /*
 * Copyright 2014 Amadeus s.a.s.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var preIncDec = {
            "++": "+=",
            "--": "-="
        };
        var postIncDec = {
            "++": "inc",
            "--": "dec"
        };
        module.exports = function(ast, options) {
            options = options || {};
            var UglifyJS = options["uglify-js"] || require("uglify-js");
            var mode = options.mode || "commonJS";
            if (mode !== "global" && mode !== "commonJS") {
                throw new Error("Invalid compilation mode option: " + mode);
            }
            var isCommonJS = mode === "commonJS";
            var setVarName = options.setVarName || "$set";
            function getPropertyName(propAccess) {
                if (propAccess instanceof UglifyJS.AST_Dot) {
                    return new UglifyJS.AST_String({
                        value: propAccess.property
                    });
                } else {
                    return propAccess.property;
                }
            }
            function createCallRuntimeMethod(method, args, originalNode) {
                var $setRef = new UglifyJS.AST_SymbolRef({
                    name: setVarName
                });
                var res = new UglifyJS.AST_Call({
                    expression: method == "$set" ? $setRef : new UglifyJS.AST_Dot({
                        expression: $setRef,
                        property: method
                    }),
                    args: args
                });
                res.formatInfo = {
                    before: (method == "$set" ? setVarName : setVarName + "." + method) + "(",
                    middle: args,
                    after: ")",
                    originalStartPos: originalNode.start.pos,
                    originalEndPos: originalNode.end.endpos
                };
                return res;
            }
            var createRequire = function() {
                var res = new UglifyJS.AST_Var({
                    definitions: [ new UglifyJS.AST_VarDef({
                        name: new UglifyJS.AST_SymbolVar({
                            name: setVarName
                        }),
                        value: new UglifyJS.AST_Call({
                            expression: new UglifyJS.AST_SymbolRef({
                                name: "require"
                            }),
                            args: [ new UglifyJS.AST_String({
                                value: "hsp/$set"
                            }) ]
                        })
                    }) ]
                });
                res.formatInfo = {
                    before: res.print_to_string(),
                    middle: [],
                    after: "; ",
                    originalStartPos: 0,
                    originalEndPos: 0
                };
                return res;
            };
            function replaceAssignment(node, aDotB) {
                if (node.operator == "=") {
                    return createCallRuntimeMethod("$set", [ aDotB.expression, getPropertyName(aDotB), node.right ], node);
                } else {
                    return createCallRuntimeMethod("op", [ aDotB.expression, getPropertyName(aDotB), new UglifyJS.AST_String({
                        value: node.operator
                    }), node.right ], node);
                }
                return node;
            }
            function replacePostIncDec(node, aDotB) {
                return createCallRuntimeMethod(postIncDec[node.operator], [ aDotB.expression, getPropertyName(aDotB) ], node);
            }
            function replacePreIncDec(node, aDotB, options) {
                return createCallRuntimeMethod("op", [ aDotB.expression, getPropertyName(aDotB), new UglifyJS.AST_String({
                    value: preIncDec[node.operator]
                }), new UglifyJS.AST_Number({
                    value: 1
                }) ], node, aDotB);
            }
            function replaceDelete(node, aDotB, options) {
                return createCallRuntimeMethod("del", [ aDotB.expression, getPropertyName(aDotB) ], node);
            }
            var changed = false;
            var transformer = new UglifyJS.TreeTransformer(function(node, descend) {
                descend(node, this);
                var replacer = null;
                var aDotB = null;
                if (node instanceof UglifyJS.AST_Assign) {
                    aDotB = node.left;
                    replacer = replaceAssignment;
                } else if (node instanceof UglifyJS.AST_Unary) {
                    aDotB = node.expression;
                    if (node.operator == "delete") {
                        replacer = replaceDelete;
                    } else if (preIncDec.hasOwnProperty(node.operator)) {
                        replacer = node instanceof UglifyJS.AST_UnaryPostfix ? replacePostIncDec : replacePreIncDec;
                    }
                }
                if (replacer && aDotB instanceof UglifyJS.AST_PropAccess) {
                    changed = true;
                    node = replacer(node, aDotB);
                }
                if (changed && node instanceof UglifyJS.AST_Toplevel && isCommonJS) {
                    node.body.unshift(createRequire());
                }
                return node;
            });
            ast.transform(transformer);
            return changed;
        };
    });
    define("hsp/transpiler/formatAST.js", [ "uglify-js" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /*
 * Copyright 2014 Amadeus s.a.s.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        module.exports = function(ast, fileContent, options) {
            options = options || {};
            var UglifyJS = options["uglify-js"] || require("uglify-js");
            fileContent = fileContent.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, "");
            var nextStart = null;
            var out = [];
            function continueUntil(newPosition) {
                if (nextStart !== null && newPosition > nextStart) {
                    out.push(fileContent.substring(nextStart, newPosition));
                }
                nextStart = null;
            }
            function restartFrom(newPosition) {
                nextStart = newPosition;
            }
            function walkFunction(node, descend) {
                var newStart = nextStart === null;
                var formatInfo = node.formatInfo;
                if (formatInfo) {
                    if (!newStart) {
                        continueUntil(formatInfo.originalStartPos);
                    }
                    out.push(formatInfo.before);
                    var middle = formatInfo.middle;
                    for (var i = 0, l = middle.length; i < l; i++) {
                        if (i > 0) {
                            out.push(", ");
                        }
                        walkNode(middle[i]);
                    }
                    out.push(formatInfo.after);
                    if (!newStart) {
                        restartFrom(formatInfo.originalEndPos);
                    }
                } else if (newStart && !(node.start && node.end)) {
                    out.push(node.print_to_string());
                } else {
                    if (newStart) {
                        restartFrom(node.start.pos);
                    }
                    descend();
                    if (newStart) {
                        continueUntil(node.end.endpos);
                    }
                }
                return true;
            }
            function walkNode(node) {
                var walker = new UglifyJS.TreeWalker(walkFunction);
                node.walk(walker);
            }
            walkNode(ast);
            return out.join("");
        };
    });
    define("hsp/transpiler/processString.js", [ "./processAST", "./formatAST", "uglify-js" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /*
 * Copyright 2014 Amadeus s.a.s.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var processAST = require("./processAST");
        var formatAST = require("./formatAST");
        module.exports = function(fileContent, fileName, options) {
            options = options || {};
            var UglifyJS = options["uglify-js"] || require("uglify-js");
            var ast = UglifyJS.parse(fileContent, {
                filename: fileName
            });
            var changed = processAST(ast, options);
            return {
                changed: changed,
                code: changed ? formatAST(ast, fileContent, options) : fileContent,
                ast: ast
            };
        };
    });
    define("hsp/transpiler/index.js", [ "./processString", "./processAST", "./formatAST" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /*
 * Copyright 2014 Amadeus s.a.s.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        module.exports = {
            processString: require("./processString"),
            processAST: require("./processAST"),
            formatAST: require("./formatAST")
        };
    });
    define("hsp/compiler/compiler.js", [ "./parser/index", "./treebuilder/index", "./jsgenerator/index", "../transpiler/index" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        var parser = require("./parser/index");
        var treebuilder = require("./treebuilder/index");
        var jsgenerator = require("./jsgenerator/index");
        var transpiler = require("../transpiler/index");
        /**
 * Compiles a template and return a JS compiled string and a list of errors.
 * @param {String} template the template file content as a string.
 * @param {String} path path of a file being compiled (optional - used for error messages).
 * @param {Object} compiler options; supported options are:
 *      includeSyntaxTree  if true, the result object will contain the syntax tree generated by the compiler.
 *      bypassJSvalidation  if true, the validation of the generated JS file (including non-template code) is bypassed - default:false.
 *      mode the type of module system the code shold comply with: either "commonJS" or "global" 
 *      globalRef the name of the runtime global reference when the "global" mode is used (default: "hsp")
 * @return {Object} a JSON structure with the following properties:
 *      errors: {Array} the error list - each error having the following structure:
 *          description: {String} - a message describing the error 
 *          line: {Number} - the error line number
 *          column: {Number} - the error column number 
 *          code: {String} - a code extract showing where the error occurs (optional)
 *      code: {String} the generated JavaScript code
 *      syntaxTree: {JSON} the syntax tree generated by the parser (optional - cf. parameters)
 *      lineMap: {Array} array of the new line indexes: lineMap[3] returns the new line index for line 4 in
 *          the orginal file (lineMap[0] is always 0 as all line count starts at 1 for both input and output values)
 */
        exports.compile = function(template, path, options) {
            options = options || {};
            if (!path) {
                throw new Error('The template "path" argument is mandatory.');
            }
            if (!template) {
                throw new Error('The template "' + path + '" is empty but content to compile is mandatory.');
            }
            // Parsing might throw an exception
            var res;
            var m = path.match(/[^\/]+$/), fileName = m ? m[0] : "unknown", dirPath = "";
            if (fileName.length < path.length) {
                dirPath = path.slice(0, -fileName.length);
            }
            //Step 1: parser
            var blockList = parser.parse(template);
            //Step2 : treebuilder
            res = treebuilder.build(blockList);
            //Step3 : jsgenerator
            res = jsgenerator.generate(res, template, fileName, dirPath, options);
            //Step4 : transpiler
            if (!res.errors || res.errors.length === 0) {
                res.code = transpiler.processString(res.code, path, options).code;
            }
            return res;
        };
    });
    define("hsp/compiler/compile.js", [ "./compiler" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /*
 * Copyright 2014 Amadeus s.a.s.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var compiler = require("./compiler");
        module.exports = function(code, moduleName, options) {
            var compileRes = compiler.compile(code, moduleName, options);
            return compileRes.code;
        };
    });
    define("hsp/transpiler/transpile.js", [ "./processString" ], function(module, global) {
        var require = module.require, exports = module.exports, __filename = module.filename, __dirname = module.dirname;
        /*
 * Copyright 2014 Amadeus s.a.s.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var processString = require("./processString");
        module.exports = function(code, moduleName, options) {
            var transpileRes = processString(code, moduleName, options);
            return transpileRes.code;
        };
    });
})(noder.define);