var klass = require("../../klass");
var HExpression = klass({
    /**
     * Process the HExpression node parsed by the PEG grammar to generate a more digestable format for the syntax tree
     * (note:processing is mostly for the JSExpression parts)
     * @param {JSON} node the node generated by the PEG Grammar (cf. HExpression)
     * @param {SyntaxTree} globalSyntaxTree the parent syntax tree
     */
    $constructor : function (node, globalSyntaxTree) {
        this.rootExpression = node;
        this.errors = null;
        this.globalSyntaxTree = globalSyntaxTree;
        if (node.expType) {
            node.type = node.expType;
        }

        if (node.category !== "jsexpression") {
            // we only reprocess jsexpression
            this.syntaxTree = node;
        } else {
            this._objectRefs = []; // list of objectref expressions found in the jsexpression

            var code = this._process(node);
            this.rootExpression.code = code;
            this.syntaxTree = {
                type : "expression",
                category : "jsexpression",
                objectrefs : this._objectRefs,
                code : code
            };

            // if we have only one variable, we can simplify the syntaxtree
            if (code === "a0") {
                this.syntaxTree = this._objectRefs[0];
            } else if (code.match(/^ *$/)) {
                // there is no code to display
                this.syntaxTree = {
                    "type" : "text",
                    "value" : code
                };
            }

            // add line / column nbr if present
            if (node.line) {
                this.syntaxTree.line = node.line;
                this.syntaxTree.column = node.column;
            }

            // check errors
            if (this.errors) {
                for (var i = 0; i < this.errors.length; i++) {
                    globalSyntaxTree._logError(this.errors[i], this.rootExpression);
                }
            }
        }
    },
    /**
     * Return the syntax tree node to put in the global syntax tree
     */
    getSyntaxTree : function () {
        return this.syntaxTree;
    },

    /**
     * Log an error on the syntax tree associated to this expression
     */
    _logError : function (msg) {
        if (!this.errors) {
            this.errors = [];
        }
        this.errors.push(msg);
    },

    /**
     * Internal recursive method to process a node
     * @param {JSON} node the expression node to be processed
     * @return {String} the JS code associated to this node
     */
    _process : function (node) {
        var result = "";
        switch (node.type) {
            case "expression" :
                result = this._getValue(node);
                break;
            case "BinaryExpression" :
                result = '(' + this._process(node.left) + ' ' + node.operator + ' ' + this._process(node.right) + ')';
                break;
            case "UnaryExpression" : // e.g. !x +x -x typeof x. Note that ++x and --x will not be supported
                result = '' + node.operator + '(' + this._process(node.expression) + ')';
                if (node.operator === '++' || node.operator === '--') {
                    this._logError('Unary operator ' + node.operator + ' is not allowed');
                }
                break;
            case "PostfixExpression" : // e.g. x++ or x-- (not allowed)
                result = '' + '(' + this._process(node.expression) + ')' + node.operator;
                this._logError('Postfix operator ' + node.operator + ' is not allowed');
                break;
            case "Variable" :
                result = this._getValue({
                    type : "expression",
                    "category" : "objectref",
                    bound : node.bound,
                    "path" : [node.name]
                });
                break;
            case "PropertyAccess" :
                // this is an object ref
                var n = node, path = [], name;
                while (n) {
                    name = n.name;
                    if (name.type && name.type === "expression") {
                        path.push(name.value);
                    } else {
                        path.push(name);
                    }
                    n = n.base;
                }
                path.reverse();
                result = this._getValue({
                    type : "expression",
                    "category" : "objectref",
                    bound : node.bound,
                    "path" : path
                });
                break;
            case "ConditionalExpression" :
                result = '(' + this._process(node.condition) + '? ' + this._process(node.trueExpression) + ' : '
                        + this._process(node.falseExpression) + ')';
                break;
            case "FunctionCall" :
                // this is an object ref
                var n = node.name, path = [];
                while (n) {
                    path.push(n.name);
                    n = n.base;
                }
                path.reverse();

                var n = {
                    type : "expression",
                    "category" : "functionref",
                    bound : node.bound,
                    "path" : path
                };
                result = this._getValue(n);

                // add arguments
                var outArgs = [], args = node.arguments;
                for (var i = 0; i < (args ? args.length : 0); i++) {
                    if (!args[i].category) {
                        // add category otherwise HExpression will not be parsed
                        args[i].category = "jsexpression";
                    }
                    var expr = new HExpression(args[i], this.globalSyntaxTree);
                    outArgs[i] = expr.getSyntaxTree();
                }
                n.args = outArgs;
                break;
            case "CssClassElement" :
                result = "((" + this._process(node.right) + ")? ''+" + this._process(node.left) + ":'')";
                break;
            case "CssClassExpression" :
                var list = node.list, length = list.length, code = [];
                for (var i = 0; i < length; i++) {
                    code[i] = this._process(list[i]);
                }
                if (length < 1) {
                    result = '';
                } else {
                    result = "[" + code.join(",") + "].join(' ')";
                }
                break;
            case "ObjectLiteral":
                var properties = node.properties, length = properties.length, code = [];
                for (var i = 0; i < length; i++) {
                    code[i] = this._process(properties[i]);
                }
                if (length < 1) {
                    result = '';
                } else {
                    result = "{" + code.join(",") + "}";
                }
                break;
            case "PropertyAssignment":
                var name = node.name, child = node.value;
                var code = this._process(child);
                result = name + ":" + code;
                break;
            default :
                this._logError(node.type + '(s) are not supported yet');
                console.warn('[HExpression] ' + node.type + '(s) are not supported yet:');
                console.dir(node);
                break;
        }
        return result;
    },

    /**
     * Returns the code value for a node of type "expression" (i.e. literals, objectrefs...).
     * @param {Object} node the node.
     * @return {String} the value of the node.
     */
    _getValue : function (node) {
        var result = '';
        switch (node.category) {
            case "objectref" :
                var length = this._objectRefs.length, expr, pathLength, ok;

                // check if an indentical expression already exist
                for (var i = 0; i < length; i++) {
                    expr = this._objectRefs[i], pathLength = expr.path.length, ok = true;
                    // only the path may vary
                    if (expr.category !== "objectref") {
                        continue;
                    }
                    if (pathLength === node.path.length) {
                        for (var j = 0; j < pathLength; j++) {
                            if (expr.path[j] !== node.path[j]) {
                                ok = false;
                                break;
                            }
                        }
                        if (ok) {
                            result = "a" + i;
                            break;
                        }
                    }
                }

                if (!result) {
                    // objectref doesn't exist in previous expressions
                    result = "a" + length; // argument variable
                    this._objectRefs[length] = node;
                }
                break;
            case "functionref" :
                // add the function call to the object ref list
                // we don't optimize the storeage as it is less likely to have the same combination repeated
                // than with simple object refs
                var length = this._objectRefs.length;
                result = "a" + length; // argument variable
                this._objectRefs[length] = node;
                break;
            case "string" :
                result = '"' + node.value.replace(/\"/g, '\\"') + '"';
                break;
            case "boolean" :
            case "number" :
                result = node.value;
                break;
            case "null" :
                result = "null";
                break;
        }
        return result;
    }
});
exports.HExpression = HExpression;