var klass = require("../../klass");
var HExpression = klass({
    /**
     * Process the HExpression node parsed by the PEG grammar to generate a more digestable format for the syntax tree
     * (note:processing is mostly for the JSExpression parts)
     * @param {JSON} node the node generated by the PEG Grammar (cf. HExpression)
     */
    $constructor : function (node, globalSyntaxTree) {
        this.rootExpression = node;
        this.errors = null;
        this.globalSyntaxTree = globalSyntaxTree;
        if (node.expType) {
            node.type = node.expType;
        }

        if (node.category !== "jsexpression") {
            // we only reprocess jsexpression
            this._st = node;
        } else {
            this._objectRefs = []; // list of objectref expressions found in the jsexpression

            var code = this._process(node);
            this.rootExpression.code = code;
            this._st = {
                type : "expression",
                category : "jsexpression",
                objectrefs : this._objectRefs,
                code : code
            };

            // if we have only one variable, we can simplify the syntaxtree
            if (code === "a0") {
                this._st = this._objectRefs[0];
            } else if (code.match(/^ *$/)) {
                // there is no code to display
                this._st = {
                    "type" : "text",
                    "value" : code
                };
            }

            // add line / column nbr if present
            if (node.line) {
                this._st.line = node.line;
                this._st.column = node.column;
            }

            // check errors
            if (this.errors) {
                for (var i = 0, sz = this.errors.length; sz > i; i++) {
                    globalSyntaxTree._logError(this.errors[i], this.rootExpression);
                }
            }
        }
    },
    /**
     * Return the syntax tree node to put in the global syntax tree
     */
    getSyntaxTree : function () {
        return this._st;
    },

    /**
     * Log an error on the syntax tree associated to this expression
     */
    _logError : function (msg) {
        if (!this.errors) {
            this.errors = [];
        }
        this.errors.push(msg);
    },

    /**
     * Internal recursive method to process a node
     * @param {JSON} node the expression node to be processed
     * @return {String} the JS code associated to this node
     */
    _process : function (node) {
        var r = "";
        switch (node.type) {
            case "expression" :
                r = this._getValue(node);
                break;
            case "BinaryExpression" :
                r = '(' + this._process(node.left) + ' ' + node.operator + ' ' + this._process(node.right) + ')';
                break;
            case "UnaryExpression" : // e.g. !x +x -x typeof x ++x and --x will not be supported
                r = '' + node.operator + '(' + this._process(node.expression) + ')';
                if (node.operator === '++' || node.operator === '--') {
                    this._logError('Unary operator ' + node.operator + ' is not allowed');
                }
                break;
            case "PostfixExpression" : // e.g. x++ or x-- (not allowed)
                r = '' + '(' + this._process(node.expression) + ')' + node.operator;
                this._logError('Postfix operator ' + node.operator + ' is not allowed');
                break;
            case "Variable" :
                r = this._getValue({
                    type : "expression",
                    "category" : "objectref",
                    bound : node.bound,
                    "path" : [node.name]
                });
                break;
            case "PropertyAccess" :
                // this is an object ref
                var n = node, p = [], nm;
                while (n) {
                    nm = n.name;
                    if (nm.type && nm.type === "expression") {
                        p.push(nm.value);
                    } else {
                        p.push(nm);
                    }
                    n = n.base;
                }
                p.reverse();
                r = this._getValue({
                    type : "expression",
                    "category" : "objectref",
                    bound : node.bound,
                    "path" : p
                });
                break;
            case "ConditionalExpression" :
                r = '(' + this._process(node.condition) + '? ' + this._process(node.trueExpression) + ' : '
                        + this._process(node.falseExpression) + ')';
                break;
            case "FunctionCall" :
                // this is an object ref
                var n = node.name, p = [];
                while (n) {
                    p.push(n.name);
                    n = n.base;
                }
                p.reverse();

                var n = {
                    type : "expression",
                    "category" : "functionref",
                    bound : node.bound,
                    "path" : p
                };
                r = this._getValue(n);

                // add arguments
                var args2 = [], args = node.arguments, sz = args ? args.length : 0, e;
                for (var i = 0; sz > i; i++) {
                    if (!args[i].category) {
                        // add category otherwise HExpression will not be parsed
                        args[i].category = "jsexpression";
                    }
                    e = new HExpression(args[i], this.globalSyntaxTree);
                    args2[i] = e.getSyntaxTree();
                }
                n.args = args2;
                break;
            case "CssClassElement" :
                r = "((" + this._process(node.right) + ")? ''+" + this._process(node.left) + ":'')";
                break;
            case "CssClassExpression" :
                var ls = node.list, sz = ls.length, code = [];
                for (var i = 0; sz > i; i++) {
                    code[i] = this._process(ls[i]);
                }
                if (sz < 1) {
                    r = '';
                } else {
                    r = "[" + code.join(",") + "].join(' ')";
                }
                break;
            case "ObjectLiteral":
                var properties = node.properties, size = properties.length, code = [];
                for (var i = 0; size > i; i++) {
                    code[i] = this._process(properties[i]);
                }
                if (size < 1) {
                    r = '';
                } else {
                    r = "{" + code.join(",") + "}";
                }
                break;
            case "PropertyAssignment":
                var name = node.name, child = node.value;
                var code = this._process(child);
                r = name + ":" + code;
                break;
            default :
                this._logError(node.type + '(s) are not supported yet');
                console.warn('[HExpression] ' + node.type + '(s) are not supported yet:');
                console.dir(node);
                break;
        }
        return r;
    },

    /**
     * Return the code value for a node of type "expression" (i.e. literals, objectrefs...)
     */
    _getValue : function (node) {
        var r = '';
        switch (node.category) {
            case "objectref" :
                var sz = this._objectRefs.length, e, pl, ok;

                // check if an indentical expression already exist
                for (var i = 0; sz > i; i++) {
                    e = this._objectRefs[i], pl = e.path.length, ok = true;
                    // only the path may vary
                    if (e.category !== "objectref") {
                        continue;
                    }
                    if (pl === node.path.length) {
                        for (var j = 0; pl > j; j++) {
                            if (e.path[j] !== node.path[j]) {
                                ok = false;
                                break;
                            }
                        }
                        if (ok) {
                            r = "a" + i;
                            break;
                        }
                    }
                }

                if (!r) {
                    // objectref doesn't exist in previous expressions
                    r = "a" + sz; // argument variable
                    this._objectRefs[sz] = node;
                }
                break;
            case "functionref" :
                // add the function call to the object ref list
                // we don't optimize the storeage as it is less likely to have the same combination repeated
                // than with simple object refs
                var sz = this._objectRefs.length;
                r = "a" + sz; // argument variable
                this._objectRefs[sz] = node;
                break;
            case "string" :
                r = '"' + node.value.replace(/\"/g, '\\"') + '"';
                break;
            case "boolean" :
            case "number" :
                r = node.value;
                break;
            case "null" :
                r = "null";
                break;
        }
        return r;
    }
});
exports.HExpression = HExpression;