var klass = require("../../klass");
var HExpression = klass({
    /**
     * Process the HExpression node parsed by the PEG grammar to generate a more digestable format for the syntax tree
     * (note:processing is mostly for the JSExpression parts)
     * @param {JSON} node the node generated by the PEG Grammar (cf. HExpression)
     * @param {SyntaxTree} globalSyntaxTree the parent syntax tree
     */
    $constructor : function (node, globalSyntaxTree) {
        this.rootExpression = node;
        this.errors = null;
        this.globalSyntaxTree = globalSyntaxTree;
        if (node.expType) {
            node.type = node.expType;
        }

        if (node.category !== "jsexpression") {
            // we only reprocess jsexpression
            this.syntaxTree = node;
        } else {
            if (node.pipes) {
                node=this._transformPipesIntoFnCalls(node);
                node.type=node.expType;
            }
            this._objectRefs = []; // list of objectref expressions found in the jsexpression
            var code = this._process(node), oref=this._objectRefs;
            this.rootExpression.code = code;
            this.syntaxTree = {
                type : "expression",
                category : "jsexpression",
                objectrefs : oref,
                code : code
            };

            // if we have only one variable, we can simplify the syntaxtree
            if (code === "a0") {
                this.syntaxTree = oref[0];
            } else if (code.match(/^a\d+$/) && oref && oref[oref.length-1].category==="dynref") {
                // this is a dynamic object path

                this.syntaxTree = oref[oref.length-1];
                oref.pop();
                this.syntaxTree.objectrefs = oref;
            } else if (code.match(/^ *$/)) {
                // there is no code to display
                this.syntaxTree = {
                    "type" : "text",
                    "value" : code
                };
            }

            // add line / column nbr if present
            if (node.line) {
                this.syntaxTree.line = node.line;
                this.syntaxTree.column = node.column;
            }

            // check errors
            if (this.errors) {
                for (var i = 0; i < this.errors.length; i++) {
                    globalSyntaxTree._logError(this.errors[i], this.rootExpression);
                }
            }
        }
    },
    /**
     * Return the syntax tree node to put in the global syntax tree
     */
    getSyntaxTree : function () {
        return this.syntaxTree;
    },

    /**
     * Log an error on the syntax tree associated to this expression
     */
    _logError : function (msg) {
        if (!this.errors) {
            this.errors = [];
        }
        this.errors.push(msg);
    },

    /**
     * Internal recursive method to process a node
     * @param {JSON} node the expression node to be processed
     * @return {String} the JS code associated to this node - e.g. "((a0 + 2) + \"a\")"
     */
    _process : function (node) {
        var result = "";
        switch (node.type) {
            case "expression" : // root node - we have to look at node.category
                result = this._getValue(node);
                break;
            case "BinaryExpression" : // e.g. a + b
                result = '(' + this._process(node.left) + ' ' + node.operator + ' ' + this._process(node.right) + ')';
                break;
            case "UnaryExpression" : // e.g. !x +x -x typeof x. Note that ++x and --x will not be supported
                result = '' + node.operator + '(' + this._process(node.expression) + ')';
                if (node.operator === '++' || node.operator === '--') {
                    this._logError('Unary operator ' + node.operator + ' is not allowed');
                }
                break;
            case "PostfixExpression" : // e.g. x++ or x-- (not allowed)
                result = '' + '(' + this._process(node.expression) + ')' + node.operator;
                this._logError('Postfix operator ' + node.operator + ' is not allowed');
                break;
            case "Variable" :
                // return an argument name (e.g. "a0") through _getValue
                result = this._getValue({
                    type : "expression",
                    "category" : "objectref",
                    bound : node.bound,
                    "path" : [node.name]
                });
                break;
            case "PropertyAccess" :
                // we fall in this category when we have sth like xxx.prop or xxx[yyy] where xxx and yyy are expressions
                // in this case 'xxx' corresponds to the 'base' property of the parsed tree and 'yyy' corresponds to the 'name'
                // e.g "a.b", "a.b['c'].d" or "a.b(foo)[blah]"

                // as square-bracket access may contain sub-expressions we have to
                // 1. split the expression in a list of objectrefs / expressions
                //      e.g. for a.b[1+2][2+3].c.d we should have "a.b", "1+2", "2+3", "c", "d"
                // 2. if there is only one chunk, create an objectref
                // 3. otherwise create a dynref with sub-expressions (the 1st one being an objectref cf. a.b in previous example)

                var n = node, path = [], name, dynref=false;
                // determine if we are in an objectref or dynref use case:
                while (n) {
                    name = n.name;
                    if (name.type) {
                        // for person.name -> "name": "name"
                        // for person["name"] -> "name": { "type": "Variable","name": "property","code": "property" }
                        // for person["a"+123] -> "name": {"type": "BinaryExpression", "operator": "+", ...}

                        if (name.type === "expression") {
                            // in this case name is a simple type like number or string:
                            // { type: 'expression', category: 'number', value: 2, code: '2' }
                            path.push(name.value);
                        } else {
                            // name is a complex expression - so we will have to create a dynref instead of objectref
                            dynref=true;
                            break;
                        }
                    } else {
                        path.push(name);
                    }
                    n = n.base;
                }

                if (!dynref) {
                    // std objectref - e.g. "a.b.c"
                    path.reverse();
                    // _getValue will return an argument nbr - e.g. "a1"
                    result = this._getValue({
                        type : "expression",
                        "category" : "objectref",
                        bound : node.bound,
                        "path" : path
                    });
                } else {

                    // dynref: path contains expressions - e.g. a.b[foo][1+2]
                    var exprs=[]; // list of expressions that compose the path
                    n=node;
                    while (n) {
                        name = n.name;
                        if (!name.type) {
                            // name is a string
                            name={ type: 'expression', category: 'string', value: name, code: name };
                        }
                        exprs.push(name);
                        n = n.base;
                    }
                    exprs.reverse();

                    // the first string expressions should be gathered as an objectref
                    var p1=[], e;
                    for (var i=0;exprs.length>i;i++) {
                        e=exprs[i];
                        if (e.type==='expression' && e.category === 'string') {
                            p1.push(e.value);
                            i--;
                            exprs.shift();
                        } else {
                            break;
                        }
                    }

                    // add objectref as first element
                    if (!p1.length) {
                        this._logError('Invalid dynamic data reference!');
                    } else {
                        exprs.splice(0,0,{
                            type : "expression",
                            "category" : "objectref",
                            bound : node.bound,
                            "path" : p1
                        });
                    }

                    // convert all expressions
                    var fragments=[];
                    if (exprs) {
                        for (var i=0;exprs.length>i;i++) {
                            fragments.push(this._process(exprs[i])); // this can be "a1" or "(1+a3)"
                        }
                    }

                    // _getValue will return an argument nbr - e.g. "a1"
                    result = this._getValue({
                        type : "expression",
                        "category" : "dynref",
                        "codefragments" : fragments
                    });
                }
                break;
            case "ConditionalExpression" :
                result = '(' + this._process(node.condition) + '? ' + this._process(node.trueExpression) + ' : '
                        + this._process(node.falseExpression) + ')';
                break;
            case "NewExpression":
                var constr=this._process(node.callee), args=[];
                if (node.arguments) {
                    for (var i=0;node.arguments.length>i;i++) {
                        args.push(this._process(node.arguments[i]));
                    }
                }
                result = 'new ' + constr + '(' + args.join(',') + ')';
                break;
            case "FunctionCall" :
                // this is an object ref
                var n = node.name, path = [];
                while (n) {
                    path.push(n.name);
                    n = n.base;
                }
                path.reverse();

                var n = {
                    type : "expression",
                    "category" : "functionref",
                    bound : node.bound,
                    "path" : path
                };
                result = this._getValue(n);

                // add arguments
                var outArgs = [], args = node.arguments;
                for (var i = 0; i < (args ? args.length : 0); i++) {
                    if (!args[i].category) {
                        // add category otherwise HExpression will not be parsed
                        args[i].category = "jsexpression";
                    }
                    var expr = new HExpression(args[i], this.globalSyntaxTree);
                    outArgs[i] = expr.getSyntaxTree();
                }
                n.args = outArgs;
                break;
            case "CssClassElement" :
                result = "((" + this._process(node.right) + ")? ''+" + this._process(node.left) + ":'')";
                break;
            case "CssClassExpression" :
                var list = node.list, length = list.length, code = [];
                for (var i = 0; i < length; i++) {
                    code[i] = this._process(list[i]);
                }
                if (length < 1) {
                    result = '';
                } else {
                    result = "[" + code.join(",") + "].join(' ')";
                }
                break;
            case "ObjectLiteral":
                var properties = node.properties, length = properties.length, code = [];
                for (var i = 0; i < length; i++) {
                    code[i] = this._process(properties[i]);
                }
                if (length < 1) {
                    result = '';
                } else {
                    result = "{" + code.join(",") + "}";
                }
                break;
            case "PropertyAssignment":
                var name = node.name, child = node.value;
                var code = this._process(child);
                result = name + ":" + code;
                break;
            default :
                this._logError(node.type + '(s) are not supported yet');
                console.warn('[HExpression] ' + node.type + '(s) are not supported yet:');
                console.dir(node);
                break;
        }
        return result;
    },

    /**
     * Returns the code value for a node of type "expression" (i.e. literals, objectrefs...).
     * @param {Object} node the node.
     * @return {String} the value of the node.
     */
    _getValue : function (node) {
        var result = '';
        switch (node.category) {
            case "objectref" :
                var length = this._objectRefs.length, expr, pathLength, ok;

                // check if an identical expression already exist
                for (var i = 0; i < length; i++) {
                    expr = this._objectRefs[i];
                    if (expr.category !== "objectref") {
                        continue;
                    }
                    pathLength = expr.path.length;
                    ok = true;
                    // only the path may vary
                    if (pathLength === node.path.length) {
                        for (var j = 0; j < pathLength; j++) {
                            if (expr.path[j] !== node.path[j]) {
                                ok = false;
                                break;
                            }
                        }
                        if (ok) {
                            result = "a" + i;
                            break;
                        }
                    }
                }

                if (!result) {
                    // objectref doesn't exist in previous expressions
                    result = "a" + length; // argument variable
                    this._objectRefs[length] = node;
                }
                break;
            case "dynref":
                var length = this._objectRefs.length;
                result = "a" + length; // argument variable
                this._objectRefs[length] = node;
                break;
            case "functionref" :
                // add the function call to the object ref list
                // we don't optimize the storeage as it is less likely to have the same combination repeated
                // than with simple object refs
                var length = this._objectRefs.length;
                result = "a" + length; // argument variable
                this._objectRefs[length] = node;
                break;
            case "string" :
                result = '"' + node.value.replace(/\"/g, '\\"') + '"';
                break;
            case "boolean" :
            case "number" :
                result = node.value;
                break;
            case "null" :
                result = "null";
                break;
        }
        return result;
    },

    /**
     * Transforms a node that contains a pipes[] collection into another node
     * that uses function call expressions and that can be processed in a standard way
     */
    _transformPipesIntoFnCalls:function(node) {
        var pipes=node.pipes, p, arg0, args;
        if (!pipes || !pipes.length) {
            return node;
        }

        var nd;
        for (var i=0;pipes.length>i;i++) {
            p=pipes[i];
            // create the node corresponding to the first argument
            if (i===0) {
                arg0={};
                // copy properties from the original node
                for (var k in node) {
                    if (node.hasOwnProperty(k)) {
                        if (k==="expType") {
                            arg0.type=node[k];
                        } else if (k!=="pipes" && k!=="line" && k!=="column" && k!=="bound" && k!=="type" && k!=="category") {
                            arg0[k]=node[k];
                        }
                    }
                }
            } else {
                arg0=nd;
            }
            args=p.args;
            args.splice(0,0,arg0);
            nd={
                "type": "FunctionCall",
                "name": p.fnexpr,
                "arguments": args
            };
        }

        // add general information to the main node
        nd.type="expression";
        nd.category="jsexpression";
        nd.expType="FunctionCall";
        nd.line=node.line;
        nd.column=node.column;
        nd.bound=node.bound;

        return nd;
    }
});
exports.HExpression = HExpression;